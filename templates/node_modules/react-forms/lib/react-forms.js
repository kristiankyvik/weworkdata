module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @copyright 2015, Prometheus Research, LLC
	 */
	
	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _Fieldset2 = __webpack_require__(1);
	
	var _Fieldset3 = _interopRequireDefault(_Fieldset2);
	
	exports.Fieldset = _Fieldset3['default'];
	
	var _Field2 = __webpack_require__(51);
	
	var _Field3 = _interopRequireDefault(_Field2);
	
	exports.Field = _Field3['default'];
	
	var _Value2 = __webpack_require__(60);
	
	var _Value3 = _interopRequireDefault(_Value2);
	
	exports.Value = _Value3['default'];
	
	var _WithFormValue2 = __webpack_require__(80);
	
	var _WithFormValue3 = _interopRequireDefault(_WithFormValue2);
	
	exports.WithFormValue = _WithFormValue3['default'];
	
	var _Schema2 = __webpack_require__(67);
	
	var _Schema = _interopRequireWildcard(_Schema2);
	
	exports.Schema = _Schema;
	
	var _Input2 = __webpack_require__(53);
	
	var _Input3 = _interopRequireDefault(_Input2);
	
	exports.Input = _Input3['default'];
	
	var _ErrorList2 = __webpack_require__(57);
	
	var _ErrorList3 = _interopRequireDefault(_ErrorList2);
	
	exports.ErrorList = _ErrorList3['default'];

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @copyright 2015, Prometheus Research, LLC
	 */
	
	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _reactStylesheet = __webpack_require__(3);
	
	var ReactStylesheet = _interopRequireWildcard(_reactStylesheet);
	
	var _Component2 = __webpack_require__(41);
	
	var _Component3 = _interopRequireDefault(_Component2);
	
	var Fieldset = (function (_Component) {
	  _inherits(Fieldset, _Component);
	
	  function Fieldset() {
	    _classCallCheck(this, _Fieldset);
	
	    _get(Object.getPrototypeOf(_Fieldset.prototype), 'constructor', this).apply(this, arguments);
	  }
	
	  _createClass(Fieldset, [{
	    key: 'render',
	    value: function render() {
	      return _react2['default'].createElement(this.stylesheet.Root, this.props);
	    }
	  }], [{
	    key: 'propTypes',
	    value: _extends({}, _Component3['default'].propTypes, {
	      children: _react.PropTypes.node
	    }),
	    enumerable: true
	  }, {
	    key: 'stylesheet',
	    value: ReactStylesheet.createStylesheet({
	      Root: 'div'
	    }),
	    enumerable: true
	  }]);
	
	  var _Fieldset = Fieldset;
	  Fieldset = ReactStylesheet.styleable(Fieldset) || Fieldset;
	  return Fieldset;
	})(_Component3['default']);
	
	exports['default'] = Fieldset;
	module.exports = exports['default'];

/***/ },
/* 2 */
/***/ function(module, exports) {

	module.exports = require("react");

/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @copyright 2015 Prometheus Research, LLC
	 */
	
	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _attachStylesheet2 = __webpack_require__(4);
	
	var _attachStylesheet3 = _interopRequireDefault(_attachStylesheet2);
	
	exports.attachStylesheet = _attachStylesheet3['default'];
	
	var _styleComponent2 = __webpack_require__(21);
	
	var _styleComponent3 = _interopRequireDefault(_styleComponent2);
	
	exports.styleComponent = _styleComponent3['default'];
	
	var _Stylesheet = __webpack_require__(20);
	
	Object.defineProperty(exports, 'createStylesheet', {
	  enumerable: true,
	  get: function get() {
	    return _Stylesheet.createStylesheet;
	  }
	});
	
	var _styleable2 = __webpack_require__(40);
	
	var _styleable3 = _interopRequireDefault(_styleable2);
	
	exports.styleable = _styleable3['default'];


/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @copyright 2015 Prometheus Research, LLC
	 */
	
	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };
	
	exports['default'] = attachStylesheet;
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _invariant = __webpack_require__(5);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _getComponentDisplayName = __webpack_require__(7);
	
	var _getComponentDisplayName2 = _interopRequireDefault(_getComponentDisplayName);
	
	var _isValidReactComponent = __webpack_require__(8);
	
	var _isValidReactComponent2 = _interopRequireDefault(_isValidReactComponent);
	
	var _transferStaticProperties = __webpack_require__(19);
	
	var _transferStaticProperties2 = _interopRequireDefault(_transferStaticProperties);
	
	var _Stylesheet = __webpack_require__(20);
	
	var Stylesheet = _interopRequireWildcard(_Stylesheet);
	
	function attachStylesheet(Component, spec) {
	  if ((0, _isValidReactComponent2['default'])(Component)) {
	    return attachStylesheetImpl(Component, spec);
	  } else if (spec === undefined) {
	    var _ret = (function () {
	      var spec = Component;
	      return {
	        v: function attachStylesheetDecorator(Component) {
	          return attachStylesheetImpl(Component, spec);
	        }
	      };
	    })();
	
	    if (typeof _ret === 'object') return _ret.v;
	  } else {
	    (0, _invariant2['default'])(false, 'Styleable(...): can only be used as a decorator or factory function');
	  }
	}
	
	function attachStylesheetImpl(Component, spec) {
	  var StyleableComponent = (function (_StyleableComponentDecorator) {
	    _inherits(StyleableComponent, _StyleableComponentDecorator);
	
	    function StyleableComponent() {
	      _classCallCheck(this, StyleableComponent);
	
	      _get(Object.getPrototypeOf(StyleableComponent.prototype), 'constructor', this).apply(this, arguments);
	    }
	
	    _createClass(StyleableComponent, null, [{
	      key: 'displayName',
	      value: 'Styleable(' + (0, _getComponentDisplayName2['default'])(Component) + ')',
	      enumerable: true
	    }, {
	      key: 'stylesheet',
	      value: Stylesheet.createStylesheet(spec),
	      enumerable: true
	    }, {
	      key: 'Component',
	      value: Component,
	      enumerable: true
	    }]);
	
	    return StyleableComponent;
	  })(StyleableComponentDecorator);
	  (0, _transferStaticProperties2['default'])(Component, StyleableComponent, ['Component', 'stylesheet']);
	  return StyleableComponent;
	}
	
	var StyleableComponentDecorator = (function (_React$Component) {
	  _inherits(StyleableComponentDecorator, _React$Component);
	
	  function StyleableComponentDecorator() {
	    _classCallCheck(this, StyleableComponentDecorator);
	
	    _get(Object.getPrototypeOf(StyleableComponentDecorator.prototype), 'constructor', this).apply(this, arguments);
	  }
	
	  _createClass(StyleableComponentDecorator, [{
	    key: 'render',
	    value: function render() {
	      var _constructor = this.constructor;
	      var Component = _constructor.Component;
	      var stylesheet = _constructor.stylesheet;
	
	      return _react2['default'].createElement(Component, _extends({ stylesheet: stylesheet }, this.props));
	    }
	  }], [{
	    key: 'style',
	    value: function style(spec) {
	      var _this = this;
	
	      var stylesheet = Stylesheet.overrideStylesheet(this.stylesheet, spec);
	      var StyleableComponent = (function (_StyleableComponentDecorator2) {
	        _inherits(StyleableComponent, _StyleableComponentDecorator2);
	
	        function StyleableComponent() {
	          _classCallCheck(this, StyleableComponent);
	
	          _get(Object.getPrototypeOf(StyleableComponent.prototype), 'constructor', this).apply(this, arguments);
	        }
	
	        _createClass(StyleableComponent, null, [{
	          key: 'stylesheet',
	          value: stylesheet,
	          enumerable: true
	        }, {
	          key: 'Component',
	          value: _this.Component,
	          enumerable: true
	        }, {
	          key: 'displayName',
	          value: _this.displayName,
	          enumerable: true
	        }]);
	
	        return StyleableComponent;
	      })(StyleableComponentDecorator);
	      (0, _transferStaticProperties2['default'])(this.Component, StyleableComponent, ['Component', 'stylesheet']);
	      return StyleableComponent;
	    }
	  }, {
	    key: 'stylesheet',
	    value: null,
	    enumerable: true
	  }, {
	    key: 'Component',
	    value: null,
	    enumerable: true
	  }]);
	
	  return StyleableComponentDecorator;
	})(_react2['default'].Component);
	
	module.exports = exports['default'];


/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 */
	
	'use strict';
	
	/**
	 * Use invariant() to assert state which your program assumes to be true.
	 *
	 * Provide sprintf-style format (only %s is supported) and arguments
	 * to provide information about what broke and what you were
	 * expecting.
	 *
	 * The invariant message will be stripped in production, but the invariant
	 * will remain to ensure logic does not differ in production.
	 */
	
	var invariant = function(condition, format, a, b, c, d, e, f) {
	  if (process.env.NODE_ENV !== 'production') {
	    if (format === undefined) {
	      throw new Error('invariant requires an error message argument');
	    }
	  }
	
	  if (!condition) {
	    var error;
	    if (format === undefined) {
	      error = new Error(
	        'Minified exception occurred; use the non-minified dev environment ' +
	        'for the full error message and additional helpful warnings.'
	      );
	    } else {
	      var args = [a, b, c, d, e, f];
	      var argIndex = 0;
	      error = new Error(
	        format.replace(/%s/g, function() { return args[argIndex++]; })
	      );
	      error.name = 'Invariant Violation';
	    }
	
	    error.framesToPop = 1; // we don't care about invariant's own frame
	    throw error;
	  }
	};
	
	module.exports = invariant;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(6)))

/***/ },
/* 6 */
/***/ function(module, exports) {

	// shim for using process in browser
	
	var process = module.exports = {};
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;
	
	function cleanUpNextTick() {
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}
	
	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = setTimeout(cleanUpNextTick);
	    draining = true;
	
	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    clearTimeout(timeout);
	}
	
	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        setTimeout(drainQueue, 0);
	    }
	};
	
	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};
	
	function noop() {}
	
	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;
	
	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};
	
	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ },
/* 7 */
/***/ function(module, exports) {

	/**
	 * @copyright 2015 Prometheus Research, LLC
	 */
	
	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = getComponentDisplayName;
	
	function getComponentDisplayName(Component) {
	  return typeof Component === 'string' ? Component : Component.displayName || Component.name;
	}
	
	module.exports = exports['default'];


/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @copyright 2015 Prometheus Research, LLC
	 */
	
	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = isValidReactComponent;
	
	var _Utils = __webpack_require__(9);
	
	/**
	 * Loose check if the argument is a valid React component.
	 */
	
	function isValidReactComponent(Component) {
	  return (0, _Utils.isString)(Component) || (0, _Utils.isFunction)(Component);
	}
	
	module.exports = exports['default'];


/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @copyright 2015, Prometheus Research, LLC
	 */
	
	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _isArray2 = __webpack_require__(10);
	
	var _isArray3 = _interopRequireDefault(_isArray2);
	
	exports.isArray = _isArray3['default'];
	
	var _isPlainObject2 = __webpack_require__(11);
	
	var _isPlainObject3 = _interopRequireDefault(_isPlainObject2);
	
	exports.isPlainObject = _isPlainObject3['default'];
	
	var _isFunction2 = __webpack_require__(13);
	
	var _isFunction3 = _interopRequireDefault(_isFunction2);
	
	exports.isFunction = _isFunction3['default'];
	
	var _isString2 = __webpack_require__(14);
	
	var _isString3 = _interopRequireDefault(_isString2);
	
	exports.isString = _isString3['default'];
	
	var _toSlugCase = __webpack_require__(15);
	
	var _toSlugCase2 = _interopRequireDefault(_toSlugCase);
	
	exports.toDashCase = _toSlugCase2['default'];
	
	var _ampUniqueId = __webpack_require__(18);
	
	var _ampUniqueId2 = _interopRequireDefault(_ampUniqueId);
	
	exports.uniqueID = _ampUniqueId2['default'];


/***/ },
/* 10 */
/***/ function(module, exports) {

	
	/**
	 * isArray
	 */
	
	var isArray = Array.isArray;
	
	/**
	 * toString
	 */
	
	var str = Object.prototype.toString;
	
	/**
	 * Whether or not the given `val`
	 * is an array.
	 *
	 * example:
	 *
	 *        isArray([]);
	 *        // > true
	 *        isArray(arguments);
	 *        // > false
	 *        isArray('');
	 *        // > false
	 *
	 * @param {mixed} val
	 * @return {bool}
	 */
	
	module.exports = isArray || function (val) {
	  return !! val && '[object Array]' == str.call(val);
	};


/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
	 *
	 * Copyright (c) 2014-2015, Jon Schlinkert.
	 * Licensed under the MIT License.
	 */
	
	'use strict';
	
	var isObject = __webpack_require__(12);
	
	function isObjectObject(o) {
	  return isObject(o) === true
	    && Object.prototype.toString.call(o) === '[object Object]';
	}
	
	module.exports = function isPlainObject(o) {
	  var ctor,prot;
	  
	  if (isObjectObject(o) === false) return false;
	  
	  // If has modified constructor
	  ctor = o.constructor;
	  if (typeof ctor !== 'function') return false;
	  
	  // If has modified prototype
	  prot = ctor.prototype;
	  if (isObjectObject(prot) === false) return false;
	  
	  // If constructor does not have an Object-specific method
	  if (prot.hasOwnProperty('isPrototypeOf') === false) {
	    return false;
	  }
	  
	  // Most likely a plain Object
	  return true;
	};


/***/ },
/* 12 */
/***/ function(module, exports) {

	/*!
	 * isobject <https://github.com/jonschlinkert/isobject>
	 *
	 * Copyright (c) 2014-2015, Jon Schlinkert.
	 * Licensed under the MIT License.
	 */
	
	'use strict';
	
	module.exports = function isObject(val) {
	  return val != null && typeof val === 'object'
	    && !Array.isArray(val);
	};


/***/ },
/* 13 */
/***/ function(module, exports) {

	module.exports = isFunction
	
	var toString = Object.prototype.toString
	
	function isFunction (fn) {
	  var string = toString.call(fn)
	  return string === '[object Function]' ||
	    (typeof fn === 'function' && string !== '[object RegExp]') ||
	    (typeof window !== 'undefined' &&
	     // IE8 and below
	     (fn === window.setTimeout ||
	      fn === window.alert ||
	      fn === window.confirm ||
	      fn === window.prompt))
	};


/***/ },
/* 14 */
/***/ function(module, exports) {

	'use strict';
	
	var strValue = String.prototype.valueOf;
	var tryStringObject = function tryStringObject(value) {
		try {
			strValue.call(value);
			return true;
		} catch (e) {
			return false;
		}
	};
	var toStr = Object.prototype.toString;
	var strClass = '[object String]';
	var hasToStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';
	
	module.exports = function isString(value) {
		if (typeof value === 'string') { return true; }
		if (typeof value !== 'object') { return false; }
		return hasToStringTag ? tryStringObject(value) : toStr.call(value) === strClass;
	};


/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	
	var toSpace = __webpack_require__(16);
	
	
	/**
	 * Expose `toSlugCase`.
	 */
	
	module.exports = toSlugCase;
	
	
	/**
	 * Convert a `string` to slug case.
	 *
	 * @param {String} string
	 * @return {String}
	 */
	
	
	function toSlugCase (string) {
	  return toSpace(string).replace(/\s/g, '-');
	}

/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	
	var clean = __webpack_require__(17);
	
	
	/**
	 * Expose `toSpaceCase`.
	 */
	
	module.exports = toSpaceCase;
	
	
	/**
	 * Convert a `string` to space case.
	 *
	 * @param {String} string
	 * @return {String}
	 */
	
	
	function toSpaceCase (string) {
	  return clean(string).replace(/[\W_]+(.|$)/g, function (matches, match) {
	    return match ? ' ' + match : '';
	  });
	}

/***/ },
/* 17 */
/***/ function(module, exports) {

	
	/**
	 * Expose `toNoCase`.
	 */
	
	module.exports = toNoCase;
	
	
	/**
	 * Test whether a string is camel-case.
	 */
	
	var hasSpace = /\s/;
	var hasCamel = /[a-z][A-Z]/;
	var hasSeparator = /[\W_]/;
	
	
	/**
	 * Remove any starting case from a `string`, like camel or snake, but keep
	 * spaces and punctuation that may be important otherwise.
	 *
	 * @param {String} string
	 * @return {String}
	 */
	
	function toNoCase (string) {
	  if (hasSpace.test(string)) return string.toLowerCase();
	
	  if (hasSeparator.test(string)) string = unseparate(string);
	  if (hasCamel.test(string)) string = uncamelize(string);
	  return string.toLowerCase();
	}
	
	
	/**
	 * Separator splitter.
	 */
	
	var separatorSplitter = /[\W_]+(.|$)/g;
	
	
	/**
	 * Un-separate a `string`.
	 *
	 * @param {String} string
	 * @return {String}
	 */
	
	function unseparate (string) {
	  return string.replace(separatorSplitter, function (m, next) {
	    return next ? ' ' + next : '';
	  });
	}
	
	
	/**
	 * Camelcase splitter.
	 */
	
	var camelSplitter = /(.)([A-Z]+)/g;
	
	
	/**
	 * Un-camelcase a `string`.
	 *
	 * @param {String} string
	 * @return {String}
	 */
	
	function uncamelize (string) {
	  return string.replace(camelSplitter, function (m, previous, uppers) {
	    return previous + ' ' + uppers.toLowerCase().split('').join(' ');
	  });
	}

/***/ },
/* 18 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {/*global window, global*/
	var theGlobal = (typeof window !== 'undefined') ? window : global;
	if (!theGlobal.__ampIdCounter) {
	    theGlobal.__ampIdCounter = 0;
	}
	
	
	module.exports = function uniqueId(prefix) {
	    var id = ++theGlobal.__ampIdCounter + '';
	    return prefix ? prefix + id : id;
	};
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 19 */
/***/ function(module, exports) {

	/**
	 * @copyright 2015, Prometheus Research, LLC
	 */
	
	// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function
	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports["default"] = transferStaticProperties;
	var FUNCTION_STATIC_PROPERTIES = {
	  arguments: true,
	  arity: true,
	  caller: true,
	  length: true,
	  name: true,
	  displayName: true,
	  prototype: true
	};
	
	/**
	 * Transfer all static properties and methods from `source` to `target`.
	 */
	
	function transferStaticProperties(source, target) {
	  var ignoreKeys = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];
	
	  var keys = Object.getOwnPropertyNames(source);
	  for (var i = 0; i < keys.length; i++) {
	    var key = keys[i];
	    if (!source.hasOwnProperty(key)) {
	      continue;
	    }
	    if (FUNCTION_STATIC_PROPERTIES[key]) {
	      continue;
	    }
	    if (ignoreKeys && ignoreKeys.indexOf(key) > -1) {
	      continue;
	    }
	    target[key] = source[key];
	  }
	}
	
	module.exports = exports["default"];


/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @copyright 2015, Prometheus Research, LLC
	 */
	
	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	exports.createStylesheet = createStylesheet;
	exports.isValidStylesheet = isValidStylesheet;
	exports.overrideStylesheet = overrideStylesheet;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }
	
	var _invariant = __webpack_require__(5);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _isValidReactComponent = __webpack_require__(8);
	
	var _isValidReactComponent2 = _interopRequireDefault(_isValidReactComponent);
	
	var _styleComponent = __webpack_require__(21);
	
	var _styleComponent2 = _interopRequireDefault(_styleComponent);
	
	/**
	 * Create stylesheet from stylesheet spec.
	 */
	
	function createStylesheet(spec) {
	  var stylesheet = {};
	  for (var key in spec) {
	    if (!spec.hasOwnProperty(key)) {
	      continue;
	    }
	    var item = spec[key];
	    if ((0, _isValidReactComponent2['default'])(item)) {
	      stylesheet[key] = item;
	    } else {
	      var _item$Component = item.Component;
	      var Component = _item$Component === undefined ? 'div' : _item$Component;
	
	      var componentStylesheet = _objectWithoutProperties(item, ['Component']);
	
	      Component = (0, _styleComponent2['default'])(Component, componentStylesheet);
	      stylesheet[key] = Component;
	    }
	  }
	  return stylesheet;
	}
	
	/**
	 * Check if object is a valid stylesheet.
	 *
	 * Object is a stylesheet if every value is a valid React component.
	 */
	
	function isValidStylesheet(obj) {
	  for (var key in obj) {
	    if (!obj.hasOwnProperty(key)) {
	      continue;
	    }
	    if (!(0, _isValidReactComponent2['default'])(obj[key])) {
	      return false;
	    }
	  }
	  return true;
	}
	
	/**
	 * Produce a new stylesheet by overriding keys from the original stylesheet with
	 * values from spec.
	 *
	 * Note that as stylesheet is also a valid spec then this function can be used
	 * to override one stylesheet with another.
	 */
	
	function overrideStylesheet(stylesheet, spec) {
	  (0, _invariant2['default'])(isValidStylesheet(stylesheet), 'overrideStylesheet(...): first argument should be a valid stylesheet');
	  stylesheet = _extends({}, stylesheet);
	  for (var key in spec) {
	    if (!spec.hasOwnProperty(key)) {
	      continue;
	    }
	    (0, _invariant2['default'])(stylesheet[key] !== undefined, 'overrideStylesheet(...): invalid override, stylesheet does not have key "%s"', key);
	    var item = spec[key];
	    if ((0, _isValidReactComponent2['default'])(item)) {
	      stylesheet[key] = item;
	    } else {
	      var _spec$key = spec[key];
	      var _spec$key$Component = _spec$key.Component;
	      var Component = _spec$key$Component === undefined ? stylesheet[key] : _spec$key$Component;
	
	      var componentStylesheet = _objectWithoutProperties(_spec$key, ['Component']);
	
	      stylesheet[key] = (0, _styleComponent2['default'])(Component, componentStylesheet);
	    }
	  }
	  return stylesheet;
	}


/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @copyright 2015 Prometheus Research, LLC
	 */
	
	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _get = function get(_x2, _x3, _x4) { var _again = true; _function: while (_again) { var object = _x2, property = _x3, receiver = _x4; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x2 = parent; _x3 = property; _x4 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };
	
	exports['default'] = styleComponent;
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var _invariant = __webpack_require__(5);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _DOMStylesheet = __webpack_require__(22);
	
	var DOMStylesheet = _interopRequireWildcard(_DOMStylesheet);
	
	var _StyleableDOMComponent2 = __webpack_require__(38);
	
	var _StyleableDOMComponent3 = _interopRequireDefault(_StyleableDOMComponent2);
	
	var _isValidReactComponent = __webpack_require__(8);
	
	var _isValidReactComponent2 = _interopRequireDefault(_isValidReactComponent);
	
	var _getComponentDisplayName = __webpack_require__(7);
	
	var _getComponentDisplayName2 = _interopRequireDefault(_getComponentDisplayName);
	
	/**
	 * Apply a stylesheet to a component.
	 */
	
	function styleComponent(Component, stylesheet) {
	  var name = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];
	
	  (0, _invariant2['default'])((0, _isValidReactComponent2['default'])(Component), 'Expected a valid React component, got: %s', typeof Component);
	  if (typeof Component.style === 'function') {
	    return Component.style(stylesheet);
	  } else {
	    if (!DOMStylesheet.isValidStylesheet(stylesheet)) {
	      name = name || (0, _getComponentDisplayName2['default'])(Component);
	      stylesheet = DOMStylesheet.createStylesheet(stylesheet, name);
	    }
	    return styleDOMComponent(Component, stylesheet);
	  }
	}
	
	function styleDOMComponent(Component, spec) {
	  return (function (_StyleableDOMComponent) {
	    _inherits(_class, _StyleableDOMComponent);
	
	    function _class() {
	      _classCallCheck(this, _class);
	
	      _get(Object.getPrototypeOf(_class.prototype), 'constructor', this).apply(this, arguments);
	    }
	
	    _createClass(_class, null, [{
	      key: 'displayName',
	      value: 'StyleableDOMComponent(' + (0, _getComponentDisplayName2['default'])(Component) + ')',
	      enumerable: true
	    }, {
	      key: 'Component',
	      value: Component,
	      enumerable: true
	    }, {
	      key: 'stylesheet',
	      value: spec,
	      enumerable: true
	    }]);
	
	    return _class;
	  })(_StyleableDOMComponent3['default']);
	}
	module.exports = exports['default'];


/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @copyright 2015 Prometheus Research, LLC
	 */
	
	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _createDecoratedClass = (function () { function defineProperties(target, descriptors, initializers) { for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === 'function') { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator); } } if (descriptor.initializer !== undefined) { initializers[key] = descriptor; continue; } } Object.defineProperty(target, key, descriptor); } } return function (Constructor, protoProps, staticProps, protoInitializers, staticInitializers) { if (protoProps) defineProperties(Constructor.prototype, protoProps, protoInitializers); if (staticProps) defineProperties(Constructor, staticProps, staticInitializers); return Constructor; }; })();
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	exports.createStylesheet = createStylesheet;
	exports.isValidStylesheet = isValidStylesheet;
	exports.overrideStylesheet = overrideStylesheet;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	var _memoizeDecorator = __webpack_require__(23);
	
	var _memoizeDecorator2 = _interopRequireDefault(_memoizeDecorator);
	
	var _styleLoaderAddStyles = __webpack_require__(24);
	
	var _styleLoaderAddStyles2 = _interopRequireDefault(_styleLoaderAddStyles);
	
	var _reactLibCSSPropertyOperations = __webpack_require__(25);
	
	var _reactLibCSSPropertyOperations2 = _interopRequireDefault(_reactLibCSSPropertyOperations);
	
	var _reactLibDangerousStyleValue = __webpack_require__(31);
	
	var _reactLibDangerousStyleValue2 = _interopRequireDefault(_reactLibDangerousStyleValue);
	
	var _Utils = __webpack_require__(9);
	
	/**
	 * Special key which designates the rules which should be applied even if no
	 * variant is being active.
	 */
	var BASE = 'base';
	
	/**
	 * Special key which is used to store className in mapping.
	 */
	var CLASSNAME = 'className';
	
	/**
	 * Styles we want to be added to every CSS class.
	 */
	var DEFAULT_STYLE = {
	  boxSizing: 'border-box'
	};
	
	/**
	 * Variant names we want to see compiled as CSS pseudo classes.
	 */
	var SUPPORTED_PSEUDO_CLASSES = {
	  focus: true,
	  hover: true,
	  active: true,
	  checked: true,
	  'default': true,
	  disabled: true,
	  empty: true,
	  enabled: true,
	  firstChild: true,
	  fullscreen: true,
	  indeterminate: true,
	  invalid: true,
	  lastChild: true,
	  left: true,
	  link: true,
	  onlyChild: true,
	  optional: true,
	  required: true,
	  right: true,
	  root: true,
	  scope: true,
	  target: true,
	  valid: true,
	  visited: true
	};
	
	/**
	 * Create a new stylesheet from stylesheet spec.
	 */
	
	function createStylesheet(spec) {
	  var id = arguments.length <= 1 || arguments[1] === undefined ? '' : arguments[1];
	
	  id = (0, _Utils.uniqueID)(id ? 'Style_' + id : 'Style');
	  return new DOMStylesheet(parseSpecToStyle(spec), id);
	}
	
	/**
	 * Check if object is a valida stylesheet.
	 */
	
	function isValidStylesheet(obj) {
	  return obj instanceof DOMStylesheet;
	}
	
	/**
	 * Produce a new stylesheet by overriding an existing one with a new stylesheet
	 * spec.
	 */
	
	function overrideStylesheet(stylesheet, override, id) {
	  override = isValidStylesheet(override) ? override.style : parseSpecToStyle(override);
	  var style = overrideStyle(stylesheet.style, override);
	  id = (0, _Utils.uniqueID)(id ? 'Style_' + id : 'Style');
	  return new DOMStylesheet(style, id);
	}
	
	function overrideStyle(style, override) {
	  var nextStyle = _extends({}, style);
	  for (var key in override) {
	    if (!override.hasOwnProperty(key)) {
	      continue;
	    }
	    if (key === BASE) {
	      nextStyle[key] = _extends({}, nextStyle[key], override[key]);
	    } else {
	      nextStyle[key] = overrideStyle(nextStyle[key], override[key]);
	    }
	  }
	  return nextStyle;
	}
	
	/**
	 * DOM stylesheet is a collection of classes which are applied to a single DOM
	 * element.
	 */
	
	var DOMStylesheet = (function () {
	  function DOMStylesheet(style, id) {
	    _classCallCheck(this, DOMStylesheet);
	
	    this.style = style;
	    this.id = id;
	
	    this._refs = 0;
	    this._remove = null;
	    this._disposePerform = this._disposePerform.bind(this);
	    this._disposeTimer = null;
	  }
	
	  /**
	   * Resolve variant to CSS class name.
	   */
	
	  _createDecoratedClass(DOMStylesheet, [{
	    key: 'asClassName',
	    value: function asClassName() {
	      var variant = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	
	      return resolveVariantToClassName(this.mapping, variant).join(' ');
	    }
	  }, {
	    key: 'use',
	    value: function use() {
	      this._refs = this._refs + 1;
	      if (this._disposeTimer !== null) {
	        clearTimeout(this._disposeTimer);
	        this._disposeTimer = null;
	      }
	      if (this._remove === null) {
	        this._remove = (0, _styleLoaderAddStyles2['default'])(this.css);
	      }
	      return this;
	    }
	  }, {
	    key: 'dispose',
	    value: function dispose() {
	      this._refs = this._refs - 1;
	      if (this._disposeTimer === null) {
	        this._disposeTimer = setTimeout(this._disposePerform, 0);
	      }
	      return this;
	    }
	  }, {
	    key: '_disposePerform',
	    value: function _disposePerform() {
	      if (this._refs < 1) {
	        this._remove();
	        this._remove = null;
	      }
	    }
	  }, {
	    key: '_compiled',
	    decorators: [_memoizeDecorator2['default']],
	    get: function get() {
	      return compileStyle(this.style, this.id);
	    }
	  }, {
	    key: 'css',
	    get: function get() {
	      return [[this.id, this._compiled.css.join('\n')]];
	    }
	  }, {
	    key: 'mapping',
	    get: function get() {
	      return this._compiled.mapping;
	    }
	  }]);
	
	  return DOMStylesheet;
	})();
	
	function resolveVariantToClassName(mapping, variant) {
	  var classList = [];
	
	  for (var key in mapping) {
	    if (key === CLASSNAME) {
	      classList.push(mapping[key]);
	    } else if (variant[key]) {
	      var subClassList = resolveVariantToClassName(mapping[key], variant);
	      for (var i = 0; i < subClassList.length; i++) {
	        classList.push(subClassList[i]);
	      }
	    }
	  }
	
	  return classList;
	}
	
	/**
	 * Parse style spec to style object.
	 */
	function parseSpecToStyle(spec) {
	  var root = arguments.length <= 1 || arguments[1] === undefined ? true : arguments[1];
	
	  var styleBase = root ? _extends({}, DEFAULT_STYLE) : {};
	  var style = _defineProperty({}, BASE, styleBase);
	  for (var key in spec) {
	    if (!spec.hasOwnProperty(key)) {
	      continue;
	    }
	    var item = spec[key];
	    if ((0, _Utils.isPlainObject)(item)) {
	      style[key] = parseSpecToStyle(item, false);
	    } else {
	      styleBase[key] = _value(key, item);
	    }
	  }
	  return style;
	}
	
	/**
	 * Compile style into CSS string with mapping from variant names to CSS class
	 * names.
	 */
	function compileStyle(style, id) {
	  var path = arguments.length <= 2 || arguments[2] === undefined ? [] : arguments[2];
	  var variant = arguments.length <= 3 || arguments[3] === undefined ? null : arguments[3];
	
	  var mapping = {};
	  var css = [];
	  for (var key in style) {
	    if (!style.hasOwnProperty(key)) {
	      continue;
	    }
	    var value = style[key];
	    if (key === BASE) {
	      if (variant !== null) {
	        var className = _className(id, path, variant);
	        mapping[variant] = mapping[variant] || {};
	        mapping[variant][CLASSNAME] = className;
	
	        if (SUPPORTED_PSEUDO_CLASSES[variant]) {
	          var pseudoClassName = _className(id, path, variant, true);
	          css.push(compileClass('.' + className + ', .' + pseudoClassName, value));
	        } else {
	          css.push(compileClass('.' + className, value));
	        }
	      } else {
	        css.push(compileClass('.' + id, value));
	        mapping[CLASSNAME] = id;
	      }
	    } else {
	      var nextPath = variant === null ? path : path.concat(variant);
	      var subResult = compileStyle(value, id, nextPath, key);
	      mapping[key] = subResult.mapping;
	      css = css.concat(subResult.css);
	    }
	  }
	  return { css: css, mapping: mapping };
	}
	
	/**
	 * Compile class name and rule set into CSS class.
	 */
	function compileClass(className, ruleSet) {
	  var css = className + ' { ' + _reactLibCSSPropertyOperations2['default'].createMarkupForStyles(ruleSet) + ' }';
	  return css;
	}
	
	/**
	 * Create a CSS class name.
	 */
	function _className(id, path, variant) {
	  var asPseudo = arguments.length <= 3 || arguments[3] === undefined ? false : arguments[3];
	
	  var className = '' + id;
	  if (path.length > 0) {
	    className = className + ('--' + path.join('--'));
	  }
	  if (variant) {
	    if (asPseudo) {
	      className = className + (':' + (0, _Utils.toDashCase)(variant));
	    } else {
	      className = className + ('--' + variant);
	    }
	  }
	  return className;
	}
	
	/**
	 * Process ruleSet value.
	 */
	function _value(key, value) {
	  if ((0, _Utils.isArray)(value) && value.length > 0) {
	    var rest = value.slice(1).map(function (v) {
	      return key + ':' + (0, _reactLibDangerousStyleValue2['default'])(key, v);
	    });
	    value = [(0, _reactLibDangerousStyleValue2['default'])(key, value[0])].concat(rest).join(';');
	  }
	  return value;
	}


/***/ },
/* 23 */
/***/ function(module, exports) {

	'use strict';
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = memoize;
	/**
	 * @copyright 2015, Andrey Popp <8mayday@gmail.com>
	 */
	
	var SENTINEL = {};
	
	function memoize(target, name, descriptor) {
	  if (typeof descriptor.value === 'function') {
	    return _memoizeMethod(target, name, descriptor);
	  } else if (typeof descriptor.get === 'function') {
	    return _memoizeGetter(target, name, descriptor);
	  } else {
	    throw new Error('@memoize decorator can be applied to methods or getters, got ' + String(descriptor.value) + ' instead');
	  }
	}
	
	function _memoizeGetter(target, name, descriptor) {
	  var memoizedName = '_memoized_' + name;
	  var get = descriptor.get;
	  target[memoizedName] = SENTINEL;
	  return _extends({}, descriptor, {
	    get: (function (_get) {
	      function get() {
	        return _get.apply(this, arguments);
	      }
	
	      get.toString = function () {
	        return _get.toString();
	      };
	
	      return get;
	    })(function () {
	      if (this[memoizedName] === SENTINEL) {
	        this[memoizedName] = get.call(this);
	      }
	      return this[memoizedName];
	    })
	  });
	}
	
	function _memoizeMethod(target, name, descriptor) {
	  if (descriptor.value.length > 0) {
	    throw new Error('@memoize decorator can only be applied to methods of zero arguments');
	  }
	  var memoizedName = '_memoized_' + name;
	  var value = descriptor.value;
	  target[memoizedName] = SENTINEL;
	  return _extends({}, descriptor, {
	    value: (function (_value) {
	      function value() {
	        return _value.apply(this, arguments);
	      }
	
	      value.toString = function () {
	        return _value.toString();
	      };
	
	      return value;
	    })(function () {
	      if (this[memoizedName] === SENTINEL) {
	        this[memoizedName] = value.call(this);
	      }
	      return this[memoizedName];
	    })
	  });
	}
	module.exports = exports['default'];


/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var stylesInDom = {},
		memoize = function(fn) {
			var memo;
			return function () {
				if (typeof memo === "undefined") memo = fn.apply(this, arguments);
				return memo;
			};
		},
		isOldIE = memoize(function() {
			return /msie [6-9]\b/.test(window.navigator.userAgent.toLowerCase());
		}),
		getHeadElement = memoize(function () {
			return document.head || document.getElementsByTagName("head")[0];
		}),
		singletonElement = null,
		singletonCounter = 0;
	
	module.exports = function(list, options) {
		if(false) {
			if(typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
		}
	
		options = options || {};
		// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
		// tags it will allow on a page
		if (typeof options.singleton === "undefined") options.singleton = isOldIE();
	
		var styles = listToStyles(list);
		addStylesToDom(styles, options);
	
		return function update(newList) {
			var mayRemove = [];
			for(var i = 0; i < styles.length; i++) {
				var item = styles[i];
				var domStyle = stylesInDom[item.id];
				domStyle.refs--;
				mayRemove.push(domStyle);
			}
			if(newList) {
				var newStyles = listToStyles(newList);
				addStylesToDom(newStyles, options);
			}
			for(var i = 0; i < mayRemove.length; i++) {
				var domStyle = mayRemove[i];
				if(domStyle.refs === 0) {
					for(var j = 0; j < domStyle.parts.length; j++)
						domStyle.parts[j]();
					delete stylesInDom[domStyle.id];
				}
			}
		};
	}
	
	function addStylesToDom(styles, options) {
		for(var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];
			if(domStyle) {
				domStyle.refs++;
				for(var j = 0; j < domStyle.parts.length; j++) {
					domStyle.parts[j](item.parts[j]);
				}
				for(; j < item.parts.length; j++) {
					domStyle.parts.push(addStyle(item.parts[j], options));
				}
			} else {
				var parts = [];
				for(var j = 0; j < item.parts.length; j++) {
					parts.push(addStyle(item.parts[j], options));
				}
				stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
			}
		}
	}
	
	function listToStyles(list) {
		var styles = [];
		var newStyles = {};
		for(var i = 0; i < list.length; i++) {
			var item = list[i];
			var id = item[0];
			var css = item[1];
			var media = item[2];
			var sourceMap = item[3];
			var part = {css: css, media: media, sourceMap: sourceMap};
			if(!newStyles[id])
				styles.push(newStyles[id] = {id: id, parts: [part]});
			else
				newStyles[id].parts.push(part);
		}
		return styles;
	}
	
	function createStyleElement() {
		var styleElement = document.createElement("style");
		var head = getHeadElement();
		styleElement.type = "text/css";
		head.appendChild(styleElement);
		return styleElement;
	}
	
	function createLinkElement() {
		var linkElement = document.createElement("link");
		var head = getHeadElement();
		linkElement.rel = "stylesheet";
		head.appendChild(linkElement);
		return linkElement;
	}
	
	function addStyle(obj, options) {
		var styleElement, update, remove;
	
		if (options.singleton) {
			var styleIndex = singletonCounter++;
			styleElement = singletonElement || (singletonElement = createStyleElement());
			update = applyToSingletonTag.bind(null, styleElement, styleIndex, false);
			remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);
		} else if(obj.sourceMap &&
			typeof URL === "function" &&
			typeof URL.createObjectURL === "function" &&
			typeof URL.revokeObjectURL === "function" &&
			typeof Blob === "function" &&
			typeof btoa === "function") {
			styleElement = createLinkElement();
			update = updateLink.bind(null, styleElement);
			remove = function() {
				styleElement.parentNode.removeChild(styleElement);
				if(styleElement.href)
					URL.revokeObjectURL(styleElement.href);
			};
		} else {
			styleElement = createStyleElement();
			update = applyToTag.bind(null, styleElement);
			remove = function() {
				styleElement.parentNode.removeChild(styleElement);
			};
		}
	
		update(obj);
	
		return function updateStyle(newObj) {
			if(newObj) {
				if(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)
					return;
				update(obj = newObj);
			} else {
				remove();
			}
		};
	}
	
	var replaceText = (function () {
		var textStore = [];
	
		return function (index, replacement) {
			textStore[index] = replacement;
			return textStore.filter(Boolean).join('\n');
		};
	})();
	
	function applyToSingletonTag(styleElement, index, remove, obj) {
		var css = remove ? "" : obj.css;
	
		if (styleElement.styleSheet) {
			styleElement.styleSheet.cssText = replaceText(index, css);
		} else {
			var cssNode = document.createTextNode(css);
			var childNodes = styleElement.childNodes;
			if (childNodes[index]) styleElement.removeChild(childNodes[index]);
			if (childNodes.length) {
				styleElement.insertBefore(cssNode, childNodes[index]);
			} else {
				styleElement.appendChild(cssNode);
			}
		}
	}
	
	function applyToTag(styleElement, obj) {
		var css = obj.css;
		var media = obj.media;
		var sourceMap = obj.sourceMap;
	
		if(media) {
			styleElement.setAttribute("media", media)
		}
	
		if(styleElement.styleSheet) {
			styleElement.styleSheet.cssText = css;
		} else {
			while(styleElement.firstChild) {
				styleElement.removeChild(styleElement.firstChild);
			}
			styleElement.appendChild(document.createTextNode(css));
		}
	}
	
	function updateLink(linkElement, obj) {
		var css = obj.css;
		var media = obj.media;
		var sourceMap = obj.sourceMap;
	
		if(sourceMap) {
			// http://stackoverflow.com/a/26603875
			css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
		}
	
		var blob = new Blob([css], { type: "text/css" });
	
		var oldSrc = linkElement.href;
	
		linkElement.href = URL.createObjectURL(blob);
	
		if(oldSrc)
			URL.revokeObjectURL(oldSrc);
	}


/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule CSSPropertyOperations
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var CSSProperty = __webpack_require__(26);
	var ExecutionEnvironment = __webpack_require__(27);
	var ReactPerf = __webpack_require__(28);
	
	var camelizeStyleName = __webpack_require__(29);
	var dangerousStyleValue = __webpack_require__(31);
	var hyphenateStyleName = __webpack_require__(32);
	var memoizeStringOnly = __webpack_require__(34);
	var warning = __webpack_require__(35);
	
	var processStyleName = memoizeStringOnly(function (styleName) {
	  return hyphenateStyleName(styleName);
	});
	
	var hasShorthandPropertyBug = false;
	var styleFloatAccessor = 'cssFloat';
	if (ExecutionEnvironment.canUseDOM) {
	  var tempStyle = document.createElement('div').style;
	  try {
	    // IE8 throws "Invalid argument." if resetting shorthand style properties.
	    tempStyle.font = '';
	  } catch (e) {
	    hasShorthandPropertyBug = true;
	  }
	  // IE8 only supports accessing cssFloat (standard) as styleFloat
	  if (document.documentElement.style.cssFloat === undefined) {
	    styleFloatAccessor = 'styleFloat';
	  }
	}
	
	if (process.env.NODE_ENV !== 'production') {
	  // 'msTransform' is correct, but the other prefixes should be capitalized
	  var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;
	
	  // style values shouldn't contain a semicolon
	  var badStyleValueWithSemicolonPattern = /;\s*$/;
	
	  var warnedStyleNames = {};
	  var warnedStyleValues = {};
	
	  var warnHyphenatedStyleName = function (name) {
	    if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
	      return;
	    }
	
	    warnedStyleNames[name] = true;
	    process.env.NODE_ENV !== 'production' ? warning(false, 'Unsupported style property %s. Did you mean %s?', name, camelizeStyleName(name)) : undefined;
	  };
	
	  var warnBadVendoredStyleName = function (name) {
	    if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
	      return;
	    }
	
	    warnedStyleNames[name] = true;
	    process.env.NODE_ENV !== 'production' ? warning(false, 'Unsupported vendor-prefixed style property %s. Did you mean %s?', name, name.charAt(0).toUpperCase() + name.slice(1)) : undefined;
	  };
	
	  var warnStyleValueWithSemicolon = function (name, value) {
	    if (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) {
	      return;
	    }
	
	    warnedStyleValues[value] = true;
	    process.env.NODE_ENV !== 'production' ? warning(false, 'Style property values shouldn\'t contain a semicolon. ' + 'Try "%s: %s" instead.', name, value.replace(badStyleValueWithSemicolonPattern, '')) : undefined;
	  };
	
	  /**
	   * @param {string} name
	   * @param {*} value
	   */
	  var warnValidStyle = function (name, value) {
	    if (name.indexOf('-') > -1) {
	      warnHyphenatedStyleName(name);
	    } else if (badVendoredStyleNamePattern.test(name)) {
	      warnBadVendoredStyleName(name);
	    } else if (badStyleValueWithSemicolonPattern.test(value)) {
	      warnStyleValueWithSemicolon(name, value);
	    }
	  };
	}
	
	/**
	 * Operations for dealing with CSS properties.
	 */
	var CSSPropertyOperations = {
	
	  /**
	   * Serializes a mapping of style properties for use as inline styles:
	   *
	   *   > createMarkupForStyles({width: '200px', height: 0})
	   *   "width:200px;height:0;"
	   *
	   * Undefined values are ignored so that declarative programming is easier.
	   * The result should be HTML-escaped before insertion into the DOM.
	   *
	   * @param {object} styles
	   * @return {?string}
	   */
	  createMarkupForStyles: function (styles) {
	    var serialized = '';
	    for (var styleName in styles) {
	      if (!styles.hasOwnProperty(styleName)) {
	        continue;
	      }
	      var styleValue = styles[styleName];
	      if (process.env.NODE_ENV !== 'production') {
	        warnValidStyle(styleName, styleValue);
	      }
	      if (styleValue != null) {
	        serialized += processStyleName(styleName) + ':';
	        serialized += dangerousStyleValue(styleName, styleValue) + ';';
	      }
	    }
	    return serialized || null;
	  },
	
	  /**
	   * Sets the value for multiple styles on a node.  If a value is specified as
	   * '' (empty string), the corresponding style property will be unset.
	   *
	   * @param {DOMElement} node
	   * @param {object} styles
	   */
	  setValueForStyles: function (node, styles) {
	    var style = node.style;
	    for (var styleName in styles) {
	      if (!styles.hasOwnProperty(styleName)) {
	        continue;
	      }
	      if (process.env.NODE_ENV !== 'production') {
	        warnValidStyle(styleName, styles[styleName]);
	      }
	      var styleValue = dangerousStyleValue(styleName, styles[styleName]);
	      if (styleName === 'float') {
	        styleName = styleFloatAccessor;
	      }
	      if (styleValue) {
	        style[styleName] = styleValue;
	      } else {
	        var expansion = hasShorthandPropertyBug && CSSProperty.shorthandPropertyExpansions[styleName];
	        if (expansion) {
	          // Shorthand property that IE8 won't like unsetting, so unset each
	          // component to placate it
	          for (var individualStyleName in expansion) {
	            style[individualStyleName] = '';
	          }
	        } else {
	          style[styleName] = '';
	        }
	      }
	    }
	  }
	
	};
	
	ReactPerf.measureMethods(CSSPropertyOperations, 'CSSPropertyOperations', {
	  setValueForStyles: 'setValueForStyles'
	});
	
	module.exports = CSSPropertyOperations;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(6)))

/***/ },
/* 26 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule CSSProperty
	 */
	
	'use strict';
	
	/**
	 * CSS properties which accept numbers but are not in units of "px".
	 */
	var isUnitlessNumber = {
	  animationIterationCount: true,
	  boxFlex: true,
	  boxFlexGroup: true,
	  boxOrdinalGroup: true,
	  columnCount: true,
	  flex: true,
	  flexGrow: true,
	  flexPositive: true,
	  flexShrink: true,
	  flexNegative: true,
	  flexOrder: true,
	  fontWeight: true,
	  lineClamp: true,
	  lineHeight: true,
	  opacity: true,
	  order: true,
	  orphans: true,
	  tabSize: true,
	  widows: true,
	  zIndex: true,
	  zoom: true,
	
	  // SVG-related properties
	  fillOpacity: true,
	  stopOpacity: true,
	  strokeDashoffset: true,
	  strokeOpacity: true,
	  strokeWidth: true
	};
	
	/**
	 * @param {string} prefix vendor-specific prefix, eg: Webkit
	 * @param {string} key style name, eg: transitionDuration
	 * @return {string} style name prefixed with `prefix`, properly camelCased, eg:
	 * WebkitTransitionDuration
	 */
	function prefixKey(prefix, key) {
	  return prefix + key.charAt(0).toUpperCase() + key.substring(1);
	}
	
	/**
	 * Support style names that may come passed in prefixed by adding permutations
	 * of vendor prefixes.
	 */
	var prefixes = ['Webkit', 'ms', 'Moz', 'O'];
	
	// Using Object.keys here, or else the vanilla for-in loop makes IE8 go into an
	// infinite loop, because it iterates over the newly added props too.
	Object.keys(isUnitlessNumber).forEach(function (prop) {
	  prefixes.forEach(function (prefix) {
	    isUnitlessNumber[prefixKey(prefix, prop)] = isUnitlessNumber[prop];
	  });
	});
	
	/**
	 * Most style properties can be unset by doing .style[prop] = '' but IE8
	 * doesn't like doing that with shorthand properties so for the properties that
	 * IE8 breaks on, which are listed here, we instead unset each of the
	 * individual properties. See http://bugs.jquery.com/ticket/12385.
	 * The 4-value 'clock' properties like margin, padding, border-width seem to
	 * behave without any problems. Curiously, list-style works too without any
	 * special prodding.
	 */
	var shorthandPropertyExpansions = {
	  background: {
	    backgroundAttachment: true,
	    backgroundColor: true,
	    backgroundImage: true,
	    backgroundPositionX: true,
	    backgroundPositionY: true,
	    backgroundRepeat: true
	  },
	  backgroundPosition: {
	    backgroundPositionX: true,
	    backgroundPositionY: true
	  },
	  border: {
	    borderWidth: true,
	    borderStyle: true,
	    borderColor: true
	  },
	  borderBottom: {
	    borderBottomWidth: true,
	    borderBottomStyle: true,
	    borderBottomColor: true
	  },
	  borderLeft: {
	    borderLeftWidth: true,
	    borderLeftStyle: true,
	    borderLeftColor: true
	  },
	  borderRight: {
	    borderRightWidth: true,
	    borderRightStyle: true,
	    borderRightColor: true
	  },
	  borderTop: {
	    borderTopWidth: true,
	    borderTopStyle: true,
	    borderTopColor: true
	  },
	  font: {
	    fontStyle: true,
	    fontVariant: true,
	    fontWeight: true,
	    fontSize: true,
	    lineHeight: true,
	    fontFamily: true
	  },
	  outline: {
	    outlineWidth: true,
	    outlineStyle: true,
	    outlineColor: true
	  }
	};
	
	var CSSProperty = {
	  isUnitlessNumber: isUnitlessNumber,
	  shorthandPropertyExpansions: shorthandPropertyExpansions
	};
	
	module.exports = CSSProperty;

/***/ },
/* 27 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ExecutionEnvironment
	 */
	
	'use strict';
	
	var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);
	
	/**
	 * Simple, lightweight module assisting with the detection and context of
	 * Worker. Helps avoid circular dependencies and allows code to reason about
	 * whether or not they are in a Worker, even if they never include the main
	 * `ReactWorker` dependency.
	 */
	var ExecutionEnvironment = {
	
	  canUseDOM: canUseDOM,
	
	  canUseWorkers: typeof Worker !== 'undefined',
	
	  canUseEventListeners: canUseDOM && !!(window.addEventListener || window.attachEvent),
	
	  canUseViewport: canUseDOM && !!window.screen,
	
	  isInWorker: !canUseDOM // For now, this is true - might change in the future.
	
	};
	
	module.exports = ExecutionEnvironment;

/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactPerf
	 * @typechecks static-only
	 */
	
	'use strict';
	
	/**
	 * ReactPerf is a general AOP system designed to measure performance. This
	 * module only has the hooks: see ReactDefaultPerf for the analysis tool.
	 */
	var ReactPerf = {
	  /**
	   * Boolean to enable/disable measurement. Set to false by default to prevent
	   * accidental logging and perf loss.
	   */
	  enableMeasure: false,
	
	  /**
	   * Holds onto the measure function in use. By default, don't measure
	   * anything, but we'll override this if we inject a measure function.
	   */
	  storedMeasure: _noMeasure,
	
	  /**
	   * @param {object} object
	   * @param {string} objectName
	   * @param {object<string>} methodNames
	   */
	  measureMethods: function (object, objectName, methodNames) {
	    if (process.env.NODE_ENV !== 'production') {
	      for (var key in methodNames) {
	        if (!methodNames.hasOwnProperty(key)) {
	          continue;
	        }
	        object[key] = ReactPerf.measure(objectName, methodNames[key], object[key]);
	      }
	    }
	  },
	
	  /**
	   * Use this to wrap methods you want to measure. Zero overhead in production.
	   *
	   * @param {string} objName
	   * @param {string} fnName
	   * @param {function} func
	   * @return {function}
	   */
	  measure: function (objName, fnName, func) {
	    if (process.env.NODE_ENV !== 'production') {
	      var measuredFunc = null;
	      var wrapper = function () {
	        if (ReactPerf.enableMeasure) {
	          if (!measuredFunc) {
	            measuredFunc = ReactPerf.storedMeasure(objName, fnName, func);
	          }
	          return measuredFunc.apply(this, arguments);
	        }
	        return func.apply(this, arguments);
	      };
	      wrapper.displayName = objName + '_' + fnName;
	      return wrapper;
	    }
	    return func;
	  },
	
	  injection: {
	    /**
	     * @param {function} measure
	     */
	    injectMeasure: function (measure) {
	      ReactPerf.storedMeasure = measure;
	    }
	  }
	};
	
	/**
	 * Simply passes through the measured function, without measuring it.
	 *
	 * @param {string} objName
	 * @param {string} fnName
	 * @param {function} func
	 * @return {function}
	 */
	function _noMeasure(objName, fnName, func) {
	  return func;
	}
	
	module.exports = ReactPerf;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(6)))

/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule camelizeStyleName
	 * @typechecks
	 */
	
	'use strict';
	
	var camelize = __webpack_require__(30);
	
	var msPattern = /^-ms-/;
	
	/**
	 * Camelcases a hyphenated CSS property name, for example:
	 *
	 *   > camelizeStyleName('background-color')
	 *   < "backgroundColor"
	 *   > camelizeStyleName('-moz-transition')
	 *   < "MozTransition"
	 *   > camelizeStyleName('-ms-transition')
	 *   < "msTransition"
	 *
	 * As Andi Smith suggests
	 * (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
	 * is converted to lowercase `ms`.
	 *
	 * @param {string} string
	 * @return {string}
	 */
	function camelizeStyleName(string) {
	  return camelize(string.replace(msPattern, 'ms-'));
	}
	
	module.exports = camelizeStyleName;

/***/ },
/* 30 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule camelize
	 * @typechecks
	 */
	
	"use strict";
	
	var _hyphenPattern = /-(.)/g;
	
	/**
	 * Camelcases a hyphenated string, for example:
	 *
	 *   > camelize('background-color')
	 *   < "backgroundColor"
	 *
	 * @param {string} string
	 * @return {string}
	 */
	function camelize(string) {
	  return string.replace(_hyphenPattern, function (_, character) {
	    return character.toUpperCase();
	  });
	}
	
	module.exports = camelize;

/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule dangerousStyleValue
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var CSSProperty = __webpack_require__(26);
	
	var isUnitlessNumber = CSSProperty.isUnitlessNumber;
	
	/**
	 * Convert a value into the proper css writable value. The style name `name`
	 * should be logical (no hyphens), as specified
	 * in `CSSProperty.isUnitlessNumber`.
	 *
	 * @param {string} name CSS property name such as `topMargin`.
	 * @param {*} value CSS property value such as `10px`.
	 * @return {string} Normalized style value with dimensions applied.
	 */
	function dangerousStyleValue(name, value) {
	  // Note that we've removed escapeTextForBrowser() calls here since the
	  // whole string will be escaped when the attribute is injected into
	  // the markup. If you provide unsafe user data here they can inject
	  // arbitrary CSS which may be problematic (I couldn't repro this):
	  // https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet
	  // http://www.thespanner.co.uk/2007/11/26/ultimate-xss-css-injection/
	  // This is not an XSS hole but instead a potential CSS injection issue
	  // which has lead to a greater discussion about how we're going to
	  // trust URLs moving forward. See #2115901
	
	  var isEmpty = value == null || typeof value === 'boolean' || value === '';
	  if (isEmpty) {
	    return '';
	  }
	
	  var isNonNumeric = isNaN(value);
	  if (isNonNumeric || value === 0 || isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name]) {
	    return '' + value; // cast to string
	  }
	
	  if (typeof value === 'string') {
	    value = value.trim();
	  }
	  return value + 'px';
	}
	
	module.exports = dangerousStyleValue;

/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule hyphenateStyleName
	 * @typechecks
	 */
	
	'use strict';
	
	var hyphenate = __webpack_require__(33);
	
	var msPattern = /^ms-/;
	
	/**
	 * Hyphenates a camelcased CSS property name, for example:
	 *
	 *   > hyphenateStyleName('backgroundColor')
	 *   < "background-color"
	 *   > hyphenateStyleName('MozTransition')
	 *   < "-moz-transition"
	 *   > hyphenateStyleName('msTransition')
	 *   < "-ms-transition"
	 *
	 * As Modernizr suggests (http://modernizr.com/docs/#prefixed), an `ms` prefix
	 * is converted to `-ms-`.
	 *
	 * @param {string} string
	 * @return {string}
	 */
	function hyphenateStyleName(string) {
	  return hyphenate(string).replace(msPattern, '-ms-');
	}
	
	module.exports = hyphenateStyleName;

/***/ },
/* 33 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule hyphenate
	 * @typechecks
	 */
	
	'use strict';
	
	var _uppercasePattern = /([A-Z])/g;
	
	/**
	 * Hyphenates a camelcased string, for example:
	 *
	 *   > hyphenate('backgroundColor')
	 *   < "background-color"
	 *
	 * For CSS style names, use `hyphenateStyleName` instead which works properly
	 * with all vendor prefixes, including `ms`.
	 *
	 * @param {string} string
	 * @return {string}
	 */
	function hyphenate(string) {
	  return string.replace(_uppercasePattern, '-$1').toLowerCase();
	}
	
	module.exports = hyphenate;

/***/ },
/* 34 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule memoizeStringOnly
	 * @typechecks static-only
	 */
	
	'use strict';
	
	/**
	 * Memoizes the return value of a function that accepts one string argument.
	 *
	 * @param {function} callback
	 * @return {function}
	 */
	function memoizeStringOnly(callback) {
	  var cache = {};
	  return function (string) {
	    if (!cache.hasOwnProperty(string)) {
	      cache[string] = callback.call(this, string);
	    }
	    return cache[string];
	  };
	}
	
	module.exports = memoizeStringOnly;

/***/ },
/* 35 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process, console) {/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule warning
	 */
	
	'use strict';
	
	var emptyFunction = __webpack_require__(37);
	
	/**
	 * Similar to invariant but only logs a warning if the condition is not met.
	 * This can be used to log issues in development environments in critical
	 * paths. Removing the logging code for production environments will keep the
	 * same logic and follow the same code paths.
	 */
	
	var warning = emptyFunction;
	
	if (process.env.NODE_ENV !== 'production') {
	  warning = function (condition, format) {
	    for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
	      args[_key - 2] = arguments[_key];
	    }
	
	    if (format === undefined) {
	      throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
	    }
	
	    if (format.indexOf('Failed Composite propType: ') === 0) {
	      return; // Ignore CompositeComponent proptype check.
	    }
	
	    if (!condition) {
	      var argIndex = 0;
	      var message = 'Warning: ' + format.replace(/%s/g, function () {
	        return args[argIndex++];
	      });
	      if (typeof console !== 'undefined') {
	        console.error(message);
	      }
	      try {
	        // --- Welcome to debugging React ---
	        // This error was thrown as a convenience so that you can use this stack
	        // to find the callsite that caused this warning to fire.
	        throw new Error(message);
	      } catch (x) {}
	    }
	  };
	}
	
	module.exports = warning;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(6), __webpack_require__(36)))

/***/ },
/* 36 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {var console;
	if (typeof global !== "undefined" && global.console) {
	    console = global.console
	} else if (typeof window !== "undefined" && window.console) {
	    console = window.console
	} else {
	    console = window.console = {}
	}
	module.exports = console;
	for(var name in {log:1, info:1, error:1, warn:1, dir:1, trace:1, assert:1, time:1, timeEnd: 1})
		if(!console[name])
			console[name] = function() {};
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 37 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule emptyFunction
	 */
	
	"use strict";
	
	function makeEmptyFunction(arg) {
	  return function () {
	    return arg;
	  };
	}
	
	/**
	 * This function accepts and discards inputs; it has no side effects. This is
	 * primarily useful idiomatically for overridable function endpoints which
	 * always need to be callable, since JS lacks a null-call idiom ala Cocoa.
	 */
	function emptyFunction() {}
	
	emptyFunction.thatReturns = makeEmptyFunction;
	emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
	emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
	emptyFunction.thatReturnsNull = makeEmptyFunction(null);
	emptyFunction.thatReturnsThis = function () {
	  return this;
	};
	emptyFunction.thatReturnsArgument = function (arg) {
	  return arg;
	};
	
	module.exports = emptyFunction;

/***/ },
/* 38 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(console) {/**
	 * @copyright 2015 Prometheus Research, LLC
	 */
	
	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _classnames = __webpack_require__(39);
	
	var _classnames2 = _interopRequireDefault(_classnames);
	
	var _getComponentDisplayName = __webpack_require__(7);
	
	var _getComponentDisplayName2 = _interopRequireDefault(_getComponentDisplayName);
	
	var _DOMStylesheet = __webpack_require__(22);
	
	var DOMStylesheet = _interopRequireWildcard(_DOMStylesheet);
	
	var StyleableDOMComponent = (function (_React$Component) {
	  _inherits(StyleableDOMComponent, _React$Component);
	
	  _createClass(StyleableDOMComponent, null, [{
	    key: 'style',
	    value: function style(spec) {
	      var _this = this;
	
	      return (function (_StyleableDOMComponent) {
	        _inherits(_class, _StyleableDOMComponent);
	
	        function _class() {
	          _classCallCheck(this, _class);
	
	          _get(Object.getPrototypeOf(_class.prototype), 'constructor', this).apply(this, arguments);
	        }
	
	        _createClass(_class, null, [{
	          key: 'displayName',
	          value: (0, _getComponentDisplayName2['default'])(_this),
	          enumerable: true
	        }, {
	          key: 'Component',
	          value: _this.Component,
	          enumerable: true
	        }, {
	          key: 'stylesheet',
	          value: DOMStylesheet.overrideStylesheet(_this.stylesheet, spec),
	          enumerable: true
	        }]);
	
	        return _class;
	      })(StyleableDOMComponent);
	    }
	  }, {
	    key: 'Component',
	    value: null,
	    enumerable: true
	  }, {
	    key: 'stylesheet',
	    value: null,
	    enumerable: true
	  }, {
	    key: 'propTypes',
	    value: {
	      variant: _react.PropTypes.object,
	      state: _react.PropTypes.object,
	      Component: _react.PropTypes.oneOfType([_react.PropTypes.string, _react.PropTypes.func]),
	      className: _react.PropTypes.string
	    },
	    enumerable: true
	  }]);
	
	  function StyleableDOMComponent(props) {
	    _classCallCheck(this, StyleableDOMComponent);
	
	    _get(Object.getPrototypeOf(StyleableDOMComponent.prototype), 'constructor', this).call(this, props);
	    this._stateDeprecationWarned = false;
	  }
	
	  _createClass(StyleableDOMComponent, [{
	    key: 'render',
	    value: function render() {
	      var _props = this.props;
	      var variant = _props.variant;
	      var state = _props.state;
	      var _props$Component = _props.Component;
	      var Component = _props$Component === undefined ? this.constructor.Component : _props$Component;
	      var extraClassName = _props.className;
	
	      var props = _objectWithoutProperties(_props, ['variant', 'state', 'Component', 'className']);
	
	      if (state && !this._stateDeprecationWarned) {
	        this._stateDeprecationWarned = true;
	        console.error( // eslint-disable-line
	        'Warning: React Stylesheet: state is deprecated, use variant instead');
	      }
	      variant = variant || state;
	      var stylesheet = this.constructor.stylesheet;
	
	      var className = stylesheet.asClassName(variant);
	      return _react2['default'].createElement(Component, _extends({}, props, {
	        className: (0, _classnames2['default'])(className, extraClassName)
	      }));
	    }
	  }, {
	    key: 'componentDidMount',
	    value: function componentDidMount() {
	      this.constructor.stylesheet.use();
	    }
	  }, {
	    key: 'componentWillUnmount',
	    value: function componentWillUnmount() {
	      this.constructor.stylesheet.dispose();
	    }
	  }]);
	
	  return StyleableDOMComponent;
	})(_react2['default'].Component);
	
	exports['default'] = StyleableDOMComponent;
	module.exports = exports['default'];
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(36)))

/***/ },
/* 39 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	  Copyright (c) 2015 Jed Watson.
	  Licensed under the MIT License (MIT), see
	  http://jedwatson.github.io/classnames
	*/
	/* global define */
	
	(function () {
		'use strict';
	
		var hasOwn = {}.hasOwnProperty;
	
		function classNames () {
			var classes = '';
	
			for (var i = 0; i < arguments.length; i++) {
				var arg = arguments[i];
				if (!arg) continue;
	
				var argType = typeof arg;
	
				if (argType === 'string' || argType === 'number') {
					classes += ' ' + arg;
				} else if (Array.isArray(arg)) {
					classes += ' ' + classNames.apply(null, arg);
				} else if (argType === 'object') {
					for (var key in arg) {
						if (hasOwn.call(arg, key) && arg[key]) {
							classes += ' ' + key;
						}
					}
				}
			}
	
			return classes.substr(1);
		}
	
		if (typeof module !== 'undefined' && module.exports) {
			module.exports = classNames;
		} else if (true) {
			// register as 'classnames', consistent with npm package name
			!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
				return classNames;
			}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		} else {
			window.classNames = classNames;
		}
	}());


/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @copyright 2015 Prometheus Research, LLC
	 */
	
	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };
	
	exports['default'] = styleable;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var _react = __webpack_require__(2);
	
	var _Stylesheet = __webpack_require__(20);
	
	var _getComponentDisplayName = __webpack_require__(7);
	
	var _getComponentDisplayName2 = _interopRequireDefault(_getComponentDisplayName);
	
	function styleable(Component) {
	  var displayName = (0, _getComponentDisplayName2['default'])(Component);
	  return (function (_Component) {
	    _inherits(_class, _Component);
	
	    function _class() {
	      _classCallCheck(this, _class);
	
	      _get(Object.getPrototypeOf(_class.prototype), 'constructor', this).apply(this, arguments);
	    }
	
	    _createClass(_class, [{
	      key: 'stylesheet',
	      get: function get() {
	        return this.props.stylesheet || this.constructor.stylesheet;
	      }
	    }], [{
	      key: 'style',
	      value: function style(spec) {
	        var _this = this;
	
	        return (function (_ref) {
	          _inherits(_class2, _ref);
	
	          function _class2() {
	            _classCallCheck(this, _class2);
	
	            _get(Object.getPrototypeOf(_class2.prototype), 'constructor', this).apply(this, arguments);
	          }
	
	          _createClass(_class2, null, [{
	            key: 'stylesheet',
	            value: (0, _Stylesheet.overrideStylesheet)(_this.stylesheet, spec),
	            enumerable: true
	          }]);
	
	          return _class2;
	        })(this);
	      }
	    }, {
	      key: 'propTypes',
	      value: _extends({}, Component.propTypes, {
	        stylesheet: _react.PropTypes.object
	      }),
	      enumerable: true
	    }, {
	      key: 'displayName',
	      value: displayName,
	      enumerable: true
	    }]);
	
	    return _class;
	  })(Component);
	}
	
	module.exports = exports['default'];


/***/ },
/* 41 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @copyright 2015, Prometheus Research, LLC
	 */
	
	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _invariant = __webpack_require__(5);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _keyPath = __webpack_require__(42);
	
	var _keyPath2 = _interopRequireDefault(_keyPath);
	
	var ContextTypes = {
	  formValue: _react.PropTypes.object
	};
	
	exports.ContextTypes = ContextTypes;
	var selectPropType = _react.PropTypes.oneOfType([_react.PropTypes.array, _react.PropTypes.string, _react.PropTypes.number, _react.PropTypes.bool]);
	
	/**
	 * Base class for form components.
	 *
	 * It exposes form value via `this.formValue` which is provided either via
	 * `this.props.formValue` or via context.
	 */
	
	var Component = (function (_React$Component) {
	  _inherits(Component, _React$Component);
	
	  function Component() {
	    _classCallCheck(this, Component);
	
	    _get(Object.getPrototypeOf(Component.prototype), 'constructor', this).apply(this, arguments);
	  }
	
	  _createClass(Component, [{
	    key: 'getChildContext',
	    value: function getChildContext() {
	      return { formValue: this.formValue };
	    }
	  }, {
	    key: 'formValue',
	    get: function get() {
	      var formValue = this.props.formValue || this.context.formValue;
	
	      (0, _invariant2['default'])(formValue, 'A form component <%s /> should receive form value via props ' + 'or be used as a part of element hierarchy which ' + 'includes <Form /> component in its ancestors', this.constructor.displayName || this.constructor.name);
	
	      var select = this.props.select || this.props.selectFormValue;
	      // We check for select !== true to keep compatability we eariler
	      // versions of React Forms where we needed to rebuild element tree to
	      // propagate values to form.
	      if (select && select !== true) {
	        select = (0, _keyPath2['default'])(select);
	        formValue = formValue.select(select);
	      }
	
	      return formValue;
	    }
	  }], [{
	    key: 'propTypes',
	    value: {
	      /**
	       * Form value passed as a prop.
	       */
	      formValue: _react.PropTypes.object,
	
	      /**
	       * Selector for form value.
	       *
	       * Used to select a part from a form value passed via context.
	       */
	      select: selectPropType,
	
	      /**
	       * Same as `select`.
	       *
	       * Deprecated.
	       */
	      selectFormValue: selectPropType
	    },
	    enumerable: true
	  }, {
	    key: 'contextTypes',
	    value: ContextTypes,
	    enumerable: true
	  }, {
	    key: 'childContextTypes',
	    value: ContextTypes,
	    enumerable: true
	  }]);
	
	  return Component;
	})(_react2['default'].Component);
	
	exports['default'] = Component;

/***/ },
/* 42 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @copyright 2015, Prometheus Research, LLC
	 */
	
	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = keyPath;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _lodashLangIsString = __webpack_require__(43);
	
	var _lodashLangIsString2 = _interopRequireDefault(_lodashLangIsString);
	
	var _lodashLangIsArray = __webpack_require__(45);
	
	var _lodashLangIsArray2 = _interopRequireDefault(_lodashLangIsArray);
	
	var _invariant = __webpack_require__(5);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var IS_NUMBER = /[0-9]+/;
	
	function tryParseInt(v) {
	  if (typeof v === 'string' && IS_NUMBER.exec(v)) {
	    v = parseInt(v, 10);
	  }
	  return v;
	}
	
	function keyPath(value) {
	  if ((0, _lodashLangIsArray2['default'])(value)) {
	    return value;
	  } else if ((0, _lodashLangIsString2['default'])(value)) {
	    if (value.indexOf('.') !== -1) {
	      value = value.split('.').filter(Boolean).map(tryParseInt);
	    } else {
	      value = [tryParseInt(value)];
	    }
	    return value;
	  } else if (typeof value === 'number') {
	    return [value];
	  } else {
	    (0, _invariant2['default'])(false, 'keyPath can be either an array, a string or a number, got: %s', value);
	  }
	}
	
	module.exports = exports['default'];

/***/ },
/* 43 */
/***/ function(module, exports, __webpack_require__) {

	var isObjectLike = __webpack_require__(44);
	
	/** `Object#toString` result references. */
	var stringTag = '[object String]';
	
	/** Used for native method references. */
	var objectProto = Object.prototype;
	
	/**
	 * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var objToString = objectProto.toString;
	
	/**
	 * Checks if `value` is classified as a `String` primitive or object.
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	 * @example
	 *
	 * _.isString('abc');
	 * // => true
	 *
	 * _.isString(1);
	 * // => false
	 */
	function isString(value) {
	  return typeof value == 'string' || (isObjectLike(value) && objToString.call(value) == stringTag);
	}
	
	module.exports = isString;


/***/ },
/* 44 */
/***/ function(module, exports) {

	/**
	 * Checks if `value` is object-like.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 */
	function isObjectLike(value) {
	  return !!value && typeof value == 'object';
	}
	
	module.exports = isObjectLike;


/***/ },
/* 45 */
/***/ function(module, exports, __webpack_require__) {

	var getNative = __webpack_require__(46),
	    isLength = __webpack_require__(50),
	    isObjectLike = __webpack_require__(44);
	
	/** `Object#toString` result references. */
	var arrayTag = '[object Array]';
	
	/** Used for native method references. */
	var objectProto = Object.prototype;
	
	/**
	 * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var objToString = objectProto.toString;
	
	/* Native method references for those with the same name as other `lodash` methods. */
	var nativeIsArray = getNative(Array, 'isArray');
	
	/**
	 * Checks if `value` is classified as an `Array` object.
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	 * @example
	 *
	 * _.isArray([1, 2, 3]);
	 * // => true
	 *
	 * _.isArray(function() { return arguments; }());
	 * // => false
	 */
	var isArray = nativeIsArray || function(value) {
	  return isObjectLike(value) && isLength(value.length) && objToString.call(value) == arrayTag;
	};
	
	module.exports = isArray;


/***/ },
/* 46 */
/***/ function(module, exports, __webpack_require__) {

	var isNative = __webpack_require__(47);
	
	/**
	 * Gets the native function at `key` of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {string} key The key of the method to get.
	 * @returns {*} Returns the function if it's native, else `undefined`.
	 */
	function getNative(object, key) {
	  var value = object == null ? undefined : object[key];
	  return isNative(value) ? value : undefined;
	}
	
	module.exports = getNative;


/***/ },
/* 47 */
/***/ function(module, exports, __webpack_require__) {

	var isFunction = __webpack_require__(48),
	    isObjectLike = __webpack_require__(44);
	
	/** Used to detect host constructors (Safari > 5). */
	var reIsHostCtor = /^\[object .+?Constructor\]$/;
	
	/** Used for native method references. */
	var objectProto = Object.prototype;
	
	/** Used to resolve the decompiled source of functions. */
	var fnToString = Function.prototype.toString;
	
	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;
	
	/** Used to detect if a method is native. */
	var reIsNative = RegExp('^' +
	  fnToString.call(hasOwnProperty).replace(/[\\^$.*+?()[\]{}|]/g, '\\$&')
	  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
	);
	
	/**
	 * Checks if `value` is a native function.
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a native function, else `false`.
	 * @example
	 *
	 * _.isNative(Array.prototype.push);
	 * // => true
	 *
	 * _.isNative(_);
	 * // => false
	 */
	function isNative(value) {
	  if (value == null) {
	    return false;
	  }
	  if (isFunction(value)) {
	    return reIsNative.test(fnToString.call(value));
	  }
	  return isObjectLike(value) && reIsHostCtor.test(value);
	}
	
	module.exports = isNative;


/***/ },
/* 48 */
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(49);
	
	/** `Object#toString` result references. */
	var funcTag = '[object Function]';
	
	/** Used for native method references. */
	var objectProto = Object.prototype;
	
	/**
	 * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var objToString = objectProto.toString;
	
	/**
	 * Checks if `value` is classified as a `Function` object.
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	 * @example
	 *
	 * _.isFunction(_);
	 * // => true
	 *
	 * _.isFunction(/abc/);
	 * // => false
	 */
	function isFunction(value) {
	  // The use of `Object#toString` avoids issues with the `typeof` operator
	  // in older versions of Chrome and Safari which return 'function' for regexes
	  // and Safari 8 which returns 'object' for typed array constructors.
	  return isObject(value) && objToString.call(value) == funcTag;
	}
	
	module.exports = isFunction;


/***/ },
/* 49 */
/***/ function(module, exports) {

	/**
	 * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
	 * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	 * @example
	 *
	 * _.isObject({});
	 * // => true
	 *
	 * _.isObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isObject(1);
	 * // => false
	 */
	function isObject(value) {
	  // Avoid a V8 JIT bug in Chrome 19-20.
	  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
	  var type = typeof value;
	  return !!value && (type == 'object' || type == 'function');
	}
	
	module.exports = isObject;


/***/ },
/* 50 */
/***/ function(module, exports) {

	/**
	 * Used as the [maximum length](http://ecma-international.org/ecma-262/6.0/#sec-number.max_safe_integer)
	 * of an array-like value.
	 */
	var MAX_SAFE_INTEGER = 9007199254740991;
	
	/**
	 * Checks if `value` is a valid array-like length.
	 *
	 * **Note:** This function is based on [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
	 */
	function isLength(value) {
	  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
	}
	
	module.exports = isLength;


/***/ },
/* 51 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @copyright 2015, Prometheus Research, LLC
	 */
	
	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _createDecoratedClass = (function () { function defineProperties(target, descriptors, initializers) { for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === 'function') { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator); } } if (descriptor.initializer !== undefined) { initializers[key] = descriptor; continue; } } Object.defineProperty(target, key, descriptor); } } return function (Constructor, protoProps, staticProps, protoInitializers, staticInitializers) { if (protoProps) defineProperties(Constructor.prototype, protoProps, protoInitializers); if (staticProps) defineProperties(Constructor, staticProps, staticInitializers); return Constructor; }; })();
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var _autobindDecorator = __webpack_require__(52);
	
	var _autobindDecorator2 = _interopRequireDefault(_autobindDecorator);
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _reactStylesheet = __webpack_require__(3);
	
	var ReactStylesheet = _interopRequireWildcard(_reactStylesheet);
	
	var _Component2 = __webpack_require__(41);
	
	var _Component3 = _interopRequireDefault(_Component2);
	
	var _Input = __webpack_require__(53);
	
	var _Input2 = _interopRequireDefault(_Input);
	
	var _ErrorList = __webpack_require__(57);
	
	var _ErrorList2 = _interopRequireDefault(_ErrorList);
	
	var _Label = __webpack_require__(59);
	
	var _Label2 = _interopRequireDefault(_Label);
	
	var Field = (function (_Component) {
	  _inherits(Field, _Component);
	
	  _createClass(Field, null, [{
	    key: 'propTypes',
	    value: _extends({}, _Component3['default'].propTypes, {
	      label: _react.PropTypes.string,
	      children: _react.PropTypes.element,
	      Input: _react.PropTypes.oneOfType([_react.PropTypes.string, _react.PropTypes.func])
	    }),
	    enumerable: true
	  }, {
	    key: 'defaultProps',
	    value: {
	      Input: _Input2['default']
	    },
	    enumerable: true
	  }, {
	    key: 'stylesheet',
	    value: ReactStylesheet.createStylesheet({
	      Root: 'div',
	      ErrorList: _ErrorList2['default'],
	      Label: _Label2['default'],
	      InputWrapper: 'div'
	    }),
	    enumerable: true
	  }]);
	
	  function Field(props) {
	    _classCallCheck(this, _Field);
	
	    _get(Object.getPrototypeOf(_Field.prototype), 'constructor', this).call(this, props);
	    this.state = { dirty: false };
	  }
	
	  _createDecoratedClass(Field, [{
	    key: 'render',
	    value: function render() {
	      var _props = this.props;
	      var Input = _props.Input;
	      var label = _props.label;
	      var children = _props.children;
	      var _stylesheet = this.stylesheet;
	      var Root = _stylesheet.Root;
	      var ErrorList = _stylesheet.ErrorList;
	      var Label = _stylesheet.Label;
	      var InputWrapper = _stylesheet.InputWrapper;
	      var dirty = this.state.dirty;
	      var _formValue = this.formValue;
	      var _formValue$schema = _formValue.schema;
	      var schema = _formValue$schema === undefined ? {} : _formValue$schema;
	      var value = _formValue.value;
	      var _formValue$params = _formValue.params;
	      var params = _formValue$params === undefined ? {} : _formValue$params;
	
	      var showErrors = dirty || params.forceShowErrors;
	      if (!children) {
	        children = _react2['default'].createElement(Input, { value: value, onChange: this.onChange });
	      } else {
	        children = _react2['default'].cloneElement(_react2['default'].Children.only(children), { value: value, onChange: this.onChange });
	      }
	      return _react2['default'].createElement(
	        Root,
	        { onBlur: this.onBlur },
	        _react2['default'].createElement(Label, { label: label, schema: schema }),
	        _react2['default'].createElement(
	          InputWrapper,
	          null,
	          children
	        ),
	        showErrors && _react2['default'].createElement(ErrorList, { formValue: this.formValue })
	      );
	    }
	  }, {
	    key: 'onBlur',
	    decorators: [_autobindDecorator2['default']],
	    value: function onBlur() {
	      this.setState({ dirty: true });
	    }
	  }, {
	    key: 'onChange',
	    decorators: [_autobindDecorator2['default']],
	    value: function onChange(e) {
	      var value = undefined;
	      if (e && e.target && e.target.value !== undefined) {
	        e.stopPropagation();
	        value = e.target.value;
	        if (value === '') {
	          value = undefined;
	        }
	      } else {
	        value = e;
	      }
	      this.setState({ dirty: true });
	      this.formValue.update(value);
	    }
	  }]);
	
	  var _Field = Field;
	  Field = ReactStylesheet.styleable(Field) || Field;
	  return Field;
	})(_Component3['default']);
	
	exports['default'] = Field;
	module.exports = exports['default'];

/***/ },
/* 52 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	/**
	 * @copyright 2015, Andrey Popp <8mayday@gmail.com>
	 *
	 * The decorator may be used on classes or methods
	 * ```
	 * @autobind
	 * class FullBound {}
	 *
	 * class PartBound {
	 *   @autobind
	 *   method () {}
	 * }
	 * ```
	 */
	exports['default'] = autobind;
	
	function autobind() {
	  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	    args[_key] = arguments[_key];
	  }
	
	  if (args.length === 1) {
	    return boundClass.apply(undefined, args);
	  } else {
	    return boundMethod.apply(undefined, args);
	  }
	}
	
	/**
	 * Use boundMethod to bind all methods on the target.prototype
	 */
	function boundClass(target) {
	  // (Using reflect to get all keys including symbols)
	  var keys = undefined;
	  // Use Reflect if exists
	  if (typeof Reflect !== 'undefined') {
	    keys = Reflect.ownKeys(target.prototype);
	  } else {
	    keys = Object.getOwnPropertyNames(target.prototype);
	    // use symbols if support is provided
	    if (typeof Object.getOwnPropertySymbols === 'function') {
	      keys = keys.concat(Object.getOwnPropertySymbols(target.prototype));
	    }
	  }
	
	  keys.forEach(function (key) {
	    // Ignore special case target method
	    if (key === 'constructor') {
	      return;
	    }
	
	    var descriptor = Object.getOwnPropertyDescriptor(target.prototype, key);
	
	    // Only methods need binding
	    if (typeof descriptor.value === 'function') {
	      Object.defineProperty(target.prototype, key, boundMethod(target, key, descriptor));
	    }
	  });
	  return target;
	}
	
	/**
	 * Return a descriptor removing the value and returning a getter
	 * The getter will return a .bind version of the function
	 * and memoize the result against a symbol on the instance
	 */
	function boundMethod(target, key, descriptor) {
	  var fn = descriptor.value;
	
	  if (typeof fn !== 'function') {
	    throw new Error('@autobind decorator can only be applied to methods not: ' + typeof fn);
	  }
	
	  return {
	    configurable: true,
	    get: function get() {
	      if (this === target.prototype) {
	        return fn;
	      }
	
	      var boundFn = fn.bind(this);
	      Object.defineProperty(this, key, {
	        value: boundFn,
	        configurable: true,
	        writable: true
	      });
	      return boundFn;
	    }
	  };
	}
	module.exports = exports['default'];


/***/ },
/* 53 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @copyright 2015, Prometheus Research, LLC
	 */
	
	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _createDecoratedClass = (function () { function defineProperties(target, descriptors, initializers) { for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === 'function') { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator); } } if (descriptor.initializer !== undefined) { initializers[key] = descriptor; continue; } } Object.defineProperty(target, key, descriptor); } } return function (Constructor, protoProps, staticProps, protoInitializers, staticInitializers) { if (protoProps) defineProperties(Constructor.prototype, protoProps, protoInitializers); if (staticProps) defineProperties(Constructor, staticProps, staticInitializers); return Constructor; }; })();
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var _autobindDecorator = __webpack_require__(52);
	
	var _autobindDecorator2 = _interopRequireDefault(_autobindDecorator);
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _lodashFunctionDebounce = __webpack_require__(54);
	
	var _lodashFunctionDebounce2 = _interopRequireDefault(_lodashFunctionDebounce);
	
	var _emptyFunction = __webpack_require__(56);
	
	var _emptyFunction2 = _interopRequireDefault(_emptyFunction);
	
	/**
	 * Input component with debounce.
	 */
	
	var Input = (function (_React$Component) {
	  _inherits(Input, _React$Component);
	
	  _createClass(Input, null, [{
	    key: 'propTypes',
	    value: {
	      Component: _react.PropTypes.oneOfType([_react.PropTypes.string, _react.PropTypes.func]),
	      debounce: _react.PropTypes.number,
	      value: _react.PropTypes.any,
	      onChange: _react.PropTypes.func
	    },
	    enumerable: true
	  }, {
	    key: 'defaultProps',
	    value: {
	      Component: 'input',
	      debounce: 100,
	      onChange: _emptyFunction2['default']
	    },
	    enumerable: true
	  }]);
	
	  function Input(props) {
	    _classCallCheck(this, Input);
	
	    _get(Object.getPrototypeOf(Input.prototype), 'constructor', this).call(this, props);
	    this.state = { value: props.value };
	    this._expectedValue = undefined;
	    this._finalizeOnChangeDebounced = props.debounce ? (0, _lodashFunctionDebounce2['default'])(this._finalizeOnChange.bind(this), props.debounce) : this._finalizeOnChange.bind(this);
	  }
	
	  _createDecoratedClass(Input, [{
	    key: 'render',
	    value: function render() {
	      var _props = this.props;
	      var Component = _props.Component;
	      var debounceEnabled = _props.debounce;
	      var value = _props.value;
	
	      var props = _objectWithoutProperties(_props, ['Component', 'debounce', 'value']);
	
	      if (debounceEnabled) {
	        value = this.state.value;
	      }
	      return _react2['default'].createElement(Component, _extends({}, props, {
	        value: value,
	        onChange: this.onChange,
	        onBlur: this.onBlur }));
	    }
	  }, {
	    key: 'componentWillReceiveProps',
	    value: function componentWillReceiveProps(nextProps) {
	      if (nextProps.value !== this._expectedValue) {
	        this._cancelOnChange();
	        this.setState({ value: nextProps.value });
	      }
	      if (nextProps.debounce !== this.props.debounce) {
	        this._finalizeOnChange();
	        this._cancelOnChange();
	        this._finalizeOnChangeDebounced = nextProps.debounce ? (0, _lodashFunctionDebounce2['default'])(this._finalizeOnChange.bind(this), nextProps.debounce) : this._finalizeOnChange.bind(this);
	      }
	    }
	  }, {
	    key: 'componentWillUnmount',
	    value: function componentWillUnmount() {
	      this._finalizeOnChange();
	      this._cancelOnChange();
	    }
	  }, {
	    key: '_scheduleOnChange',
	    value: function _scheduleOnChange(value) {
	      this.setState({ value: value });
	      this._expectedValue = value;
	      this._finalizeOnChangeDebounced();
	    }
	  }, {
	    key: '_finalizeOnChange',
	    value: function _finalizeOnChange() {
	      if (this._expectedValue !== undefined) {
	        var value = this._expectedValue;
	        this._expectedValue = undefined;
	        this.props.onChange(value);
	      }
	    }
	  }, {
	    key: '_cancelOnChange',
	    value: function _cancelOnChange() {
	      if (this._finalizeOnChangeDebounced.cancel) {
	        this._expectedValue = undefined;
	        this._finalizeOnChangeDebounced.cancel();
	      }
	    }
	  }, {
	    key: 'onChange',
	    decorators: [_autobindDecorator2['default']],
	    value: function onChange(e) {
	      var value = e && e.target && 'value' in e.target ? e.target.value : e;
	      this._scheduleOnChange(value);
	    }
	  }, {
	    key: 'onBlur',
	    decorators: [_autobindDecorator2['default']],
	    value: function onBlur() {
	      if (this._expectedValue !== undefined) {
	        this._finalizeOnChange();
	        this._cancelOnChange();
	      }
	    }
	  }]);
	
	  return Input;
	})(_react2['default'].Component);
	
	exports['default'] = Input;
	module.exports = exports['default'];

/***/ },
/* 54 */
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(49),
	    now = __webpack_require__(55);
	
	/** Used as the `TypeError` message for "Functions" methods. */
	var FUNC_ERROR_TEXT = 'Expected a function';
	
	/* Native method references for those with the same name as other `lodash` methods. */
	var nativeMax = Math.max;
	
	/**
	 * Creates a debounced function that delays invoking `func` until after `wait`
	 * milliseconds have elapsed since the last time the debounced function was
	 * invoked. The debounced function comes with a `cancel` method to cancel
	 * delayed invocations. Provide an options object to indicate that `func`
	 * should be invoked on the leading and/or trailing edge of the `wait` timeout.
	 * Subsequent calls to the debounced function return the result of the last
	 * `func` invocation.
	 *
	 * **Note:** If `leading` and `trailing` options are `true`, `func` is invoked
	 * on the trailing edge of the timeout only if the the debounced function is
	 * invoked more than once during the `wait` timeout.
	 *
	 * See [David Corbacho's article](http://drupalmotion.com/article/debounce-and-throttle-visual-explanation)
	 * for details over the differences between `_.debounce` and `_.throttle`.
	 *
	 * @static
	 * @memberOf _
	 * @category Function
	 * @param {Function} func The function to debounce.
	 * @param {number} [wait=0] The number of milliseconds to delay.
	 * @param {Object} [options] The options object.
	 * @param {boolean} [options.leading=false] Specify invoking on the leading
	 *  edge of the timeout.
	 * @param {number} [options.maxWait] The maximum time `func` is allowed to be
	 *  delayed before it's invoked.
	 * @param {boolean} [options.trailing=true] Specify invoking on the trailing
	 *  edge of the timeout.
	 * @returns {Function} Returns the new debounced function.
	 * @example
	 *
	 * // avoid costly calculations while the window size is in flux
	 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
	 *
	 * // invoke `sendMail` when the click event is fired, debouncing subsequent calls
	 * jQuery('#postbox').on('click', _.debounce(sendMail, 300, {
	 *   'leading': true,
	 *   'trailing': false
	 * }));
	 *
	 * // ensure `batchLog` is invoked once after 1 second of debounced calls
	 * var source = new EventSource('/stream');
	 * jQuery(source).on('message', _.debounce(batchLog, 250, {
	 *   'maxWait': 1000
	 * }));
	 *
	 * // cancel a debounced call
	 * var todoChanges = _.debounce(batchLog, 1000);
	 * Object.observe(models.todo, todoChanges);
	 *
	 * Object.observe(models, function(changes) {
	 *   if (_.find(changes, { 'user': 'todo', 'type': 'delete'})) {
	 *     todoChanges.cancel();
	 *   }
	 * }, ['delete']);
	 *
	 * // ...at some point `models.todo` is changed
	 * models.todo.completed = true;
	 *
	 * // ...before 1 second has passed `models.todo` is deleted
	 * // which cancels the debounced `todoChanges` call
	 * delete models.todo;
	 */
	function debounce(func, wait, options) {
	  var args,
	      maxTimeoutId,
	      result,
	      stamp,
	      thisArg,
	      timeoutId,
	      trailingCall,
	      lastCalled = 0,
	      maxWait = false,
	      trailing = true;
	
	  if (typeof func != 'function') {
	    throw new TypeError(FUNC_ERROR_TEXT);
	  }
	  wait = wait < 0 ? 0 : (+wait || 0);
	  if (options === true) {
	    var leading = true;
	    trailing = false;
	  } else if (isObject(options)) {
	    leading = !!options.leading;
	    maxWait = 'maxWait' in options && nativeMax(+options.maxWait || 0, wait);
	    trailing = 'trailing' in options ? !!options.trailing : trailing;
	  }
	
	  function cancel() {
	    if (timeoutId) {
	      clearTimeout(timeoutId);
	    }
	    if (maxTimeoutId) {
	      clearTimeout(maxTimeoutId);
	    }
	    lastCalled = 0;
	    maxTimeoutId = timeoutId = trailingCall = undefined;
	  }
	
	  function complete(isCalled, id) {
	    if (id) {
	      clearTimeout(id);
	    }
	    maxTimeoutId = timeoutId = trailingCall = undefined;
	    if (isCalled) {
	      lastCalled = now();
	      result = func.apply(thisArg, args);
	      if (!timeoutId && !maxTimeoutId) {
	        args = thisArg = undefined;
	      }
	    }
	  }
	
	  function delayed() {
	    var remaining = wait - (now() - stamp);
	    if (remaining <= 0 || remaining > wait) {
	      complete(trailingCall, maxTimeoutId);
	    } else {
	      timeoutId = setTimeout(delayed, remaining);
	    }
	  }
	
	  function maxDelayed() {
	    complete(trailing, timeoutId);
	  }
	
	  function debounced() {
	    args = arguments;
	    stamp = now();
	    thisArg = this;
	    trailingCall = trailing && (timeoutId || !leading);
	
	    if (maxWait === false) {
	      var leadingCall = leading && !timeoutId;
	    } else {
	      if (!maxTimeoutId && !leading) {
	        lastCalled = stamp;
	      }
	      var remaining = maxWait - (stamp - lastCalled),
	          isCalled = remaining <= 0 || remaining > maxWait;
	
	      if (isCalled) {
	        if (maxTimeoutId) {
	          maxTimeoutId = clearTimeout(maxTimeoutId);
	        }
	        lastCalled = stamp;
	        result = func.apply(thisArg, args);
	      }
	      else if (!maxTimeoutId) {
	        maxTimeoutId = setTimeout(maxDelayed, remaining);
	      }
	    }
	    if (isCalled && timeoutId) {
	      timeoutId = clearTimeout(timeoutId);
	    }
	    else if (!timeoutId && wait !== maxWait) {
	      timeoutId = setTimeout(delayed, wait);
	    }
	    if (leadingCall) {
	      isCalled = true;
	      result = func.apply(thisArg, args);
	    }
	    if (isCalled && !timeoutId && !maxTimeoutId) {
	      args = thisArg = undefined;
	    }
	    return result;
	  }
	  debounced.cancel = cancel;
	  return debounced;
	}
	
	module.exports = debounce;


/***/ },
/* 55 */
/***/ function(module, exports, __webpack_require__) {

	var getNative = __webpack_require__(46);
	
	/* Native method references for those with the same name as other `lodash` methods. */
	var nativeNow = getNative(Date, 'now');
	
	/**
	 * Gets the number of milliseconds that have elapsed since the Unix epoch
	 * (1 January 1970 00:00:00 UTC).
	 *
	 * @static
	 * @memberOf _
	 * @category Date
	 * @example
	 *
	 * _.defer(function(stamp) {
	 *   console.log(_.now() - stamp);
	 * }, _.now());
	 * // => logs the number of milliseconds it took for the deferred function to be invoked
	 */
	var now = nativeNow || function() {
	  return new Date().getTime();
	};
	
	module.exports = now;


/***/ },
/* 56 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	module.exports = function () {};
	
	if ('production' != process.env.NODE_ENV) {
	  Object.freeze(module.exports);
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(6)))

/***/ },
/* 57 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @copyright 2015, Prometheus Research, LLC
	 */
	
	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _reactStylesheet = __webpack_require__(3);
	
	var ReactStylesheet = _interopRequireWildcard(_reactStylesheet);
	
	var _Component2 = __webpack_require__(41);
	
	var _Component3 = _interopRequireDefault(_Component2);
	
	var _Error = __webpack_require__(58);
	
	var _Error2 = _interopRequireDefault(_Error);
	
	var ErrorList = (function (_Component) {
	  _inherits(ErrorList, _Component);
	
	  function ErrorList() {
	    _classCallCheck(this, _ErrorList);
	
	    _get(Object.getPrototypeOf(_ErrorList.prototype), 'constructor', this).apply(this, arguments);
	  }
	
	  _createClass(ErrorList, [{
	    key: 'render',
	    value: function render() {
	      var _props = this.props;
	      var noLabel = _props.noLabel;
	      var complete = _props.complete;
	      var schemaType = _props.schemaType;
	
	      var props = _objectWithoutProperties(_props, ['noLabel', 'complete', 'schemaType']);
	
	      var _stylesheet = this.stylesheet;
	      var Root = _stylesheet.Root;
	      var Error = _stylesheet.Error;
	
	      var errorList = complete ? this.formValue.completeErrorList : this.formValue.errorList;
	      if (schemaType !== undefined) {
	        errorList = errorList.filter(function (error) {
	          return error.schema ? schemaType[error.schema.type] : schemaType.none;
	        });
	      }
	      if (errorList.length === 0) {
	        return null;
	      }
	      var items = errorList.map(function (error, index) {
	        return _react2['default'].createElement(Error, {
	          key: error.field + '__' + index,
	          error: error,
	          noLabel: noLabel,
	          complete: complete
	        });
	      });
	      return _react2['default'].createElement(
	        Root,
	        props,
	        items
	      );
	    }
	  }], [{
	    key: 'propTypes',
	    value: _extends({}, _Component3['default'].propTypes, {
	
	      /**
	       * If component should render errors from all the subvalues.
	       */
	      complete: _react.PropTypes.bool,
	
	      /**
	       * Restrict schema types
	       */
	      schemaType: _react.PropTypes.object,
	
	      noLabel: _react.PropTypes.bool,
	
	      label: _react.PropTypes.string
	    }),
	    enumerable: true
	  }, {
	    key: 'stylesheet',
	    value: ReactStylesheet.createStylesheet({
	      Error: _Error2['default'],
	      Root: 'div'
	    }),
	    enumerable: true
	  }]);
	
	  var _ErrorList = ErrorList;
	  ErrorList = ReactStylesheet.styleable(ErrorList) || ErrorList;
	  return ErrorList;
	})(_Component3['default']);
	
	exports['default'] = ErrorList;
	module.exports = exports['default'];

/***/ },
/* 58 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @copyright 2015, Prometheus Research, LLC
	 */
	
	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = Error;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	function Error(_ref) {
	  var error = _ref.error;
	  var label = _ref.label;
	  var noLabel = _ref.noLabel;
	  var complete = _ref.complete;
	
	  if (!error) {
	    return _react2['default'].createElement('noscript', null);
	  }
	  if (!label && error.schema) {
	    label = error.schema.label;
	  }
	  if (label && complete && !noLabel) {
	    return _react2['default'].createElement(
	      'div',
	      null,
	      label,
	      ': ',
	      error.message
	    );
	  } else {
	    return _react2['default'].createElement(
	      'div',
	      null,
	      error.message
	    );
	  }
	}
	
	module.exports = exports['default'];

/***/ },
/* 59 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @copyright 2015, Prometheus Research, LLC
	 */
	
	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = Label;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	function Label(_ref) {
	  var _ref$schema = _ref.schema;
	  var schema = _ref$schema === undefined ? {} : _ref$schema;
	  var _ref$label = _ref.label;
	  var label = _ref$label === undefined ? schema.label : _ref$label;
	  return (function () {
	    return label ? _react2['default'].createElement(
	      'label',
	      null,
	      label
	    ) : _react2['default'].createElement('noscript', null);
	  })();
	}
	
	module.exports = exports['default'];

/***/ },
/* 60 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(console) {/**
	 * @copyright 2015, Prometheus Research, LLC
	 */
	
	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _createDecoratedClass = (function () { function defineProperties(target, descriptors, initializers) { for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === 'function') { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator); } } if (descriptor.initializer !== undefined) { initializers[key] = descriptor; continue; } } Object.defineProperty(target, key, descriptor); } } return function (Constructor, protoProps, staticProps, protoInitializers, staticInitializers) { if (protoProps) defineProperties(Constructor.prototype, protoProps, protoInitializers); if (staticProps) defineProperties(Constructor, staticProps, staticInitializers); return Constructor; }; })();
	
	var _get = function get(_x5, _x6, _x7) { var _again = true; _function: while (_again) { var object = _x5, property = _x6, receiver = _x7; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x5 = parent; _x6 = property; _x7 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	exports.isValue = isValue;
	exports['default'] = createValue;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	var _memoizeDecorator = __webpack_require__(23);
	
	var _memoizeDecorator2 = _interopRequireDefault(_memoizeDecorator);
	
	var _lodashObjectGet = __webpack_require__(61);
	
	var _lodashObjectGet2 = _interopRequireDefault(_lodashObjectGet);
	
	var _emptyFunction = __webpack_require__(56);
	
	var _emptyFunction2 = _interopRequireDefault(_emptyFunction);
	
	var _immupdate = __webpack_require__(66);
	
	var _immupdate2 = _interopRequireDefault(_immupdate);
	
	var _keyPath = __webpack_require__(42);
	
	var _keyPath2 = _interopRequireDefault(_keyPath);
	
	var _Schema = __webpack_require__(67);
	
	var Value = (function () {
	  function Value() {
	    _classCallCheck(this, Value);
	  }
	
	  _createClass(Value, [{
	    key: 'select',
	    value: function select(key) {
	      var keyPath = this.keyPath.concat((0, _keyPath2['default'])(key));
	      return new ValueLeaf(this._root, keyPath);
	    }
	  }, {
	    key: 'set',
	    value: function set(value, quiet) {
	      console.warn( // eslint-disable-line no-console
	      'Value.prototype.set(value) is deprecated, ' + 'use Value.prototype.update(value) instead');
	      return this.update(value, quiet);
	    }
	  }, {
	    key: 'update',
	    value: function update(value, quiet) {
	      var rootValue = undefined;
	      if (this.keyPath.length === 0) {
	        rootValue = value;
	      } else {
	        rootValue = (0, _immupdate2['default'])(this._root.value, this.keyPath.join('.'), value);
	      }
	      var nextRoot = createValue(this._root.schema, rootValue, this._root.onChange, this._root.params);
	      if (!quiet) {
	        this._root.onChange(nextRoot);
	      }
	      return nextRoot;
	    }
	  }]);
	
	  return Value;
	})();
	
	exports.Value = Value;
	
	var ValueRoot = (function (_Value) {
	  _inherits(ValueRoot, _Value);
	
	  function ValueRoot(schema, value, onChange, params, errorList) {
	    _classCallCheck(this, ValueRoot);
	
	    _get(Object.getPrototypeOf(ValueRoot.prototype), 'constructor', this).call(this);
	    this.keyPath = [];
	    this.parent = null;
	    this._root = this;
	    this.keyPath = [];
	    this.schema = schema;
	    this.value = value;
	    this.onChange = onChange;
	    this.params = params;
	    this.errorList = errorList.filter(function (error) {
	      return error.field === 'data';
	    });
	    this.completeErrorList = errorList;
	  }
	
	  return ValueRoot;
	})(Value);
	
	var ValueLeaf = (function (_Value2) {
	  _inherits(ValueLeaf, _Value2);
	
	  function ValueLeaf(root, keyPath) {
	    _classCallCheck(this, ValueLeaf);
	
	    _get(Object.getPrototypeOf(ValueLeaf.prototype), 'constructor', this).call(this);
	    this._root = root;
	    this.keyPath = keyPath;
	    this.schema = (0, _Schema.select)(root.schema, keyPath);
	    this.value = (0, _lodashObjectGet2['default'])(root.value, keyPath);
	  }
	
	  _createDecoratedClass(ValueLeaf, [{
	    key: 'params',
	    get: function get() {
	      return this._root.params;
	    }
	  }, {
	    key: 'errorList',
	    decorators: [_memoizeDecorator2['default']],
	    get: function get() {
	      var errorKeyPath = 'data.' + this.keyPath.join('.');
	      return this._root.completeErrorList.filter(function (error) {
	        return error.field === errorKeyPath;
	      });
	    }
	  }, {
	    key: 'completeErrorList',
	    decorators: [_memoizeDecorator2['default']],
	    get: function get() {
	      var errorKeyPath = 'data.' + this.keyPath.join('.');
	      var length = errorKeyPath.length;
	      return this._root.completeErrorList.filter(function (error) {
	        return error.field.slice(0, length) === errorKeyPath;
	      });
	    }
	  }, {
	    key: 'parent',
	    get: function get() {
	      if (this.keyPath.length === 1) {
	        return this._root;
	      } else {
	        var keyPath = this.keyPath.slice();
	        keyPath.pop();
	        return new ValueLeaf(this._root, keyPath);
	      }
	    }
	  }]);
	
	  return ValueLeaf;
	})(Value);
	
	var NON_ENUMERABLE_PROP = {
	  enumerable: false,
	  writable: true,
	  configurable: true
	};
	
	function cache(obj, key, value) {
	  Object.defineProperty(obj, key, _extends({}, NON_ENUMERABLE_PROP, { value: value }));
	}
	
	function validate(schema, value) {
	  if (!schema) {
	    return [];
	  }
	  if (value.__schema === schema && value.__errorList) {
	    return value.__errorList;
	  } else {
	    if (schema.__validator === undefined) {
	      cache(schema, '__validator', (0, _Schema.Schema)(schema, { formats: schema.formats }));
	    }
	    var errorList = schema.__validator(value);
	    cache(value, '__schema', schema);
	    cache(value, '__errorList', errorList);
	    return errorList;
	  }
	}
	
	/**
	 * Check if value is a form value.
	 */
	
	function isValue(maybeValue) {
	  return maybeValue instanceof Value;
	}
	
	/**
	 * Create a new root value.
	 */
	
	function createValue(schema) {
	  var value = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
	  var onChange = arguments.length <= 2 || arguments[2] === undefined ? _emptyFunction2['default'] : arguments[2];
	  var params = arguments.length <= 3 || arguments[3] === undefined ? {} : arguments[3];
	  var errorList = arguments.length <= 4 || arguments[4] === undefined ? null : arguments[4];
	
	  if (errorList === null) {
	    errorList = validate(schema, value);
	  }
	  return new ValueRoot(schema, value, onChange, params, errorList);
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(36)))

/***/ },
/* 61 */
/***/ function(module, exports, __webpack_require__) {

	var baseGet = __webpack_require__(62),
	    toPath = __webpack_require__(64);
	
	/**
	 * Gets the property value at `path` of `object`. If the resolved value is
	 * `undefined` the `defaultValue` is used in its place.
	 *
	 * @static
	 * @memberOf _
	 * @category Object
	 * @param {Object} object The object to query.
	 * @param {Array|string} path The path of the property to get.
	 * @param {*} [defaultValue] The value returned if the resolved value is `undefined`.
	 * @returns {*} Returns the resolved value.
	 * @example
	 *
	 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
	 *
	 * _.get(object, 'a[0].b.c');
	 * // => 3
	 *
	 * _.get(object, ['a', '0', 'b', 'c']);
	 * // => 3
	 *
	 * _.get(object, 'a.b.c', 'default');
	 * // => 'default'
	 */
	function get(object, path, defaultValue) {
	  var result = object == null ? undefined : baseGet(object, toPath(path), (path + ''));
	  return result === undefined ? defaultValue : result;
	}
	
	module.exports = get;


/***/ },
/* 62 */
/***/ function(module, exports, __webpack_require__) {

	var toObject = __webpack_require__(63);
	
	/**
	 * The base implementation of `get` without support for string paths
	 * and default values.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {Array} path The path of the property to get.
	 * @param {string} [pathKey] The key representation of path.
	 * @returns {*} Returns the resolved value.
	 */
	function baseGet(object, path, pathKey) {
	  if (object == null) {
	    return;
	  }
	  if (pathKey !== undefined && pathKey in toObject(object)) {
	    path = [pathKey];
	  }
	  var index = 0,
	      length = path.length;
	
	  while (object != null && index < length) {
	    object = object[path[index++]];
	  }
	  return (index && index == length) ? object : undefined;
	}
	
	module.exports = baseGet;


/***/ },
/* 63 */
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(49);
	
	/**
	 * Converts `value` to an object if it's not one.
	 *
	 * @private
	 * @param {*} value The value to process.
	 * @returns {Object} Returns the object.
	 */
	function toObject(value) {
	  return isObject(value) ? value : Object(value);
	}
	
	module.exports = toObject;


/***/ },
/* 64 */
/***/ function(module, exports, __webpack_require__) {

	var baseToString = __webpack_require__(65),
	    isArray = __webpack_require__(45);
	
	/** Used to match property names within property paths. */
	var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\n\\]|\\.)*?)\2)\]/g;
	
	/** Used to match backslashes in property paths. */
	var reEscapeChar = /\\(\\)?/g;
	
	/**
	 * Converts `value` to property path array if it's not one.
	 *
	 * @private
	 * @param {*} value The value to process.
	 * @returns {Array} Returns the property path array.
	 */
	function toPath(value) {
	  if (isArray(value)) {
	    return value;
	  }
	  var result = [];
	  baseToString(value).replace(rePropName, function(match, number, quote, string) {
	    result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));
	  });
	  return result;
	}
	
	module.exports = toPath;


/***/ },
/* 65 */
/***/ function(module, exports) {

	/**
	 * Converts `value` to a string if it's not one. An empty string is returned
	 * for `null` or `undefined` values.
	 *
	 * @private
	 * @param {*} value The value to process.
	 * @returns {string} Returns the string.
	 */
	function baseToString(value) {
	  return value == null ? '' : (value + '');
	}
	
	module.exports = baseToString;


/***/ },
/* 66 */
/***/ function(module, exports) {

	
	function update(host, spec) {
	  // Single path string update like: update(obj, 'path1.path2.name', 'John');
	  if (arguments.length === 3) {
	    var value = arguments[2];
	    var paths = spec.split('.');
	    var specObj = {};
	    var currentObj = specObj;
	    paths.forEach(function(path, index) {
	      if (index === paths.length - 1) currentObj[path] = value;
	      else currentObj[path] = currentObj = {};
	    });
	    spec = specObj;
	  }
	
	  // If any of the branches of an object changed, then than object changed too: clone it.
	  // The type of the copy is inferred.
	  var copy = host
	    ? Array.isArray(host) ? host.slice() : clone(host)
	    : Array.isArray(spec) ? [] : {};
	
	  for (var key in spec) {
	    var specValue = spec[key];
	
	    if (specValue === DELETE) {
	      Array.isArray(copy) ? copy.splice(key, 1) : delete copy[key];
	    }
	    // The spec continues deeper
	    else if (isObject(specValue)) {
	      copy[key] = update(copy[key], specValue);
	    }
	    // Leaf update
	    else {
	      var newValue = (typeof specValue === 'function')
	        ? specValue(copy[key])
	        : specValue;
	
	      copy[key] = newValue;
	    }
	  }
	
	  return copy;
	}
	
	function clone(obj) {
	  var result = {};
	  Object.keys(obj).forEach(function(key) { result[key] = obj[key] });
	  return result;
	}
	
	function isObject(x) { return x && typeof x === 'object' && !Array.isArray(x) }
	
	
	var DELETE = update.DELETE = {};
	
	update.replace = function(value) {
	  return function() { return value };
	};
	
	
	module.exports = update;

/***/ },
/* 67 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @copyright 2015, Prometheus Research, LLC
	 */
	
	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	exports.Schema = Schema;
	exports.object = object;
	exports.array = array;
	exports.select = select;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _JSONSchema = __webpack_require__(68);
	
	var _JSONSchema2 = _interopRequireDefault(_JSONSchema);
	
	/**
	 * Create a React Forms schema validator.
	 */
	
	function Schema(schema, options) {
	  options = _extends({}, options, {
	    greedy: true,
	    undefinedAsObject: true,
	    nullAsObject: true,
	    undefinedAsArray: true,
	    nullAsUndefined: true,
	    nullAsArray: true,
	    nullAsBottomType: true
	  });
	  return (0, _JSONSchema2['default'])(schema, options);
	}
	
	function _generateSchemaBuilder(type) {
	  return function builder(params) {
	    return _extends({
	      type: type,
	      isRequired: params ? !!params.isRequired : false
	    }, params);
	  };
	}
	
	function object(properties, params) {
	  return _extends({
	    type: 'object',
	    properties: properties,
	    required: Object.keys(properties).filter(function (k) {
	      return properties[k].isRequired;
	    }),
	    isRequired: params ? !!params.isRequired : false
	  }, params);
	}
	
	function array(items, params) {
	  return _extends({
	    type: 'array',
	    items: items,
	    isRequired: params ? !!params.isRequired : false
	  }, params);
	}
	
	var string = _generateSchemaBuilder('string');
	exports.string = string;
	var number = _generateSchemaBuilder('number');
	
	exports.number = number;
	
	function select(schema, keyPath) {
	  for (var i = 0, len = keyPath.length; i < len; i++) {
	    if (!schema) {
	      return schema;
	    }
	    schema = _select(schema, keyPath[i]);
	  }
	  return schema;
	}
	
	function _select(schema, key) {
	  if (schema) {
	    if (schema.type === 'object') {
	      var subSchema = schema.properties ? schema.properties[key] : undefined;
	      if (Array.isArray(schema.required)) {
	        // transfer required info onto schema
	        subSchema = _extends({
	          type: 'object'
	        }, subSchema, {
	          isRequired: schema.required.indexOf(key) !== -1
	        });
	      }
	      return subSchema;
	    } else if (schema.type === 'array') {
	      if (schema.items) {
	        if (Array.isArray(schema.items)) {
	          // eslint-disable-line max-depth
	          return schema.items[key];
	        } else {
	          return schema.items;
	        }
	      } else {
	        return undefined;
	      }
	    } else {
	      throw new Error(JSON.stringify(schema) + ' ' + key);
	    }
	  }
	}

/***/ },
/* 68 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @copyright 2015, Prometheus Research, LLC
	 */
	
	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = JSONSchema;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _compileValidator = __webpack_require__(69);
	
	var _compileValidator2 = _interopRequireDefault(_compileValidator);
	
	/**
	 * Create a JSON schema validator which returns a list of errors for invalid
	 * objects and an empty list of errors for valid objects.
	 */
	
	function JSONSchema(schema, options) {
	  var validate = (0, _compileValidator2['default'])(schema, options);
	  return function validator(obj) {
	    var result = validate(obj);
	    var errors = validate.errors;
	    return result ? [] : errors;
	  };
	}
	
	module.exports = exports['default'];

/***/ },
/* 69 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @copyright 2014, Mathias Buus
	 * @copyright 2015, Prometheus Research, LLC
	 */
	
	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	exports['default'] = compileValidator;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _generateObjectProperty = __webpack_require__(70);
	
	var _generateObjectProperty2 = _interopRequireDefault(_generateObjectProperty);
	
	var _generateFunction = __webpack_require__(72);
	
	var _generateFunction2 = _interopRequireDefault(_generateFunction);
	
	var _jsonpointer = __webpack_require__(76);
	
	var _jsonpointer2 = _interopRequireDefault(_jsonpointer);
	
	var _Format = __webpack_require__(79);
	
	var _Format2 = _interopRequireDefault(_Format);
	
	var HTTP_REF = /^https?:\/\//;
	var SPLIT_NAME = /[\[\]]/;
	
	function getSchemaByRef(obj, additionalSchemas, ptr) {
	  if (HTTP_REF.test(ptr)) {
	    return null;
	  }
	
	  function visit(sub) {
	    if (sub && sub.id === ptr) {
	      return sub;
	    }
	    if (typeof sub !== 'object' || !sub) {
	      return null;
	    }
	    return Object.keys(sub).reduce(function (res, k) {
	      return res || visit(sub[k]);
	    }, null);
	  }
	
	  var res = visit(obj);
	  if (res) {
	    return res;
	  }
	
	  ptr = ptr.replace(/^#/, '');
	  ptr = ptr.replace(/\/$/, '');
	
	  try {
	    return _jsonpointer2['default'].get(obj, decodeURI(ptr));
	  } catch (err) {
	    var other = additionalSchemas[ptr] || additionalSchemas[ptr.replace(/^#/, '')];
	    return other || null;
	  }
	}
	
	function formatName(field) {
	  field = field.replace(/\[/g, '[\u0001').split(SPLIT_NAME);
	  var formatted = [];
	  for (var i = 0; i < field.length; i++) {
	    var part = field[i];
	    if (part[0] === '\u0001') {
	      formatted.push(JSON.stringify('.'));
	      formatted.push(part.slice(1));
	    } else {
	      formatted.push(JSON.stringify(part));
	    }
	  }
	  return formatted.join('+');
	}
	
	var types = {
	  any: function any() {
	    return 'true';
	  },
	
	  'null': function _null(name) {
	    return name + ' === null';
	  },
	
	  boolean: function boolean(name) {
	    return 'typeof ' + name + ' === "boolean"';
	  },
	
	  array: function array(name) {
	    return 'Array.isArray(' + name + ')';
	  },
	
	  object: function object(name) {
	    return 'typeof ' + name + ' === "object" && ' + name + ' && !Array.isArray(' + name + ')';
	  },
	
	  number: function number(name) {
	    return 'typeof ' + name + ' === "number"';
	  },
	
	  integer: function integer(name) {
	    return 'typeof ' + name + ' === "number" && (Math.floor(' + name + ') === ' + name + ' || ' + name + ' > 9007199254740992 || ' + name + ' < -9007199254740992)'; // eslint-disable-line max-len
	  },
	
	  string: function string(name) {
	    return 'typeof ' + name + ' === "string"';
	  }
	};
	
	function unique(array) {
	  var list = [];
	  for (var i = 0; i < array.length; i++) {
	    list.push(typeof array[i] === 'object' ? JSON.stringify(array[i]) : array[i]);
	  }
	  for (var i = 1; i < list.length; i++) {
	    if (list.indexOf(list[i]) !== i) {
	      return false;
	    }
	  }
	  return true;
	}
	
	function compile(schema, cache, root) {
	  var opts = arguments.length <= 3 || arguments[3] === undefined ? {} : arguments[3];
	
	  var reporter = opts.reporter;
	  var formats = _extends({}, _Format2['default'], opts.formats);
	  var scope = { unique: unique, formats: formats };
	  var verbose = opts ? !!opts.verbose : false;
	  var undefinedAsObject = opts ? !!opts.undefinedAsObject : false;
	  var nullAsObject = opts ? !!opts.nullAsObject : false;
	  var nullAsUndefined = opts ? !!opts.nullAsUndefined : false;
	  var undefinedAsArray = opts ? !!opts.undefinedAsArray : false;
	  var nullAsArray = opts ? !!opts.nullAsArray : false;
	  var greedy = opts && opts.greedy !== undefined ? opts.greedy : false;
	
	  var syms = {};
	
	  function gensym(name) {
	    return name + (syms[name] = (syms[name] || 0) + 1);
	  }
	
	  var reversePatterns = {};
	  var patterns = function patterns(p) {
	    if (reversePatterns[p]) {
	      return reversePatterns[p];
	    }
	    var n = gensym('pattern');
	    scope[n] = new RegExp(p);
	    reversePatterns[p] = n;
	    return n;
	  };
	
	  var vars = ['i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'x', 'y', 'z'];
	  var genloop = function genloop() {
	    var v = vars.shift();
	    vars.push(v + v[0]);
	    return v;
	  };
	
	  function visit(name, _dataSym, node, reporter, filter) {
	    var properties = node.properties;
	    var type = node.type;
	    var tuple = false;
	
	    var dataSym = gensym('data');
	    validate('var %s = %s', dataSym, _dataSym);
	
	    var nodeSym = gensym('node');
	    scope[nodeSym] = node;
	
	    if (Array.isArray(node.items)) {
	      // tuple type
	      properties = {};
	      node.items.forEach(function (item, i) {
	        properties[i] = item;
	      });
	      type = 'array';
	      tuple = true;
	    }
	
	    var indent = 0;
	
	    function error(msg, prop, value, schema) {
	      validate('errors++');
	      if (reporter === true) {
	        validate('if (validate.errors === null) validate.errors = []');
	        if (verbose) {
	          validate('validate.errors.push({field:%s,message:%s,value:%s,schema:%s})', formatName(prop || name), JSON.stringify(msg), value || name, schema || nodeSym);
	        } else {
	          validate('validate.errors.push({field:%s,message:%s,schema:%s})', formatName(prop || name), JSON.stringify(msg), schema || nodeSym);
	        }
	      }
	    }
	    function errorFromSym(sym, schema) {
	      validate('errors++');
	      if (reporter === true) {
	        validate('if (validate.errors === null) validate.errors = []');
	        if (verbose) {
	          validate('validate.errors.push({field:%s,message:%s,value:%s,schema:%s})', formatName(name), sym, name, schema || nodeSym);
	        } else {
	          validate('validate.errors.push({field:%s,message:%s,schema:%s})', formatName(name), sym, schema || nodeSym);
	        }
	      }
	    }
	
	    if (node.required === true) {
	      indent++;
	      if (nullAsUndefined) {
	        validate('if (%s == undefined) {', dataSym);
	      } else {
	        validate('if (%s === undefined) {', dataSym);
	      }
	      error('is required');
	      validate('} else {');
	    } else {
	      if (node.type === 'object' && (undefinedAsObject || nullAsObject)) {
	        // eslint-disable-line no-lonely-if,max-len
	        if (undefinedAsObject && nullAsObject) {
	          validate('if (%s == null) %s = {}', dataSym, dataSym);
	        } else if (undefinedAsObject) {
	          validate('if (%s === undefined) %s = {}', dataSym, dataSym);
	        } else if (nullAsObject) {
	          validate('if (%s === null) %s = {}', dataSym, dataSym);
	        }
	      } else if (node.type === 'array' && (undefinedAsArray || nullAsArray)) {
	        if (undefinedAsArray && nullAsArray) {
	          validate('if (%s == null) %s = []', dataSym, dataSym);
	        } else if (undefinedAsArray) {
	          validate('if (%s === undefined) %s = []', dataSym, dataSym);
	        } else if (nullAsArray) {
	          validate('if (%s === null) %s = []', dataSym, dataSym);
	        }
	      } else {
	        indent++;
	        if (nullAsUndefined) {
	          validate('if (%s != undefined) {', dataSym);
	        } else {
	          validate('if (%s !== undefined) {', dataSym);
	        }
	      }
	    }
	
	    var valid = [].concat(type).map(function (t) {
	      return types[t || 'any'](dataSym);
	    }).join(' || ') || 'true';
	
	    if (valid !== 'true') {
	      indent++;
	      validate('if (!(%s)) {', valid);
	      error('is the wrong type');
	      validate('} else {');
	    }
	
	    if (tuple) {
	      if (node.additionalItems === false) {
	        validate('if (%s.length > %d) {', dataSym, node.items.length);
	        error('has additional items');
	        validate('}');
	      } else if (node.additionalItems) {
	        var i = genloop();
	        validate('for (var %s = %d; %s < %s.length; %s++) {', i, node.items.length, i, dataSym, i);
	        visit(name + '[' + i + ']', dataSym + '[' + i + ']', node.additionalItems, reporter, filter);
	        validate('}');
	      }
	    }
	
	    if (node.format && (formats[node.format] || typeof node.format === 'function')) {
	      if (type !== 'string' && formats[node.format]) {
	        validate('if (%s) {', types.string(dataSym));
	      }
	      var n = gensym('format');
	      if (typeof node.format === 'function') {
	        scope[n] = node.format;
	      } else {
	        scope[n] = formats[node.format];
	      }
	
	      if (typeof scope[n] === 'function') {
	        var r = gensym('result');
	        validate('var %s = %s(%s, %s)', r, n, dataSym, nodeSym);
	        validate('if (!%s) {', r);
	        error('must be ' + node.format + ' format');
	        validate('} else if (typeof %s === "string") {', r);
	        errorFromSym(r);
	        validate('}');
	      } else {
	        validate('if (!%s.test(%s)) {', n, dataSym);
	        error('must be ' + node.format + ' format');
	        validate('}');
	      }
	      if (type !== 'string' && formats[node.format]) {
	        validate('}');
	      }
	    }
	
	    if (Array.isArray(node.required)) {
	      var checkRequired = function checkRequired(req) {
	        if (nullAsUndefined) {
	          validate('if (%s == undefined) {', (0, _generateObjectProperty2['default'])(dataSym, req));
	        } else {
	          validate('if (%s === undefined) {', (0, _generateObjectProperty2['default'])(dataSym, req));
	        }
	        var reqSchema = (0, _generateObjectProperty2['default'])(nodeSym, 'properties') + ' ? ' + (0, _generateObjectProperty2['default'])((0, _generateObjectProperty2['default'])(nodeSym, 'properties'), req) + ' : undefined'; // eslint-disable-line max-len
	        error('is required', (0, _generateObjectProperty2['default'])(name, req), undefined, reqSchema);
	        validate('missing++');
	        validate('}');
	      };
	      validate('if ((%s)) {', type !== 'object' ? types.object(dataSym) : 'true');
	      validate('var missing = 0');
	      node.required.map(checkRequired);
	      validate('}');
	      if (!greedy) {
	        validate('if (missing === 0) {');
	        indent++;
	      }
	    }
	
	    if (node.uniqueItems) {
	      if (type !== 'array') {
	        validate('if (%s) {', types.array(dataSym));
	      }
	      validate('if (!(unique(%s))) {', dataSym);
	      error('must be unique');
	      validate('}');
	      if (type !== 'array') {
	        validate('}');
	      }
	    }
	
	    if (node['enum']) {
	      var complex = node['enum'].some(function (e) {
	        return typeof e === 'object';
	      });
	
	      var compare = complex ? function (e) {
	        return 'JSON.stringify(' + dataSym + ') !== JSON.stringify(' + JSON.stringify(e) + ')';
	      } : function (e) {
	        return dataSym + ' !== ' + JSON.stringify(e);
	      };
	
	      validate('if (%s) {', node['enum'].map(compare).join(' && ') || 'false');
	      error('must be an enum value');
	      validate('}');
	    }
	
	    if (node.dependencies) {
	      if (type !== 'object') {
	        validate('if (%s) {', types.object(dataSym));
	      }
	
	      Object.keys(node.dependencies).forEach(function (key) {
	        var deps = node.dependencies[key];
	        if (typeof deps === 'string') {
	          deps = [deps];
	        }
	
	        var exists = function exists(k) {
	          return (0, _generateObjectProperty2['default'])(dataSym, k) + ' !== undefined';
	        };
	
	        if (Array.isArray(deps)) {
	          validate('if (%s !== undefined && !(%s)) {', (0, _generateObjectProperty2['default'])(dataSym, key), deps.map(exists).join(' && ') || 'true');
	          error('dependencies not set');
	          validate('}');
	        }
	        if (typeof deps === 'object') {
	          validate('if (%s !== undefined) {', (0, _generateObjectProperty2['default'])(dataSym, key));
	          visit(name, dataSym, deps, reporter, filter);
	          validate('}');
	        }
	      });
	
	      if (type !== 'object') {
	        validate('}');
	      }
	    }
	
	    if (node.additionalProperties || node.additionalProperties === false) {
	      (function () {
	        if (type !== 'object') {
	          validate('if (%s) {', types.object(dataSym));
	        }
	
	        var i = genloop();
	        var keys = gensym('keys');
	
	        var toCompare = function toCompare(p) {
	          return keys + '[' + i + '] !== ' + JSON.stringify(p);
	        };
	
	        var toTest = function toTest(p) {
	          return '!' + patterns(p) + '.test(' + keys + '[' + i + '])';
	        };
	
	        var additionalProp = Object.keys(properties || {}).map(toCompare).concat(Object.keys(node.patternProperties || {}).map(toTest)).join(' && ') || 'true';
	
	        validate('var %s = Object.keys(%s)', keys, dataSym);
	        validate('  for (var %s = 0; %s < %s.length; %s++) {', i, i, keys, i);
	        validate('    if (%s) {', additionalProp);
	
	        if (node.additionalProperties === false) {
	          if (filter) {
	            validate('delete %s', dataSym + '[' + keys + '[' + i + ']]');
	          }
	          error('has additional properties', null, JSON.stringify(name + '.') + ' + ' + keys + '[' + i + ']');
	        } else {
	          visit(name + '[' + keys + '[' + i + ']]', dataSym + '[' + keys + '[' + i + ']]', node.additionalProperties, reporter, filter);
	        }
	
	        validate('  }');
	        validate('}');
	
	        if (type !== 'object') {
	          validate('}');
	        }
	      })();
	    }
	
	    if (node.$ref) {
	      var sub = getSchemaByRef(root, opts && opts.schemas || {}, node.$ref);
	      if (sub) {
	        (function () {
	          var fn = cache[node.$ref];
	          if (!fn) {
	            cache[node.$ref] = function proxy(data) {
	              return fn(data);
	            };
	            fn = compile(sub, cache, root, _extends({}, opts, { reporter: false }));
	          }
	          var n = gensym('ref');
	          scope[n] = fn;
	          validate('if (!(%s(%s))) {', n, dataSym);
	          error('referenced schema does not match');
	          validate('}');
	        })();
	      }
	    }
	
	    if (node.not) {
	      var prev = gensym('prev');
	      validate('var %s = errors', prev);
	      visit(name, dataSym, node.not, false, filter);
	      validate('if (%s === errors) {', prev);
	      error('negative schema matches');
	      validate('} else {');
	      validate('errors = %s', prev);
	      validate('}');
	    }
	
	    if (node.items && !tuple) {
	      if (type !== 'array') {
	        validate('if (%s) {', types.array(dataSym));
	      }
	
	      var i = genloop();
	      validate('for (var %s = 0; %s < %s.length; %s++) {', i, i, dataSym, i);
	      visit(name + '[' + i + ']', dataSym + '[' + i + ']', node.items, reporter, filter);
	      validate('}');
	
	      if (type !== 'array') {
	        validate('}');
	      }
	    }
	
	    if (node.patternProperties) {
	      (function () {
	        if (type !== 'object') {
	          validate('if (%s) {', types.object(dataSym));
	        }
	        var keys = gensym('keys');
	        var i = genloop();
	        validate('var %s = Object.keys(%s)', keys, dataSym);
	        validate('for (var %s = 0; %s < %s.length; %s++) {', i, i, keys, i);
	
	        Object.keys(node.patternProperties).forEach(function (key) {
	          var p = patterns(key);
	          validate('if (%s.test(%s)) {', p, keys + '[' + i + ']');
	          visit(name + '[' + keys + '[' + i + ']]', dataSym + '[' + keys + '[' + i + ']]', node.patternProperties[key], reporter, filter);
	          validate('}');
	        });
	
	        validate('}');
	        if (type !== 'object') {
	          validate('}');
	        }
	      })();
	    }
	
	    if (node.pattern) {
	      var p = patterns(node.pattern);
	      if (type !== 'string') {
	        validate('if (%s) {', types.string(dataSym));
	      }
	      validate('if (!(%s.test(%s))) {', p, dataSym);
	      error('pattern mismatch');
	      validate('}');
	      if (type !== 'string') {
	        validate('}');
	      }
	    }
	
	    if (node.allOf) {
	      node.allOf.forEach(function (sch) {
	        visit(name, dataSym, sch, reporter, filter);
	      });
	    }
	
	    if (node.anyOf && node.anyOf.length) {
	      (function () {
	        var prev = gensym('prev');
	
	        node.anyOf.forEach(function (sch, i) {
	          if (i === 0) {
	            validate('var %s = errors', prev);
	          } else {
	            validate('if (errors !== %s) {', prev);
	            validate('errors = %s', prev);
	          }
	          visit(name, dataSym, sch, false, false);
	        });
	        node.anyOf.forEach(function (sch, i) {
	          if (i) {
	            validate('}');
	          }
	        });
	        validate('if (%s !== errors) {', prev);
	        error('no schemas match');
	        validate('}');
	      })();
	    }
	
	    if (node.oneOf && node.oneOf.length) {
	      (function () {
	        var prev = gensym('prev');
	        var passes = gensym('passes');
	
	        validate('var %s = errors', prev);
	        validate('var %s = 0', passes);
	
	        node.oneOf.forEach(function (sch) {
	          visit(name, dataSym, sch, false, false);
	          validate('if (%s === errors) {', prev);
	          validate('  %s++', passes);
	          validate('} else {');
	          validate('  errors = %s', prev);
	          validate('}');
	        });
	
	        validate('if (%s !== 1) {', passes);
	        error('no (or more than one) schemas match');
	        validate('}');
	      })();
	    }
	
	    if (node.multipleOf !== undefined) {
	      if (type !== 'number' && type !== 'integer') {
	        validate('if (%s) {', types.number(dataSym));
	      }
	
	      var factor = (node.multipleOf | 0) !== node.multipleOf ? Math.pow(10, node.multipleOf.toString().split('.').pop().length) : 1;
	
	      if (factor > 1) {
	        validate('if ((%d*%s) % %d) {', factor, dataSym, factor * node.multipleOf);
	      } else {
	        validate('if (%s % %d) {', dataSym, node.multipleOf);
	      }
	
	      error('has a remainder');
	      validate('}');
	
	      if (type !== 'number' && type !== 'integer') {
	        validate('}');
	      }
	    }
	
	    if (node.maxProperties !== undefined) {
	      if (type !== 'object') {
	        validate('if (%s) {', types.object(dataSym));
	      }
	
	      validate('if (Object.keys(%s).length > %d) {', dataSym, node.maxProperties);
	      error('has more properties than allowed');
	      validate('}');
	
	      if (type !== 'object') {
	        validate('}');
	      }
	    }
	
	    if (node.minProperties !== undefined) {
	      if (type !== 'object') {
	        validate('if (%s) {', types.object(dataSym));
	      }
	
	      validate('if (Object.keys(%s).length < %d) {', dataSym, node.minProperties);
	      error('has less properties than allowed');
	      validate('}');
	
	      if (type !== 'object') {
	        validate('}');
	      }
	    }
	
	    if (node.maxItems !== undefined) {
	      if (type !== 'array') {
	        validate('if (%s) {', types.array(dataSym));
	      }
	
	      validate('if (%s.length > %d) {', dataSym, node.maxItems);
	      error('has more items than allowed');
	      validate('}');
	
	      if (type !== 'array') {
	        validate('}');
	      }
	    }
	
	    if (node.minItems !== undefined) {
	      if (type !== 'array') {
	        validate('if (%s) {', types.array(dataSym));
	      }
	
	      validate('if (%s.length < %d) {', dataSym, node.minItems);
	      error('has less items than allowed');
	      validate('}');
	
	      if (type !== 'array') {
	        validate('}');
	      }
	    }
	
	    if (node.maxLength !== undefined) {
	      if (type !== 'string') {
	        validate('if (%s) {', types.string(dataSym));
	      }
	
	      validate('if (%s.length > %d) {', dataSym, node.maxLength);
	      error('has longer length than allowed');
	      validate('}');
	
	      if (type !== 'string') {
	        validate('}');
	      }
	    }
	
	    if (node.minLength !== undefined) {
	      if (type !== 'string') {
	        validate('if (%s) {', types.string(dataSym));
	      }
	
	      validate('if (%s.length < %d) {', dataSym, node.minLength);
	      error('has less length than allowed');
	      validate('}');
	
	      if (type !== 'string') {
	        validate('}');
	      }
	    }
	
	    if (node.minimum !== undefined) {
	      validate('if (%s %s %d) {', dataSym, node.exclusiveMinimum ? '<=' : '<', node.minimum);
	      error('is less than minimum');
	      validate('}');
	    }
	
	    if (node.maximum !== undefined) {
	      validate('if (%s %s %d) {', dataSym, node.exclusiveMaximum ? '>=' : '>', node.maximum);
	      error('is more than maximum');
	      validate('}');
	    }
	
	    if (properties) {
	      Object.keys(properties).forEach(function (p) {
	        visit((0, _generateObjectProperty2['default'])(name, p), (0, _generateObjectProperty2['default'])(dataSym, p), properties[p], reporter, filter);
	      });
	    }
	
	    while (indent--) {
	      validate('}');
	    }
	  }
	
	  var validate = (0, _generateFunction2['default'])('function validate(data) {')('validate.errors = null')('var errors = 0');
	
	  visit('data', 'data', schema, reporter, opts && opts.filter);
	
	  validate('return errors === 0')('}');
	
	  validate = validate.toFunction(scope);
	  validate.errors = null;
	
	  validate.__defineGetter__('error', function () {
	    if (!validate.errors) {
	      return '';
	    } else {
	      return validate.errors.map(function (err) {
	        return err.field + ' ' + err.message;
	      }).join('\n');
	    }
	  });
	
	  validate.toJSON = function () {
	    return schema;
	  };
	
	  return validate;
	}
	
	/**
	 * Compile a new JSON Schema validator for the specified schema and options.
	 */
	
	function compileValidator(schema, opts) {
	  if (typeof schema === 'string') {
	    schema = JSON.parse(schema);
	  }
	  return compile(schema, {}, schema, _extends({}, opts, { reporter: true }));
	}
	
	module.exports = exports['default'];

/***/ },
/* 70 */
/***/ function(module, exports, __webpack_require__) {

	var isProperty = __webpack_require__(71)
	
	var gen = function(obj, prop) {
	  return isProperty(prop) ? obj+'.'+prop : obj+'['+JSON.stringify(prop)+']'
	}
	
	gen.valid = isProperty
	gen.property = function (prop) {
	 return isProperty(prop) ? prop : JSON.stringify(prop)
	}
	
	module.exports = gen


/***/ },
/* 71 */
/***/ function(module, exports) {

	"use strict"
	function isProperty(str) {
	  return /^[$A-Z\_a-z\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05d0-\u05ea\u05f0-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u08a0\u08a2-\u08ac\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097f\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c33\u0c35-\u0c39\u0c3d\u0c58\u0c59\u0c60\u0c61\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d60\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f4\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f0\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1877\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191c\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19c1-\u19c7\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1ce9-\u1cec\u1cee-\u1cf1\u1cf5\u1cf6\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2e2f\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309d-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312d\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fcc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua697\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua78e\ua790-\ua793\ua7a0-\ua7aa\ua7f8-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa80-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uabc0-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc][$A-Z\_a-z\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05d0-\u05ea\u05f0-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u08a0\u08a2-\u08ac\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097f\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c33\u0c35-\u0c39\u0c3d\u0c58\u0c59\u0c60\u0c61\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d60\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f4\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f0\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1877\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191c\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19c1-\u19c7\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1ce9-\u1cec\u1cee-\u1cf1\u1cf5\u1cf6\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2e2f\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309d-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312d\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fcc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua697\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua78e\ua790-\ua793\ua7a0-\ua7aa\ua7f8-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa80-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uabc0-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc0-9\u0300-\u036f\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u0669\u0670\u06d6-\u06dc\u06df-\u06e4\u06e7\u06e8\u06ea-\u06ed\u06f0-\u06f9\u0711\u0730-\u074a\u07a6-\u07b0\u07c0-\u07c9\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0859-\u085b\u08e4-\u08fe\u0900-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09cb-\u09cd\u09d7\u09e2\u09e3\u09e6-\u09ef\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2\u0ae3\u0ae6-\u0aef\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c01-\u0c03\u0c3e-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0c66-\u0c6f\u0c82\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0ce6-\u0cef\u0d02\u0d03\u0d3e-\u0d44\u0d46-\u0d48\u0d4a-\u0d4d\u0d57\u0d62\u0d63\u0d66-\u0d6f\u0d82\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0df2\u0df3\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0e50-\u0e59\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e\u0f3f\u0f71-\u0f84\u0f86\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u102b-\u103e\u1040-\u1049\u1056-\u1059\u105e-\u1060\u1062-\u1064\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b4-\u17d3\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u18a9\u1920-\u192b\u1930-\u193b\u1946-\u194f\u19b0-\u19c0\u19c8\u19c9\u19d0-\u19d9\u1a17-\u1a1b\u1a55-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1b00-\u1b04\u1b34-\u1b44\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1b82\u1ba1-\u1bad\u1bb0-\u1bb9\u1be6-\u1bf3\u1c24-\u1c37\u1c40-\u1c49\u1c50-\u1c59\u1cd0-\u1cd2\u1cd4-\u1ce8\u1ced\u1cf2-\u1cf4\u1dc0-\u1de6\u1dfc-\u1dff\u200c\u200d\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2cef-\u2cf1\u2d7f\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua620-\ua629\ua66f\ua674-\ua67d\ua69f\ua6f0\ua6f1\ua802\ua806\ua80b\ua823-\ua827\ua880\ua881\ua8b4-\ua8c4\ua8d0-\ua8d9\ua8e0-\ua8f1\ua900-\ua909\ua926-\ua92d\ua947-\ua953\ua980-\ua983\ua9b3-\ua9c0\ua9d0-\ua9d9\uaa29-\uaa36\uaa43\uaa4c\uaa4d\uaa50-\uaa59\uaa7b\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uaaeb-\uaaef\uaaf5\uaaf6\uabe3-\uabea\uabec\uabed\uabf0-\uabf9\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f]*$/.test(str)
	}
	module.exports = isProperty

/***/ },
/* 72 */
/***/ function(module, exports, __webpack_require__) {

	var util = __webpack_require__(73)
	
	var INDENT_START = /[\{\[]/
	var INDENT_END = /[\}\]]/
	
	module.exports = function() {
	  var lines = []
	  var indent = 0
	
	  var push = function(str) {
	    var spaces = ''
	    while (spaces.length < indent*2) spaces += '  '
	    lines.push(spaces+str)
	  }
	
	  var line = function(fmt) {
	    if (!fmt) return line
	
	    if (INDENT_END.test(fmt.trim()[0]) && INDENT_START.test(fmt[fmt.length-1])) {
	      indent--
	      push(util.format.apply(util, arguments))
	      indent++
	      return line
	    }
	    if (INDENT_START.test(fmt[fmt.length-1])) {
	      push(util.format.apply(util, arguments))
	      indent++
	      return line
	    }
	    if (INDENT_END.test(fmt.trim()[0])) {
	      indent--
	      push(util.format.apply(util, arguments))
	      return line
	    }
	
	    push(util.format.apply(util, arguments))
	    return line
	  }
	
	  line.toString = function() {
	    return lines.join('\n')
	  }
	
	  line.toFunction = function(scope) {
	    var src = 'return ('+line.toString()+')'
	
	    var keys = Object.keys(scope || {}).map(function(key) {
	      return key
	    })
	
	    var vals = keys.map(function(key) {
	      return scope[key]
	    })
	
	    return Function.apply(null, keys.concat(src)).apply(null, vals)
	  }
	
	  if (arguments.length) line.apply(null, arguments)
	
	  return line
	}


/***/ },
/* 73 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, process, console) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	var formatRegExp = /%[sdj%]/g;
	exports.format = function(f) {
	  if (!isString(f)) {
	    var objects = [];
	    for (var i = 0; i < arguments.length; i++) {
	      objects.push(inspect(arguments[i]));
	    }
	    return objects.join(' ');
	  }
	
	  var i = 1;
	  var args = arguments;
	  var len = args.length;
	  var str = String(f).replace(formatRegExp, function(x) {
	    if (x === '%%') return '%';
	    if (i >= len) return x;
	    switch (x) {
	      case '%s': return String(args[i++]);
	      case '%d': return Number(args[i++]);
	      case '%j':
	        try {
	          return JSON.stringify(args[i++]);
	        } catch (_) {
	          return '[Circular]';
	        }
	      default:
	        return x;
	    }
	  });
	  for (var x = args[i]; i < len; x = args[++i]) {
	    if (isNull(x) || !isObject(x)) {
	      str += ' ' + x;
	    } else {
	      str += ' ' + inspect(x);
	    }
	  }
	  return str;
	};
	
	
	// Mark that a method should not be used.
	// Returns a modified function which warns once by default.
	// If --no-deprecation is set, then it is a no-op.
	exports.deprecate = function(fn, msg) {
	  // Allow for deprecating things in the process of starting up.
	  if (isUndefined(global.process)) {
	    return function() {
	      return exports.deprecate(fn, msg).apply(this, arguments);
	    };
	  }
	
	  if (process.noDeprecation === true) {
	    return fn;
	  }
	
	  var warned = false;
	  function deprecated() {
	    if (!warned) {
	      if (process.throwDeprecation) {
	        throw new Error(msg);
	      } else if (process.traceDeprecation) {
	        console.trace(msg);
	      } else {
	        console.error(msg);
	      }
	      warned = true;
	    }
	    return fn.apply(this, arguments);
	  }
	
	  return deprecated;
	};
	
	
	var debugs = {};
	var debugEnviron;
	exports.debuglog = function(set) {
	  if (isUndefined(debugEnviron))
	    debugEnviron = process.env.NODE_DEBUG || '';
	  set = set.toUpperCase();
	  if (!debugs[set]) {
	    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
	      var pid = process.pid;
	      debugs[set] = function() {
	        var msg = exports.format.apply(exports, arguments);
	        console.error('%s %d: %s', set, pid, msg);
	      };
	    } else {
	      debugs[set] = function() {};
	    }
	  }
	  return debugs[set];
	};
	
	
	/**
	 * Echos the value of a value. Trys to print the value out
	 * in the best way possible given the different types.
	 *
	 * @param {Object} obj The object to print out.
	 * @param {Object} opts Optional options object that alters the output.
	 */
	/* legacy: obj, showHidden, depth, colors*/
	function inspect(obj, opts) {
	  // default options
	  var ctx = {
	    seen: [],
	    stylize: stylizeNoColor
	  };
	  // legacy...
	  if (arguments.length >= 3) ctx.depth = arguments[2];
	  if (arguments.length >= 4) ctx.colors = arguments[3];
	  if (isBoolean(opts)) {
	    // legacy...
	    ctx.showHidden = opts;
	  } else if (opts) {
	    // got an "options" object
	    exports._extend(ctx, opts);
	  }
	  // set default options
	  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
	  if (isUndefined(ctx.depth)) ctx.depth = 2;
	  if (isUndefined(ctx.colors)) ctx.colors = false;
	  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
	  if (ctx.colors) ctx.stylize = stylizeWithColor;
	  return formatValue(ctx, obj, ctx.depth);
	}
	exports.inspect = inspect;
	
	
	// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
	inspect.colors = {
	  'bold' : [1, 22],
	  'italic' : [3, 23],
	  'underline' : [4, 24],
	  'inverse' : [7, 27],
	  'white' : [37, 39],
	  'grey' : [90, 39],
	  'black' : [30, 39],
	  'blue' : [34, 39],
	  'cyan' : [36, 39],
	  'green' : [32, 39],
	  'magenta' : [35, 39],
	  'red' : [31, 39],
	  'yellow' : [33, 39]
	};
	
	// Don't use 'blue' not visible on cmd.exe
	inspect.styles = {
	  'special': 'cyan',
	  'number': 'yellow',
	  'boolean': 'yellow',
	  'undefined': 'grey',
	  'null': 'bold',
	  'string': 'green',
	  'date': 'magenta',
	  // "name": intentionally not styling
	  'regexp': 'red'
	};
	
	
	function stylizeWithColor(str, styleType) {
	  var style = inspect.styles[styleType];
	
	  if (style) {
	    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
	           '\u001b[' + inspect.colors[style][1] + 'm';
	  } else {
	    return str;
	  }
	}
	
	
	function stylizeNoColor(str, styleType) {
	  return str;
	}
	
	
	function arrayToHash(array) {
	  var hash = {};
	
	  array.forEach(function(val, idx) {
	    hash[val] = true;
	  });
	
	  return hash;
	}
	
	
	function formatValue(ctx, value, recurseTimes) {
	  // Provide a hook for user-specified inspect functions.
	  // Check that value is an object with an inspect function on it
	  if (ctx.customInspect &&
	      value &&
	      isFunction(value.inspect) &&
	      // Filter out the util module, it's inspect function is special
	      value.inspect !== exports.inspect &&
	      // Also filter out any prototype objects using the circular check.
	      !(value.constructor && value.constructor.prototype === value)) {
	    var ret = value.inspect(recurseTimes, ctx);
	    if (!isString(ret)) {
	      ret = formatValue(ctx, ret, recurseTimes);
	    }
	    return ret;
	  }
	
	  // Primitive types cannot have properties
	  var primitive = formatPrimitive(ctx, value);
	  if (primitive) {
	    return primitive;
	  }
	
	  // Look up the keys of the object.
	  var keys = Object.keys(value);
	  var visibleKeys = arrayToHash(keys);
	
	  if (ctx.showHidden) {
	    keys = Object.getOwnPropertyNames(value);
	  }
	
	  // IE doesn't make error fields non-enumerable
	  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
	  if (isError(value)
	      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
	    return formatError(value);
	  }
	
	  // Some type of object without properties can be shortcutted.
	  if (keys.length === 0) {
	    if (isFunction(value)) {
	      var name = value.name ? ': ' + value.name : '';
	      return ctx.stylize('[Function' + name + ']', 'special');
	    }
	    if (isRegExp(value)) {
	      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
	    }
	    if (isDate(value)) {
	      return ctx.stylize(Date.prototype.toString.call(value), 'date');
	    }
	    if (isError(value)) {
	      return formatError(value);
	    }
	  }
	
	  var base = '', array = false, braces = ['{', '}'];
	
	  // Make Array say that they are Array
	  if (isArray(value)) {
	    array = true;
	    braces = ['[', ']'];
	  }
	
	  // Make functions say that they are functions
	  if (isFunction(value)) {
	    var n = value.name ? ': ' + value.name : '';
	    base = ' [Function' + n + ']';
	  }
	
	  // Make RegExps say that they are RegExps
	  if (isRegExp(value)) {
	    base = ' ' + RegExp.prototype.toString.call(value);
	  }
	
	  // Make dates with properties first say the date
	  if (isDate(value)) {
	    base = ' ' + Date.prototype.toUTCString.call(value);
	  }
	
	  // Make error with message first say the error
	  if (isError(value)) {
	    base = ' ' + formatError(value);
	  }
	
	  if (keys.length === 0 && (!array || value.length == 0)) {
	    return braces[0] + base + braces[1];
	  }
	
	  if (recurseTimes < 0) {
	    if (isRegExp(value)) {
	      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
	    } else {
	      return ctx.stylize('[Object]', 'special');
	    }
	  }
	
	  ctx.seen.push(value);
	
	  var output;
	  if (array) {
	    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
	  } else {
	    output = keys.map(function(key) {
	      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
	    });
	  }
	
	  ctx.seen.pop();
	
	  return reduceToSingleString(output, base, braces);
	}
	
	
	function formatPrimitive(ctx, value) {
	  if (isUndefined(value))
	    return ctx.stylize('undefined', 'undefined');
	  if (isString(value)) {
	    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
	                                             .replace(/'/g, "\\'")
	                                             .replace(/\\"/g, '"') + '\'';
	    return ctx.stylize(simple, 'string');
	  }
	  if (isNumber(value))
	    return ctx.stylize('' + value, 'number');
	  if (isBoolean(value))
	    return ctx.stylize('' + value, 'boolean');
	  // For some reason typeof null is "object", so special case here.
	  if (isNull(value))
	    return ctx.stylize('null', 'null');
	}
	
	
	function formatError(value) {
	  return '[' + Error.prototype.toString.call(value) + ']';
	}
	
	
	function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
	  var output = [];
	  for (var i = 0, l = value.length; i < l; ++i) {
	    if (hasOwnProperty(value, String(i))) {
	      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
	          String(i), true));
	    } else {
	      output.push('');
	    }
	  }
	  keys.forEach(function(key) {
	    if (!key.match(/^\d+$/)) {
	      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
	          key, true));
	    }
	  });
	  return output;
	}
	
	
	function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
	  var name, str, desc;
	  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
	  if (desc.get) {
	    if (desc.set) {
	      str = ctx.stylize('[Getter/Setter]', 'special');
	    } else {
	      str = ctx.stylize('[Getter]', 'special');
	    }
	  } else {
	    if (desc.set) {
	      str = ctx.stylize('[Setter]', 'special');
	    }
	  }
	  if (!hasOwnProperty(visibleKeys, key)) {
	    name = '[' + key + ']';
	  }
	  if (!str) {
	    if (ctx.seen.indexOf(desc.value) < 0) {
	      if (isNull(recurseTimes)) {
	        str = formatValue(ctx, desc.value, null);
	      } else {
	        str = formatValue(ctx, desc.value, recurseTimes - 1);
	      }
	      if (str.indexOf('\n') > -1) {
	        if (array) {
	          str = str.split('\n').map(function(line) {
	            return '  ' + line;
	          }).join('\n').substr(2);
	        } else {
	          str = '\n' + str.split('\n').map(function(line) {
	            return '   ' + line;
	          }).join('\n');
	        }
	      }
	    } else {
	      str = ctx.stylize('[Circular]', 'special');
	    }
	  }
	  if (isUndefined(name)) {
	    if (array && key.match(/^\d+$/)) {
	      return str;
	    }
	    name = JSON.stringify('' + key);
	    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
	      name = name.substr(1, name.length - 2);
	      name = ctx.stylize(name, 'name');
	    } else {
	      name = name.replace(/'/g, "\\'")
	                 .replace(/\\"/g, '"')
	                 .replace(/(^"|"$)/g, "'");
	      name = ctx.stylize(name, 'string');
	    }
	  }
	
	  return name + ': ' + str;
	}
	
	
	function reduceToSingleString(output, base, braces) {
	  var numLinesEst = 0;
	  var length = output.reduce(function(prev, cur) {
	    numLinesEst++;
	    if (cur.indexOf('\n') >= 0) numLinesEst++;
	    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
	  }, 0);
	
	  if (length > 60) {
	    return braces[0] +
	           (base === '' ? '' : base + '\n ') +
	           ' ' +
	           output.join(',\n  ') +
	           ' ' +
	           braces[1];
	  }
	
	  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
	}
	
	
	// NOTE: These type checking functions intentionally don't use `instanceof`
	// because it is fragile and can be easily faked with `Object.create()`.
	function isArray(ar) {
	  return Array.isArray(ar);
	}
	exports.isArray = isArray;
	
	function isBoolean(arg) {
	  return typeof arg === 'boolean';
	}
	exports.isBoolean = isBoolean;
	
	function isNull(arg) {
	  return arg === null;
	}
	exports.isNull = isNull;
	
	function isNullOrUndefined(arg) {
	  return arg == null;
	}
	exports.isNullOrUndefined = isNullOrUndefined;
	
	function isNumber(arg) {
	  return typeof arg === 'number';
	}
	exports.isNumber = isNumber;
	
	function isString(arg) {
	  return typeof arg === 'string';
	}
	exports.isString = isString;
	
	function isSymbol(arg) {
	  return typeof arg === 'symbol';
	}
	exports.isSymbol = isSymbol;
	
	function isUndefined(arg) {
	  return arg === void 0;
	}
	exports.isUndefined = isUndefined;
	
	function isRegExp(re) {
	  return isObject(re) && objectToString(re) === '[object RegExp]';
	}
	exports.isRegExp = isRegExp;
	
	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}
	exports.isObject = isObject;
	
	function isDate(d) {
	  return isObject(d) && objectToString(d) === '[object Date]';
	}
	exports.isDate = isDate;
	
	function isError(e) {
	  return isObject(e) &&
	      (objectToString(e) === '[object Error]' || e instanceof Error);
	}
	exports.isError = isError;
	
	function isFunction(arg) {
	  return typeof arg === 'function';
	}
	exports.isFunction = isFunction;
	
	function isPrimitive(arg) {
	  return arg === null ||
	         typeof arg === 'boolean' ||
	         typeof arg === 'number' ||
	         typeof arg === 'string' ||
	         typeof arg === 'symbol' ||  // ES6 symbol
	         typeof arg === 'undefined';
	}
	exports.isPrimitive = isPrimitive;
	
	exports.isBuffer = __webpack_require__(74);
	
	function objectToString(o) {
	  return Object.prototype.toString.call(o);
	}
	
	
	function pad(n) {
	  return n < 10 ? '0' + n.toString(10) : n.toString(10);
	}
	
	
	var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
	              'Oct', 'Nov', 'Dec'];
	
	// 26 Feb 16:19:34
	function timestamp() {
	  var d = new Date();
	  var time = [pad(d.getHours()),
	              pad(d.getMinutes()),
	              pad(d.getSeconds())].join(':');
	  return [d.getDate(), months[d.getMonth()], time].join(' ');
	}
	
	
	// log is just a thin wrapper to console.log that prepends a timestamp
	exports.log = function() {
	  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
	};
	
	
	/**
	 * Inherit the prototype methods from one constructor into another.
	 *
	 * The Function.prototype.inherits from lang.js rewritten as a standalone
	 * function (not on Function.prototype). NOTE: If this file is to be loaded
	 * during bootstrapping this function needs to be rewritten using some native
	 * functions as prototype setup using normal JavaScript does not work as
	 * expected during bootstrapping (see mirror.js in r114903).
	 *
	 * @param {function} ctor Constructor function which needs to inherit the
	 *     prototype.
	 * @param {function} superCtor Constructor function to inherit prototype from.
	 */
	exports.inherits = __webpack_require__(75);
	
	exports._extend = function(origin, add) {
	  // Don't do anything if add isn't an object
	  if (!add || !isObject(add)) return origin;
	
	  var keys = Object.keys(add);
	  var i = keys.length;
	  while (i--) {
	    origin[keys[i]] = add[keys[i]];
	  }
	  return origin;
	};
	
	function hasOwnProperty(obj, prop) {
	  return Object.prototype.hasOwnProperty.call(obj, prop);
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(6), __webpack_require__(36)))

/***/ },
/* 74 */
/***/ function(module, exports) {

	module.exports = function isBuffer(arg) {
	  return arg && typeof arg === 'object'
	    && typeof arg.copy === 'function'
	    && typeof arg.fill === 'function'
	    && typeof arg.readUInt8 === 'function';
	}

/***/ },
/* 75 */
/***/ function(module, exports) {

	if (typeof Object.create === 'function') {
	  // implementation from standard node.js 'util' module
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    ctor.prototype = Object.create(superCtor.prototype, {
	      constructor: {
	        value: ctor,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	  };
	} else {
	  // old school shim for old browsers
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    var TempCtor = function () {}
	    TempCtor.prototype = superCtor.prototype
	    ctor.prototype = new TempCtor()
	    ctor.prototype.constructor = ctor
	  }
	}


/***/ },
/* 76 */
/***/ function(module, exports, __webpack_require__) {

	var console = __webpack_require__(77);
	
	var untilde = function(str) {
	  return str.replace(/~./g, function(m) {
	    switch (m) {
	      case "~0":
	        return "~";
	      case "~1":
	        return "/";
	    }
	    throw("Invalid tilde escape: " + m);
	  });
	}
	
	var traverse = function(obj, pointer, value) {
	  // assert(isArray(pointer))
	  var part = untilde(pointer.shift());
	  if(typeof obj[part] === "undefined") {
	    throw("Value for pointer '" + pointer + "' not found.");
	    return;
	  }
	  if(pointer.length !== 0) { // keep traversin!
	    return traverse(obj[part], pointer, value);
	  }
	  // we're done
	  if(typeof value === "undefined") {
	    // just reading
	    return obj[part];
	  }
	  // set new value, return old value
	  var old_value = obj[part];
	  if(value === null) {
	    delete obj[part];
	  } else {
	    obj[part] = value;
	  }
	  return old_value;
	}
	
	var validate_input = function(obj, pointer) {
	  if(typeof obj !== "object") {
	    throw("Invalid input object.");
	  }
	
	  if(pointer === "") {
	    return [];
	  }
	
	  if(!pointer) {
	    throw("Invalid JSON pointer.");
	  }
	
	  pointer = pointer.split("/");
	  var first = pointer.shift();
	  if (first !== "") {
	    throw("Invalid JSON pointer.");
	  }
	
	  return pointer;
	}
	
	var get = function(obj, pointer) {
	  pointer = validate_input(obj, pointer);
	  if (pointer.length === 0) {
	    return obj;
	  }
	  return traverse(obj, pointer);
	}
	
	var set = function(obj, pointer, value) {
	  pointer = validate_input(obj, pointer);
	  if (pointer.length === 0) {
	    throw("Invalid JSON pointer for set.")
	  }
	  return traverse(obj, pointer, value);
	}
	
	exports.get = get
	exports.set = set


/***/ },
/* 77 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(console, module) {// Avoid `console` errors in environments that lack a console.
	var method;
	var noop = function () {};
	var methods = [
	    'assert', 'clear', 'count', 'debug', 'dir', 'dirxml', 'error',
	    'exception', 'group', 'groupCollapsed', 'groupEnd', 'info', 'log',
	    'markTimeline', 'profile', 'profileEnd', 'table', 'time', 'timeEnd',
	    'timeStamp', 'trace', 'warn'
	];
	var length = methods.length;
	
	while (length--) {
	  method = methods[length];
	
	  // Only stub undefined methods.
	  if (!console[method]) {
	    console[method] = noop;
	  }
	}
	
	if ((typeof module !== "undefined" && module !== null) && module.exports) {
	  exports = module.exports = console;
	} else {
	  window.console = console;
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(36), __webpack_require__(78)(module)))

/***/ },
/* 78 */
/***/ function(module, exports) {

	module.exports = function(module) {
		if(!module.webpackPolyfill) {
			module.deprecate = function() {};
			module.paths = [];
			// module.parent = undefined by default
			module.children = [];
			module.webpackPolyfill = 1;
		}
		return module;
	}


/***/ },
/* 79 */
/***/ function(module, exports) {

	/**
	 * @copyright 2014, Mathias Buus
	 * @copyright 2015, Prometheus Research, LLC
	 */
	
	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	var Format = {};
	
	Format['date-time'] = /^\d{4}-(?:0[0-9]{1}|1[0-2]{1})-[0-9]{2}[tT ]\d{2}:\d{2}:\d{2}(\.\d+)?([zZ]|[+-]\d{2}:\d{2})$/; // eslint-disable-line max-len
	Format['date'] = /^\d{4}-(?:0[0-9]{1}|1[0-2]{1})-[0-9]{2}$/;
	Format['time'] = /^\d{2}:\d{2}:\d{2}$/;
	Format['email'] = /^\S+@\S+$/;
	Format['ip-address'] = Format['ipv4'] = /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/; // eslint-disable-line max-len
	Format['ipv6'] = /^\s*((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(%.+)?\s*$/; // eslint-disable-line max-len
	Format['uri'] = /^[a-zA-Z][a-zA-Z0-9+-.]*:[^\s]*$/;
	Format['color'] = /(#?([0-9A-Fa-f]{3,6})\b)|(aqua)|(black)|(blue)|(fuchsia)|(gray)|(green)|(lime)|(maroon)|(navy)|(olive)|(orange)|(purple)|(red)|(silver)|(teal)|(white)|(yellow)|(rgb\(\s*\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\b\s*,\s*\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\b\s*,\s*\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\b\s*\))|(rgb\(\s*(\d?\d%|100%)+\s*,\s*(\d?\d%|100%)+\s*,\s*(\d?\d%|100%)+\s*\))/; // eslint-disable-line max-len
	Format['hostname'] = /^([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])(\.([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\-]{0,61}[a-zA-Z0-9]))*$/; // eslint-disable-line max-len
	Format['alpha'] = /^[a-zA-Z]+$/;
	Format['alphanumeric'] = /^[a-zA-Z0-9]+$/;
	Format['style'] = /\s*(.+?):\s*([^;]+);?/g;
	Format['phone'] = /^\+(?:[0-9] ?){6,14}[0-9]$/;
	Format['utc-millisec'] = /^[0-9]+(\.?[0-9]+)?$/;
	
	exports['default'] = Format;
	module.exports = exports['default'];

/***/ },
/* 80 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @copyright 2015, Prometheus Research, LLC
	 */
	
	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };
	
	exports['default'] = WithFormValue;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _Component = __webpack_require__(41);
	
	var _Component2 = _interopRequireDefault(_Component);
	
	function WithFormValue(Component) {
	
	  var displayName = Component.displayName || Component.name;
	
	  return (function (_FormComponent) {
	    _inherits(_class, _FormComponent);
	
	    function _class() {
	      _classCallCheck(this, _class);
	
	      _get(Object.getPrototypeOf(_class.prototype), 'constructor', this).apply(this, arguments);
	    }
	
	    _createClass(_class, [{
	      key: 'render',
	      value: function render() {
	        return _react2['default'].createElement(Component, _extends({}, this.props, {
	          formValue: this.formValue
	        }));
	      }
	    }], [{
	      key: 'displayName',
	      value: 'WithFormValue(' + displayName + ')',
	      enumerable: true
	    }]);
	
	    return _class;
	  })(_Component2['default']);
	}
	
	module.exports = exports['default'];

/***/ }
/******/ ]);
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgZGZlMDJkNWYzOGFiYjc5NmM1OGEiLCJ3ZWJwYWNrOi8vLy4vc3JjL2luZGV4LmpzIiwid2VicGFjazovLy8uL3NyYy9GaWVsZHNldC5qcyIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwge1wicm9vdFwiOlwiUmVhY3RcIixcImNvbW1vbmpzXCI6XCJyZWFjdFwiLFwiY29tbW9uanMyXCI6XCJyZWFjdFwiLFwiYW1kXCI6XCJyZWFjdFwifSIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXN0eWxlc2hlZXQvbGliL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtc3R5bGVzaGVldC9saWIvYXR0YWNoU3R5bGVzaGVldC5qcyIsIndlYnBhY2s6Ly8vLi9+L2ludmFyaWFudC9icm93c2VyLmpzIiwid2VicGFjazovLy8uL34vcHJvY2Vzcy9icm93c2VyLmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtc3R5bGVzaGVldC9saWIvZ2V0Q29tcG9uZW50RGlzcGxheU5hbWUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1zdHlsZXNoZWV0L2xpYi9pc1ZhbGlkUmVhY3RDb21wb25lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1zdHlsZXNoZWV0L2xpYi9VdGlscy5qcyIsIndlYnBhY2s6Ly8vLi9+L2lzLWFycmF5L2luZGV4LmpzIiwid2VicGFjazovLy8uL34vaXMtcGxhaW4tb2JqZWN0L2luZGV4LmpzIiwid2VicGFjazovLy8uL34vaXNvYmplY3QvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9pcy1mdW5jdGlvbi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2lzLXN0cmluZy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3RvLXNsdWctY2FzZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3RvLXNwYWNlLWNhc2UvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi90by1uby1jYXNlL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vYW1wLXVuaXF1ZS1pZC91bmlxdWUtaWQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1zdHlsZXNoZWV0L2xpYi90cmFuc2ZlclN0YXRpY1Byb3BlcnRpZXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1zdHlsZXNoZWV0L2xpYi9TdHlsZXNoZWV0LmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtc3R5bGVzaGVldC9saWIvc3R5bGVDb21wb25lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1zdHlsZXNoZWV0L2xpYi9ET01TdHlsZXNoZWV0LmpzIiwid2VicGFjazovLy8uL34vbWVtb2l6ZS1kZWNvcmF0b3IvbGliL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vc3R5bGUtbG9hZGVyL2FkZFN0eWxlcy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9DU1NQcm9wZXJ0eU9wZXJhdGlvbnMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvQ1NTUHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9mYmpzL2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdFBlcmYuanMiLCJ3ZWJwYWNrOi8vLy4vfi9mYmpzL2xpYi9jYW1lbGl6ZVN0eWxlTmFtZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2ZianMvbGliL2NhbWVsaXplLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL2Rhbmdlcm91c1N0eWxlVmFsdWUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9mYmpzL2xpYi9oeXBoZW5hdGVTdHlsZU5hbWUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9mYmpzL2xpYi9oeXBoZW5hdGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9mYmpzL2xpYi9tZW1vaXplU3RyaW5nT25seS5qcyIsIndlYnBhY2s6Ly8vLi9+L2ZianMvbGliL3dhcm5pbmcuanMiLCJ3ZWJwYWNrOi8vLy4vfi9ub2RlLWxpYnMtYnJvd3Nlci9tb2NrL2NvbnNvbGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9mYmpzL2xpYi9lbXB0eUZ1bmN0aW9uLmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtc3R5bGVzaGVldC9saWIvU3R5bGVhYmxlRE9NQ29tcG9uZW50LmpzIiwid2VicGFjazovLy8uL34vY2xhc3NuYW1lcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXN0eWxlc2hlZXQvbGliL3N0eWxlYWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvQ29tcG9uZW50LmpzIiwid2VicGFjazovLy8uL3NyYy9rZXlQYXRoLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL2xhbmcvaXNTdHJpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvaW50ZXJuYWwvaXNPYmplY3RMaWtlLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL2xhbmcvaXNBcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9pbnRlcm5hbC9nZXROYXRpdmUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvbGFuZy9pc05hdGl2ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9sYW5nL2lzRnVuY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvbGFuZy9pc09iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9pbnRlcm5hbC9pc0xlbmd0aC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvRmllbGQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9hdXRvYmluZC1kZWNvcmF0b3IvbGliL2luZGV4LmpzIiwid2VicGFjazovLy8uL3NyYy9JbnB1dC5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9mdW5jdGlvbi9kZWJvdW5jZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9kYXRlL25vdy5qcyIsIndlYnBhY2s6Ly8vLi9+L2VtcHR5L2Z1bmN0aW9uLmpzIiwid2VicGFjazovLy8uL3NyYy9FcnJvckxpc3QuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0Vycm9yLmpzIiwid2VicGFjazovLy8uL3NyYy9MYWJlbC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvVmFsdWUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvb2JqZWN0L2dldC5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9pbnRlcm5hbC9iYXNlR2V0LmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL2ludGVybmFsL3RvT2JqZWN0LmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL2ludGVybmFsL3RvUGF0aC5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9pbnRlcm5hbC9iYXNlVG9TdHJpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vfi9pbW11cGRhdGUvaW1tdXBkYXRlLmpzIiwid2VicGFjazovLy8uL3NyYy9TY2hlbWEuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0pTT05TY2hlbWEvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0pTT05TY2hlbWEvY29tcGlsZVZhbGlkYXRvci5qcyIsIndlYnBhY2s6Ly8vLi9+L2dlbmVyYXRlLW9iamVjdC1wcm9wZXJ0eS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2lzLXByb3BlcnR5L2lzLXByb3BlcnR5LmpzIiwid2VicGFjazovLy8uL34vZ2VuZXJhdGUtZnVuY3Rpb24vaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi91dGlsL3V0aWwuanMiLCJ3ZWJwYWNrOi8vLy4vfi91dGlsL3N1cHBvcnQvaXNCdWZmZXJCcm93c2VyLmpzIiwid2VicGFjazovLy8uL34vaW5oZXJpdHMvaW5oZXJpdHNfYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9+L2pzb25wb2ludGVyL2pzb25wb2ludGVyLmpzIiwid2VicGFjazovLy8uL34vY29uc29sZS9jb25zb2xlLmpzIiwid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0pTT05TY2hlbWEvRm9ybWF0LmpzIiwid2VicGFjazovLy8uL3NyYy9XaXRoRm9ybVZhbHVlLmpzIl0sIm5hbWVzIjpbXSwibWFwcGlu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Szs7QUFFTDtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9FQUFtRSx5QkFBeUI7QUFDNUY7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0EsRUFBQzs7QUFFRDs7Ozs7OztBQ3BLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFxQztBQUNyQztBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLDJDQUEwQyx5QkFBeUIsRUFBRTtBQUNyRTtBQUNBO0FBQ0E7O0FBRUEsMkJBQTBCO0FBQzFCO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7QUNsREE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkNBQTRDLEtBQUs7O0FBRWpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBLE1BQUs7QUFDTDs7QUFFQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxvQ0FBbUMsT0FBTztBQUMxQztBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsMERBQXlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVztBQUNYLFVBQVM7QUFDVDtBQUNBO0FBQ0EsWUFBVztBQUNYO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxTQUFTO0FBQ3BCO0FBQ0EsWUFBVyxTQUFTO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUN6a0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFOzs7Ozs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ3RCQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7O0FDOUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7Ozs7Ozs7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7OztBQ0pBLEtBQUksTUFBTSxHQUFHLEVBQUUsQ0FBQzs7QUFFaEIsT0FBTSxDQUFDLFdBQVcsQ0FBQyxHQUFHLDhGQUE4RixDQUFDO0FBQ3JILE9BQU0sQ0FBQyxNQUFNLENBQUMsR0FBRywwQ0FBMEMsQ0FBQztBQUM1RCxPQUFNLENBQUMsTUFBTSxDQUFDLEdBQUcscUJBQXFCLENBQUM7QUFDdkMsT0FBTSxDQUFDLE9BQU8sQ0FBQyxHQUFHLFdBQVcsQ0FBQztBQUM5QixPQUFNLENBQUMsWUFBWSxDQUFDLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQyxHQUFHLDZGQUE2RixDQUFDO0FBQ3RJLE9BQU0sQ0FBQyxNQUFNLENBQUMsR0FBRyx5akNBQXlqQyxDQUFDO0FBQzNrQyxPQUFNLENBQUMsS0FBSyxDQUFDLEdBQUcsa0NBQWtDLENBQUM7QUFDbkQsT0FBTSxDQUFDLE9BQU8sQ0FBQyxHQUFHLHlhQUF5YSxDQUFDO0FBQzViLE9BQU0sQ0FBQyxVQUFVLENBQUMsR0FBRyx1SEFBdUgsQ0FBQztBQUM3SSxPQUFNLENBQUMsT0FBTyxDQUFDLEdBQUcsYUFBYSxDQUFDO0FBQ2hDLE9BQU0sQ0FBQyxjQUFjLENBQUMsR0FBRyxnQkFBZ0IsQ0FBQztBQUMxQyxPQUFNLENBQUMsT0FBTyxDQUFDLEdBQUcsd0JBQXdCLENBQUM7QUFDM0MsT0FBTSxDQUFDLE9BQU8sQ0FBQyxHQUFHLDRCQUE0QixDQUFDO0FBQy9DLE9BQU0sQ0FBQyxjQUFjLENBQUMsR0FBRyxzQkFBc0IsQ0FBQzs7c0JBRWpDLE1BQU07Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O3NCQ2ZHLGFBQWE7Ozs7Ozs7O2tDQUhYLENBQU87Ozs7c0NBQ1AsRUFBYTs7OztBQUV4QixVQUFTLGFBQWEsQ0FBQyxTQUFTLEVBQUU7O0FBRS9DLE9BQUksV0FBVyxHQUFHLFNBQVMsQ0FBQyxXQUFXLElBQUksU0FBUyxDQUFDLElBQUksQ0FBQzs7QUFFMUQ7Ozs7Ozs7Ozs7O2NBSVEsa0JBQUc7QUFDUCxnQkFDRSxpQ0FBQyxTQUFTLGVBQ0osSUFBSSxDQUFDLEtBQUs7QUFDZCxvQkFBUyxFQUFFLElBQUksQ0FBQyxTQUFVO1lBQ3hCLENBQ0o7UUFDSDs7O2lDQVRxQyxXQUFXOzs7Ozs4QkFVakQ7RUFDSCIsImZpbGUiOiJyZWFjdC1mb3Jtcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKVxuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuXG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRleHBvcnRzOiB7fSxcbiBcdFx0XHRpZDogbW9kdWxlSWQsXG4gXHRcdFx0bG9hZGVkOiBmYWxzZVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sb2FkZWQgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogd2VicGFjay9ib290c3RyYXAgZGZlMDJkNWYzOGFiYjc5NmM1OGFcbiAqKi8iLCIvKipcbiAqIEBjb3B5cmlnaHQgMjAxNSwgUHJvbWV0aGV1cyBSZXNlYXJjaCwgTExDXG4gKi9cblxuZXhwb3J0IEZpZWxkc2V0ICAgICAgIGZyb20gJy4vRmllbGRzZXQnO1xuZXhwb3J0IEZpZWxkICAgICAgICAgIGZyb20gJy4vRmllbGQnO1xuZXhwb3J0IFZhbHVlICAgICAgICAgIGZyb20gJy4vVmFsdWUnO1xuZXhwb3J0IFdpdGhGb3JtVmFsdWUgIGZyb20gJy4vV2l0aEZvcm1WYWx1ZSc7XG5leHBvcnQgKiBhcyBTY2hlbWEgICAgZnJvbSAnLi9TY2hlbWEnO1xuZXhwb3J0IElucHV0ICAgICAgICAgIGZyb20gJy4vSW5wdXQnO1xuZXhwb3J0IEVycm9yTGlzdCAgICAgIGZyb20gJy4vRXJyb3JMaXN0JztcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL2luZGV4LmpzXG4gKiovIiwiLyoqXG4gKiBAY29weXJpZ2h0IDIwMTUsIFByb21ldGhldXMgUmVzZWFyY2gsIExMQ1xuICovXG5cbmltcG9ydCBSZWFjdCwge1Byb3BUeXBlc30gZnJvbSAncmVhY3QnO1xuaW1wb3J0ICogYXMgUmVhY3RTdHlsZXNoZWV0IGZyb20gJ3JlYWN0LXN0eWxlc2hlZXQnO1xuaW1wb3J0IENvbXBvbmVudCBmcm9tICcuL0NvbXBvbmVudCc7XG5cbkBSZWFjdFN0eWxlc2hlZXQuc3R5bGVhYmxlXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBGaWVsZHNldCBleHRlbmRzIENvbXBvbmVudCB7XG5cbiAgc3RhdGljIHByb3BUeXBlcyA9IHtcbiAgICAuLi5Db21wb25lbnQucHJvcFR5cGVzLFxuICAgIGNoaWxkcmVuOiBQcm9wVHlwZXMubm9kZSxcbiAgfTtcblxuICBzdGF0aWMgc3R5bGVzaGVldCA9IFJlYWN0U3R5bGVzaGVldC5jcmVhdGVTdHlsZXNoZWV0KHtcbiAgICBSb290OiAnZGl2JyxcbiAgfSk7XG5cbiAgcmVuZGVyKCkge1xuICAgIHJldHVybiA8dGhpcy5zdHlsZXNoZWV0LlJvb3Qgey4uLnRoaXMucHJvcHN9IC8+O1xuICB9XG59XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9GaWVsZHNldC5qc1xuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInJlYWN0XCIpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogZXh0ZXJuYWwge1wicm9vdFwiOlwiUmVhY3RcIixcImNvbW1vbmpzXCI6XCJyZWFjdFwiLFwiY29tbW9uanMyXCI6XCJyZWFjdFwiLFwiYW1kXCI6XCJyZWFjdFwifVxuICoqIG1vZHVsZSBpZCA9IDJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQGNvcHlyaWdodCAyMDE1IFByb21ldGhldXMgUmVzZWFyY2gsIExMQ1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxudmFyIF9hdHRhY2hTdHlsZXNoZWV0MiA9IHJlcXVpcmUoJy4vYXR0YWNoU3R5bGVzaGVldCcpO1xuXG52YXIgX2F0dGFjaFN0eWxlc2hlZXQzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYXR0YWNoU3R5bGVzaGVldDIpO1xuXG5leHBvcnRzLmF0dGFjaFN0eWxlc2hlZXQgPSBfYXR0YWNoU3R5bGVzaGVldDNbJ2RlZmF1bHQnXTtcblxudmFyIF9zdHlsZUNvbXBvbmVudDIgPSByZXF1aXJlKCcuL3N0eWxlQ29tcG9uZW50Jyk7XG5cbnZhciBfc3R5bGVDb21wb25lbnQzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc3R5bGVDb21wb25lbnQyKTtcblxuZXhwb3J0cy5zdHlsZUNvbXBvbmVudCA9IF9zdHlsZUNvbXBvbmVudDNbJ2RlZmF1bHQnXTtcblxudmFyIF9TdHlsZXNoZWV0ID0gcmVxdWlyZSgnLi9TdHlsZXNoZWV0Jyk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnY3JlYXRlU3R5bGVzaGVldCcsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9TdHlsZXNoZWV0LmNyZWF0ZVN0eWxlc2hlZXQ7XG4gIH1cbn0pO1xuXG52YXIgX3N0eWxlYWJsZTIgPSByZXF1aXJlKCcuL3N0eWxlYWJsZScpO1xuXG52YXIgX3N0eWxlYWJsZTMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zdHlsZWFibGUyKTtcblxuZXhwb3J0cy5zdHlsZWFibGUgPSBfc3R5bGVhYmxlM1snZGVmYXVsdCddO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3Qtc3R5bGVzaGVldC9saWIvaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSAzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIEBjb3B5cmlnaHQgMjAxNSBQcm9tZXRoZXVzIFJlc2VhcmNoLCBMTENcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gKGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmICgndmFsdWUnIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KSgpO1xuXG52YXIgX2dldCA9IGZ1bmN0aW9uIGdldChfeCwgX3gyLCBfeDMpIHsgdmFyIF9hZ2FpbiA9IHRydWU7IF9mdW5jdGlvbjogd2hpbGUgKF9hZ2FpbikgeyB2YXIgb2JqZWN0ID0gX3gsIHByb3BlcnR5ID0gX3gyLCByZWNlaXZlciA9IF94MzsgX2FnYWluID0gZmFsc2U7IGlmIChvYmplY3QgPT09IG51bGwpIG9iamVjdCA9IEZ1bmN0aW9uLnByb3RvdHlwZTsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgcHJvcGVydHkpOyBpZiAoZGVzYyA9PT0gdW5kZWZpbmVkKSB7IHZhciBwYXJlbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKHBhcmVudCA9PT0gbnVsbCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IGVsc2UgeyBfeCA9IHBhcmVudDsgX3gyID0gcHJvcGVydHk7IF94MyA9IHJlY2VpdmVyOyBfYWdhaW4gPSB0cnVlOyBkZXNjID0gcGFyZW50ID0gdW5kZWZpbmVkOyBjb250aW51ZSBfZnVuY3Rpb247IH0gfSBlbHNlIGlmICgndmFsdWUnIGluIGRlc2MpIHsgcmV0dXJuIGRlc2MudmFsdWU7IH0gZWxzZSB7IHZhciBnZXR0ZXIgPSBkZXNjLmdldDsgaWYgKGdldHRlciA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gcmV0dXJuIGdldHRlci5jYWxsKHJlY2VpdmVyKTsgfSB9IH07XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IGF0dGFjaFN0eWxlc2hlZXQ7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gZWxzZSB7IHZhciBuZXdPYmogPSB7fTsgaWYgKG9iaiAhPSBudWxsKSB7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSBuZXdPYmpbJ2RlZmF1bHQnXSA9IG9iajsgcmV0dXJuIG5ld09iajsgfSB9XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb24nKTsgfSB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09ICdmdW5jdGlvbicgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90ICcgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgX3JlYWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0KTtcblxudmFyIF9pbnZhcmlhbnQgPSByZXF1aXJlKCdpbnZhcmlhbnQnKTtcblxudmFyIF9pbnZhcmlhbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW52YXJpYW50KTtcblxudmFyIF9nZXRDb21wb25lbnREaXNwbGF5TmFtZSA9IHJlcXVpcmUoJy4vZ2V0Q29tcG9uZW50RGlzcGxheU5hbWUnKTtcblxudmFyIF9nZXRDb21wb25lbnREaXNwbGF5TmFtZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9nZXRDb21wb25lbnREaXNwbGF5TmFtZSk7XG5cbnZhciBfaXNWYWxpZFJlYWN0Q29tcG9uZW50ID0gcmVxdWlyZSgnLi9pc1ZhbGlkUmVhY3RDb21wb25lbnQnKTtcblxudmFyIF9pc1ZhbGlkUmVhY3RDb21wb25lbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaXNWYWxpZFJlYWN0Q29tcG9uZW50KTtcblxudmFyIF90cmFuc2ZlclN0YXRpY1Byb3BlcnRpZXMgPSByZXF1aXJlKCcuL3RyYW5zZmVyU3RhdGljUHJvcGVydGllcycpO1xuXG52YXIgX3RyYW5zZmVyU3RhdGljUHJvcGVydGllczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90cmFuc2ZlclN0YXRpY1Byb3BlcnRpZXMpO1xuXG52YXIgX1N0eWxlc2hlZXQgPSByZXF1aXJlKCcuL1N0eWxlc2hlZXQnKTtcblxudmFyIFN0eWxlc2hlZXQgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfU3R5bGVzaGVldCk7XG5cbmZ1bmN0aW9uIGF0dGFjaFN0eWxlc2hlZXQoQ29tcG9uZW50LCBzcGVjKSB7XG4gIGlmICgoMCwgX2lzVmFsaWRSZWFjdENvbXBvbmVudDJbJ2RlZmF1bHQnXSkoQ29tcG9uZW50KSkge1xuICAgIHJldHVybiBhdHRhY2hTdHlsZXNoZWV0SW1wbChDb21wb25lbnQsIHNwZWMpO1xuICB9IGVsc2UgaWYgKHNwZWMgPT09IHVuZGVmaW5lZCkge1xuICAgIHZhciBfcmV0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBzcGVjID0gQ29tcG9uZW50O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdjogZnVuY3Rpb24gYXR0YWNoU3R5bGVzaGVldERlY29yYXRvcihDb21wb25lbnQpIHtcbiAgICAgICAgICByZXR1cm4gYXR0YWNoU3R5bGVzaGVldEltcGwoQ29tcG9uZW50LCBzcGVjKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9KSgpO1xuXG4gICAgaWYgKHR5cGVvZiBfcmV0ID09PSAnb2JqZWN0JykgcmV0dXJuIF9yZXQudjtcbiAgfSBlbHNlIHtcbiAgICAoMCwgX2ludmFyaWFudDJbJ2RlZmF1bHQnXSkoZmFsc2UsICdTdHlsZWFibGUoLi4uKTogY2FuIG9ubHkgYmUgdXNlZCBhcyBhIGRlY29yYXRvciBvciBmYWN0b3J5IGZ1bmN0aW9uJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gYXR0YWNoU3R5bGVzaGVldEltcGwoQ29tcG9uZW50LCBzcGVjKSB7XG4gIHZhciBTdHlsZWFibGVDb21wb25lbnQgPSAoZnVuY3Rpb24gKF9TdHlsZWFibGVDb21wb25lbnREZWNvcmF0b3IpIHtcbiAgICBfaW5oZXJpdHMoU3R5bGVhYmxlQ29tcG9uZW50LCBfU3R5bGVhYmxlQ29tcG9uZW50RGVjb3JhdG9yKTtcblxuICAgIGZ1bmN0aW9uIFN0eWxlYWJsZUNvbXBvbmVudCgpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTdHlsZWFibGVDb21wb25lbnQpO1xuXG4gICAgICBfZ2V0KE9iamVjdC5nZXRQcm90b3R5cGVPZihTdHlsZWFibGVDb21wb25lbnQucHJvdG90eXBlKSwgJ2NvbnN0cnVjdG9yJywgdGhpcykuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoU3R5bGVhYmxlQ29tcG9uZW50LCBudWxsLCBbe1xuICAgICAga2V5OiAnZGlzcGxheU5hbWUnLFxuICAgICAgdmFsdWU6ICdTdHlsZWFibGUoJyArICgwLCBfZ2V0Q29tcG9uZW50RGlzcGxheU5hbWUyWydkZWZhdWx0J10pKENvbXBvbmVudCkgKyAnKScsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgfSwge1xuICAgICAga2V5OiAnc3R5bGVzaGVldCcsXG4gICAgICB2YWx1ZTogU3R5bGVzaGVldC5jcmVhdGVTdHlsZXNoZWV0KHNwZWMpLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgIH0sIHtcbiAgICAgIGtleTogJ0NvbXBvbmVudCcsXG4gICAgICB2YWx1ZTogQ29tcG9uZW50LFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgIH1dKTtcblxuICAgIHJldHVybiBTdHlsZWFibGVDb21wb25lbnQ7XG4gIH0pKFN0eWxlYWJsZUNvbXBvbmVudERlY29yYXRvcik7XG4gICgwLCBfdHJhbnNmZXJTdGF0aWNQcm9wZXJ0aWVzMlsnZGVmYXVsdCddKShDb21wb25lbnQsIFN0eWxlYWJsZUNvbXBvbmVudCwgWydDb21wb25lbnQnLCAnc3R5bGVzaGVldCddKTtcbiAgcmV0dXJuIFN0eWxlYWJsZUNvbXBvbmVudDtcbn1cblxudmFyIFN0eWxlYWJsZUNvbXBvbmVudERlY29yYXRvciA9IChmdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICBfaW5oZXJpdHMoU3R5bGVhYmxlQ29tcG9uZW50RGVjb3JhdG9yLCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBTdHlsZWFibGVDb21wb25lbnREZWNvcmF0b3IoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFN0eWxlYWJsZUNvbXBvbmVudERlY29yYXRvcik7XG5cbiAgICBfZ2V0KE9iamVjdC5nZXRQcm90b3R5cGVPZihTdHlsZWFibGVDb21wb25lbnREZWNvcmF0b3IucHJvdG90eXBlKSwgJ2NvbnN0cnVjdG9yJywgdGhpcykuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhTdHlsZWFibGVDb21wb25lbnREZWNvcmF0b3IsIFt7XG4gICAga2V5OiAncmVuZGVyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgdmFyIF9jb25zdHJ1Y3RvciA9IHRoaXMuY29uc3RydWN0b3I7XG4gICAgICB2YXIgQ29tcG9uZW50ID0gX2NvbnN0cnVjdG9yLkNvbXBvbmVudDtcbiAgICAgIHZhciBzdHlsZXNoZWV0ID0gX2NvbnN0cnVjdG9yLnN0eWxlc2hlZXQ7XG5cbiAgICAgIHJldHVybiBfcmVhY3QyWydkZWZhdWx0J10uY3JlYXRlRWxlbWVudChDb21wb25lbnQsIF9leHRlbmRzKHsgc3R5bGVzaGVldDogc3R5bGVzaGVldCB9LCB0aGlzLnByb3BzKSk7XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6ICdzdHlsZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN0eWxlKHNwZWMpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHZhciBzdHlsZXNoZWV0ID0gU3R5bGVzaGVldC5vdmVycmlkZVN0eWxlc2hlZXQodGhpcy5zdHlsZXNoZWV0LCBzcGVjKTtcbiAgICAgIHZhciBTdHlsZWFibGVDb21wb25lbnQgPSAoZnVuY3Rpb24gKF9TdHlsZWFibGVDb21wb25lbnREZWNvcmF0b3IyKSB7XG4gICAgICAgIF9pbmhlcml0cyhTdHlsZWFibGVDb21wb25lbnQsIF9TdHlsZWFibGVDb21wb25lbnREZWNvcmF0b3IyKTtcblxuICAgICAgICBmdW5jdGlvbiBTdHlsZWFibGVDb21wb25lbnQoKSB7XG4gICAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFN0eWxlYWJsZUNvbXBvbmVudCk7XG5cbiAgICAgICAgICBfZ2V0KE9iamVjdC5nZXRQcm90b3R5cGVPZihTdHlsZWFibGVDb21wb25lbnQucHJvdG90eXBlKSwgJ2NvbnN0cnVjdG9yJywgdGhpcykuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIF9jcmVhdGVDbGFzcyhTdHlsZWFibGVDb21wb25lbnQsIG51bGwsIFt7XG4gICAgICAgICAga2V5OiAnc3R5bGVzaGVldCcsXG4gICAgICAgICAgdmFsdWU6IHN0eWxlc2hlZXQsXG4gICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgICB9LCB7XG4gICAgICAgICAga2V5OiAnQ29tcG9uZW50JyxcbiAgICAgICAgICB2YWx1ZTogX3RoaXMuQ29tcG9uZW50LFxuICAgICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICAgICAgfSwge1xuICAgICAgICAgIGtleTogJ2Rpc3BsYXlOYW1lJyxcbiAgICAgICAgICB2YWx1ZTogX3RoaXMuZGlzcGxheU5hbWUsXG4gICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgICB9XSk7XG5cbiAgICAgICAgcmV0dXJuIFN0eWxlYWJsZUNvbXBvbmVudDtcbiAgICAgIH0pKFN0eWxlYWJsZUNvbXBvbmVudERlY29yYXRvcik7XG4gICAgICAoMCwgX3RyYW5zZmVyU3RhdGljUHJvcGVydGllczJbJ2RlZmF1bHQnXSkodGhpcy5Db21wb25lbnQsIFN0eWxlYWJsZUNvbXBvbmVudCwgWydDb21wb25lbnQnLCAnc3R5bGVzaGVldCddKTtcbiAgICAgIHJldHVybiBTdHlsZWFibGVDb21wb25lbnQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnc3R5bGVzaGVldCcsXG4gICAgdmFsdWU6IG51bGwsXG4gICAgZW51bWVyYWJsZTogdHJ1ZVxuICB9LCB7XG4gICAga2V5OiAnQ29tcG9uZW50JyxcbiAgICB2YWx1ZTogbnVsbCxcbiAgICBlbnVtZXJhYmxlOiB0cnVlXG4gIH1dKTtcblxuICByZXR1cm4gU3R5bGVhYmxlQ29tcG9uZW50RGVjb3JhdG9yO1xufSkoX3JlYWN0MlsnZGVmYXVsdCddLkNvbXBvbmVudCk7XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3Qtc3R5bGVzaGVldC9saWIvYXR0YWNoU3R5bGVzaGVldC5qc1xuICoqIG1vZHVsZSBpZCA9IDRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBVc2UgaW52YXJpYW50KCkgdG8gYXNzZXJ0IHN0YXRlIHdoaWNoIHlvdXIgcHJvZ3JhbSBhc3N1bWVzIHRvIGJlIHRydWUuXG4gKlxuICogUHJvdmlkZSBzcHJpbnRmLXN0eWxlIGZvcm1hdCAob25seSAlcyBpcyBzdXBwb3J0ZWQpIGFuZCBhcmd1bWVudHNcbiAqIHRvIHByb3ZpZGUgaW5mb3JtYXRpb24gYWJvdXQgd2hhdCBicm9rZSBhbmQgd2hhdCB5b3Ugd2VyZVxuICogZXhwZWN0aW5nLlxuICpcbiAqIFRoZSBpbnZhcmlhbnQgbWVzc2FnZSB3aWxsIGJlIHN0cmlwcGVkIGluIHByb2R1Y3Rpb24sIGJ1dCB0aGUgaW52YXJpYW50XG4gKiB3aWxsIHJlbWFpbiB0byBlbnN1cmUgbG9naWMgZG9lcyBub3QgZGlmZmVyIGluIHByb2R1Y3Rpb24uXG4gKi9cblxudmFyIGludmFyaWFudCA9IGZ1bmN0aW9uKGNvbmRpdGlvbiwgZm9ybWF0LCBhLCBiLCBjLCBkLCBlLCBmKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFyaWFudCByZXF1aXJlcyBhbiBlcnJvciBtZXNzYWdlIGFyZ3VtZW50Jyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFjb25kaXRpb24pIHtcbiAgICB2YXIgZXJyb3I7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBlcnJvciA9IG5ldyBFcnJvcihcbiAgICAgICAgJ01pbmlmaWVkIGV4Y2VwdGlvbiBvY2N1cnJlZDsgdXNlIHRoZSBub24tbWluaWZpZWQgZGV2IGVudmlyb25tZW50ICcgK1xuICAgICAgICAnZm9yIHRoZSBmdWxsIGVycm9yIG1lc3NhZ2UgYW5kIGFkZGl0aW9uYWwgaGVscGZ1bCB3YXJuaW5ncy4nXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYXJncyA9IFthLCBiLCBjLCBkLCBlLCBmXTtcbiAgICAgIHZhciBhcmdJbmRleCA9IDA7XG4gICAgICBlcnJvciA9IG5ldyBFcnJvcihcbiAgICAgICAgZm9ybWF0LnJlcGxhY2UoLyVzL2csIGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJnc1thcmdJbmRleCsrXTsgfSlcbiAgICAgICk7XG4gICAgICBlcnJvci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICAgIH1cblxuICAgIGVycm9yLmZyYW1lc1RvUG9wID0gMTsgLy8gd2UgZG9uJ3QgY2FyZSBhYm91dCBpbnZhcmlhbnQncyBvd24gZnJhbWVcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBpbnZhcmlhbnQ7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9pbnZhcmlhbnQvYnJvd3Nlci5qc1xuICoqIG1vZHVsZSBpZCA9IDVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxuXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBzZXRUaW1lb3V0KGRyYWluUXVldWUsIDApO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcHJvY2Vzcy9icm93c2VyLmpzXG4gKiogbW9kdWxlIGlkID0gNlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBAY29weXJpZ2h0IDIwMTUgUHJvbWV0aGV1cyBSZXNlYXJjaCwgTExDXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IGdldENvbXBvbmVudERpc3BsYXlOYW1lO1xuXG5mdW5jdGlvbiBnZXRDb21wb25lbnREaXNwbGF5TmFtZShDb21wb25lbnQpIHtcbiAgcmV0dXJuIHR5cGVvZiBDb21wb25lbnQgPT09ICdzdHJpbmcnID8gQ29tcG9uZW50IDogQ29tcG9uZW50LmRpc3BsYXlOYW1lIHx8IENvbXBvbmVudC5uYW1lO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0LXN0eWxlc2hlZXQvbGliL2dldENvbXBvbmVudERpc3BsYXlOYW1lLmpzXG4gKiogbW9kdWxlIGlkID0gN1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBAY29weXJpZ2h0IDIwMTUgUHJvbWV0aGV1cyBSZXNlYXJjaCwgTExDXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IGlzVmFsaWRSZWFjdENvbXBvbmVudDtcblxudmFyIF9VdGlscyA9IHJlcXVpcmUoJy4vVXRpbHMnKTtcblxuLyoqXG4gKiBMb29zZSBjaGVjayBpZiB0aGUgYXJndW1lbnQgaXMgYSB2YWxpZCBSZWFjdCBjb21wb25lbnQuXG4gKi9cblxuZnVuY3Rpb24gaXNWYWxpZFJlYWN0Q29tcG9uZW50KENvbXBvbmVudCkge1xuICByZXR1cm4gKDAsIF9VdGlscy5pc1N0cmluZykoQ29tcG9uZW50KSB8fCAoMCwgX1V0aWxzLmlzRnVuY3Rpb24pKENvbXBvbmVudCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3Qtc3R5bGVzaGVldC9saWIvaXNWYWxpZFJlYWN0Q29tcG9uZW50LmpzXG4gKiogbW9kdWxlIGlkID0gOFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBAY29weXJpZ2h0IDIwMTUsIFByb21ldGhldXMgUmVzZWFyY2gsIExMQ1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxudmFyIF9pc0FycmF5MiA9IHJlcXVpcmUoJ2lzLWFycmF5Jyk7XG5cbnZhciBfaXNBcnJheTMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pc0FycmF5Mik7XG5cbmV4cG9ydHMuaXNBcnJheSA9IF9pc0FycmF5M1snZGVmYXVsdCddO1xuXG52YXIgX2lzUGxhaW5PYmplY3QyID0gcmVxdWlyZSgnaXMtcGxhaW4tb2JqZWN0Jyk7XG5cbnZhciBfaXNQbGFpbk9iamVjdDMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pc1BsYWluT2JqZWN0Mik7XG5cbmV4cG9ydHMuaXNQbGFpbk9iamVjdCA9IF9pc1BsYWluT2JqZWN0M1snZGVmYXVsdCddO1xuXG52YXIgX2lzRnVuY3Rpb24yID0gcmVxdWlyZSgnaXMtZnVuY3Rpb24nKTtcblxudmFyIF9pc0Z1bmN0aW9uMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2lzRnVuY3Rpb24yKTtcblxuZXhwb3J0cy5pc0Z1bmN0aW9uID0gX2lzRnVuY3Rpb24zWydkZWZhdWx0J107XG5cbnZhciBfaXNTdHJpbmcyID0gcmVxdWlyZSgnaXMtc3RyaW5nJyk7XG5cbnZhciBfaXNTdHJpbmczID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaXNTdHJpbmcyKTtcblxuZXhwb3J0cy5pc1N0cmluZyA9IF9pc1N0cmluZzNbJ2RlZmF1bHQnXTtcblxudmFyIF90b1NsdWdDYXNlID0gcmVxdWlyZSgndG8tc2x1Zy1jYXNlJyk7XG5cbnZhciBfdG9TbHVnQ2FzZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90b1NsdWdDYXNlKTtcblxuZXhwb3J0cy50b0Rhc2hDYXNlID0gX3RvU2x1Z0Nhc2UyWydkZWZhdWx0J107XG5cbnZhciBfYW1wVW5pcXVlSWQgPSByZXF1aXJlKCdhbXAtdW5pcXVlLWlkJyk7XG5cbnZhciBfYW1wVW5pcXVlSWQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYW1wVW5pcXVlSWQpO1xuXG5leHBvcnRzLnVuaXF1ZUlEID0gX2FtcFVuaXF1ZUlkMlsnZGVmYXVsdCddO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3Qtc3R5bGVzaGVldC9saWIvVXRpbHMuanNcbiAqKiBtb2R1bGUgaWQgPSA5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcbi8qKlxuICogaXNBcnJheVxuICovXG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcblxuLyoqXG4gKiB0b1N0cmluZ1xuICovXG5cbnZhciBzdHIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG4vKipcbiAqIFdoZXRoZXIgb3Igbm90IHRoZSBnaXZlbiBgdmFsYFxuICogaXMgYW4gYXJyYXkuXG4gKlxuICogZXhhbXBsZTpcbiAqXG4gKiAgICAgICAgaXNBcnJheShbXSk7XG4gKiAgICAgICAgLy8gPiB0cnVlXG4gKiAgICAgICAgaXNBcnJheShhcmd1bWVudHMpO1xuICogICAgICAgIC8vID4gZmFsc2VcbiAqICAgICAgICBpc0FycmF5KCcnKTtcbiAqICAgICAgICAvLyA+IGZhbHNlXG4gKlxuICogQHBhcmFtIHttaXhlZH0gdmFsXG4gKiBAcmV0dXJuIHtib29sfVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gaXNBcnJheSB8fCBmdW5jdGlvbiAodmFsKSB7XG4gIHJldHVybiAhISB2YWwgJiYgJ1tvYmplY3QgQXJyYXldJyA9PSBzdHIuY2FsbCh2YWwpO1xufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2lzLWFycmF5L2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMTBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qIVxuICogaXMtcGxhaW4tb2JqZWN0IDxodHRwczovL2dpdGh1Yi5jb20vam9uc2NobGlua2VydC9pcy1wbGFpbi1vYmplY3Q+XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LTIwMTUsIEpvbiBTY2hsaW5rZXJ0LlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnaXNvYmplY3QnKTtcblxuZnVuY3Rpb24gaXNPYmplY3RPYmplY3Qobykge1xuICByZXR1cm4gaXNPYmplY3QobykgPT09IHRydWVcbiAgICAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykgPT09ICdbb2JqZWN0IE9iamVjdF0nO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzUGxhaW5PYmplY3Qobykge1xuICB2YXIgY3Rvcixwcm90O1xuICBcbiAgaWYgKGlzT2JqZWN0T2JqZWN0KG8pID09PSBmYWxzZSkgcmV0dXJuIGZhbHNlO1xuICBcbiAgLy8gSWYgaGFzIG1vZGlmaWVkIGNvbnN0cnVjdG9yXG4gIGN0b3IgPSBvLmNvbnN0cnVjdG9yO1xuICBpZiAodHlwZW9mIGN0b3IgIT09ICdmdW5jdGlvbicpIHJldHVybiBmYWxzZTtcbiAgXG4gIC8vIElmIGhhcyBtb2RpZmllZCBwcm90b3R5cGVcbiAgcHJvdCA9IGN0b3IucHJvdG90eXBlO1xuICBpZiAoaXNPYmplY3RPYmplY3QocHJvdCkgPT09IGZhbHNlKSByZXR1cm4gZmFsc2U7XG4gIFxuICAvLyBJZiBjb25zdHJ1Y3RvciBkb2VzIG5vdCBoYXZlIGFuIE9iamVjdC1zcGVjaWZpYyBtZXRob2RcbiAgaWYgKHByb3QuaGFzT3duUHJvcGVydHkoJ2lzUHJvdG90eXBlT2YnKSA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgXG4gIC8vIE1vc3QgbGlrZWx5IGEgcGxhaW4gT2JqZWN0XG4gIHJldHVybiB0cnVlO1xufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2lzLXBsYWluLW9iamVjdC9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDExXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKiFcbiAqIGlzb2JqZWN0IDxodHRwczovL2dpdGh1Yi5jb20vam9uc2NobGlua2VydC9pc29iamVjdD5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtMjAxNSwgSm9uIFNjaGxpbmtlcnQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzT2JqZWN0KHZhbCkge1xuICByZXR1cm4gdmFsICE9IG51bGwgJiYgdHlwZW9mIHZhbCA9PT0gJ29iamVjdCdcbiAgICAmJiAhQXJyYXkuaXNBcnJheSh2YWwpO1xufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2lzb2JqZWN0L2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMTJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gaXNGdW5jdGlvblxuXG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nXG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24gKGZuKSB7XG4gIHZhciBzdHJpbmcgPSB0b1N0cmluZy5jYWxsKGZuKVxuICByZXR1cm4gc3RyaW5nID09PSAnW29iamVjdCBGdW5jdGlvbl0nIHx8XG4gICAgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJyAmJiBzdHJpbmcgIT09ICdbb2JqZWN0IFJlZ0V4cF0nKSB8fFxuICAgICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAvLyBJRTggYW5kIGJlbG93XG4gICAgIChmbiA9PT0gd2luZG93LnNldFRpbWVvdXQgfHxcbiAgICAgIGZuID09PSB3aW5kb3cuYWxlcnQgfHxcbiAgICAgIGZuID09PSB3aW5kb3cuY29uZmlybSB8fFxuICAgICAgZm4gPT09IHdpbmRvdy5wcm9tcHQpKVxufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2lzLWZ1bmN0aW9uL2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMTNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxudmFyIHN0clZhbHVlID0gU3RyaW5nLnByb3RvdHlwZS52YWx1ZU9mO1xudmFyIHRyeVN0cmluZ09iamVjdCA9IGZ1bmN0aW9uIHRyeVN0cmluZ09iamVjdCh2YWx1ZSkge1xuXHR0cnkge1xuXHRcdHN0clZhbHVlLmNhbGwodmFsdWUpO1xuXHRcdHJldHVybiB0cnVlO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG59O1xudmFyIHRvU3RyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbnZhciBzdHJDbGFzcyA9ICdbb2JqZWN0IFN0cmluZ10nO1xudmFyIGhhc1RvU3RyaW5nVGFnID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgU3ltYm9sLnRvU3RyaW5nVGFnID09PSAnc3ltYm9sJztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc1N0cmluZyh2YWx1ZSkge1xuXHRpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykgeyByZXR1cm4gdHJ1ZTsgfVxuXHRpZiAodHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JykgeyByZXR1cm4gZmFsc2U7IH1cblx0cmV0dXJuIGhhc1RvU3RyaW5nVGFnID8gdHJ5U3RyaW5nT2JqZWN0KHZhbHVlKSA6IHRvU3RyLmNhbGwodmFsdWUpID09PSBzdHJDbGFzcztcbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9pcy1zdHJpbmcvaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSAxNFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXG52YXIgdG9TcGFjZSA9IHJlcXVpcmUoJ3RvLXNwYWNlLWNhc2UnKTtcblxuXG4vKipcbiAqIEV4cG9zZSBgdG9TbHVnQ2FzZWAuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSB0b1NsdWdDYXNlO1xuXG5cbi8qKlxuICogQ29udmVydCBhIGBzdHJpbmdgIHRvIHNsdWcgY2FzZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cblxuXG5mdW5jdGlvbiB0b1NsdWdDYXNlIChzdHJpbmcpIHtcbiAgcmV0dXJuIHRvU3BhY2Uoc3RyaW5nKS5yZXBsYWNlKC9cXHMvZywgJy0nKTtcbn1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi90by1zbHVnLWNhc2UvaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSAxNVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXG52YXIgY2xlYW4gPSByZXF1aXJlKCd0by1uby1jYXNlJyk7XG5cblxuLyoqXG4gKiBFeHBvc2UgYHRvU3BhY2VDYXNlYC5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IHRvU3BhY2VDYXNlO1xuXG5cbi8qKlxuICogQ29udmVydCBhIGBzdHJpbmdgIHRvIHNwYWNlIGNhc2UuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZ1xuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5cblxuZnVuY3Rpb24gdG9TcGFjZUNhc2UgKHN0cmluZykge1xuICByZXR1cm4gY2xlYW4oc3RyaW5nKS5yZXBsYWNlKC9bXFxXX10rKC58JCkvZywgZnVuY3Rpb24gKG1hdGNoZXMsIG1hdGNoKSB7XG4gICAgcmV0dXJuIG1hdGNoID8gJyAnICsgbWF0Y2ggOiAnJztcbiAgfSk7XG59XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vdG8tc3BhY2UtY2FzZS9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDE2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcbi8qKlxuICogRXhwb3NlIGB0b05vQ2FzZWAuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSB0b05vQ2FzZTtcblxuXG4vKipcbiAqIFRlc3Qgd2hldGhlciBhIHN0cmluZyBpcyBjYW1lbC1jYXNlLlxuICovXG5cbnZhciBoYXNTcGFjZSA9IC9cXHMvO1xudmFyIGhhc0NhbWVsID0gL1thLXpdW0EtWl0vO1xudmFyIGhhc1NlcGFyYXRvciA9IC9bXFxXX10vO1xuXG5cbi8qKlxuICogUmVtb3ZlIGFueSBzdGFydGluZyBjYXNlIGZyb20gYSBgc3RyaW5nYCwgbGlrZSBjYW1lbCBvciBzbmFrZSwgYnV0IGtlZXBcbiAqIHNwYWNlcyBhbmQgcHVuY3R1YXRpb24gdGhhdCBtYXkgYmUgaW1wb3J0YW50IG90aGVyd2lzZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cblxuZnVuY3Rpb24gdG9Ob0Nhc2UgKHN0cmluZykge1xuICBpZiAoaGFzU3BhY2UudGVzdChzdHJpbmcpKSByZXR1cm4gc3RyaW5nLnRvTG93ZXJDYXNlKCk7XG5cbiAgaWYgKGhhc1NlcGFyYXRvci50ZXN0KHN0cmluZykpIHN0cmluZyA9IHVuc2VwYXJhdGUoc3RyaW5nKTtcbiAgaWYgKGhhc0NhbWVsLnRlc3Qoc3RyaW5nKSkgc3RyaW5nID0gdW5jYW1lbGl6ZShzdHJpbmcpO1xuICByZXR1cm4gc3RyaW5nLnRvTG93ZXJDYXNlKCk7XG59XG5cblxuLyoqXG4gKiBTZXBhcmF0b3Igc3BsaXR0ZXIuXG4gKi9cblxudmFyIHNlcGFyYXRvclNwbGl0dGVyID0gL1tcXFdfXSsoLnwkKS9nO1xuXG5cbi8qKlxuICogVW4tc2VwYXJhdGUgYSBgc3RyaW5nYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cblxuZnVuY3Rpb24gdW5zZXBhcmF0ZSAoc3RyaW5nKSB7XG4gIHJldHVybiBzdHJpbmcucmVwbGFjZShzZXBhcmF0b3JTcGxpdHRlciwgZnVuY3Rpb24gKG0sIG5leHQpIHtcbiAgICByZXR1cm4gbmV4dCA/ICcgJyArIG5leHQgOiAnJztcbiAgfSk7XG59XG5cblxuLyoqXG4gKiBDYW1lbGNhc2Ugc3BsaXR0ZXIuXG4gKi9cblxudmFyIGNhbWVsU3BsaXR0ZXIgPSAvKC4pKFtBLVpdKykvZztcblxuXG4vKipcbiAqIFVuLWNhbWVsY2FzZSBhIGBzdHJpbmdgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmdcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuXG5mdW5jdGlvbiB1bmNhbWVsaXplIChzdHJpbmcpIHtcbiAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKGNhbWVsU3BsaXR0ZXIsIGZ1bmN0aW9uIChtLCBwcmV2aW91cywgdXBwZXJzKSB7XG4gICAgcmV0dXJuIHByZXZpb3VzICsgJyAnICsgdXBwZXJzLnRvTG93ZXJDYXNlKCkuc3BsaXQoJycpLmpvaW4oJyAnKTtcbiAgfSk7XG59XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vdG8tbm8tY2FzZS9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDE3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKmdsb2JhbCB3aW5kb3csIGdsb2JhbCovXG52YXIgdGhlR2xvYmFsID0gKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSA/IHdpbmRvdyA6IGdsb2JhbDtcbmlmICghdGhlR2xvYmFsLl9fYW1wSWRDb3VudGVyKSB7XG4gICAgdGhlR2xvYmFsLl9fYW1wSWRDb3VudGVyID0gMDtcbn1cblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHVuaXF1ZUlkKHByZWZpeCkge1xuICAgIHZhciBpZCA9ICsrdGhlR2xvYmFsLl9fYW1wSWRDb3VudGVyICsgJyc7XG4gICAgcmV0dXJuIHByZWZpeCA/IHByZWZpeCArIGlkIDogaWQ7XG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYW1wLXVuaXF1ZS1pZC91bmlxdWUtaWQuanNcbiAqKiBtb2R1bGUgaWQgPSAxOFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBAY29weXJpZ2h0IDIwMTUsIFByb21ldGhldXMgUmVzZWFyY2gsIExMQ1xuICovXG5cbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0Z1bmN0aW9uXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gdHJhbnNmZXJTdGF0aWNQcm9wZXJ0aWVzO1xudmFyIEZVTkNUSU9OX1NUQVRJQ19QUk9QRVJUSUVTID0ge1xuICBhcmd1bWVudHM6IHRydWUsXG4gIGFyaXR5OiB0cnVlLFxuICBjYWxsZXI6IHRydWUsXG4gIGxlbmd0aDogdHJ1ZSxcbiAgbmFtZTogdHJ1ZSxcbiAgZGlzcGxheU5hbWU6IHRydWUsXG4gIHByb3RvdHlwZTogdHJ1ZVxufTtcblxuLyoqXG4gKiBUcmFuc2ZlciBhbGwgc3RhdGljIHByb3BlcnRpZXMgYW5kIG1ldGhvZHMgZnJvbSBgc291cmNlYCB0byBgdGFyZ2V0YC5cbiAqL1xuXG5mdW5jdGlvbiB0cmFuc2ZlclN0YXRpY1Byb3BlcnRpZXMoc291cmNlLCB0YXJnZXQpIHtcbiAgdmFyIGlnbm9yZUtleXMgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDIgfHwgYXJndW1lbnRzWzJdID09PSB1bmRlZmluZWQgPyBudWxsIDogYXJndW1lbnRzWzJdO1xuXG4gIHZhciBrZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoc291cmNlKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgaWYgKCFzb3VyY2UuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChGVU5DVElPTl9TVEFUSUNfUFJPUEVSVElFU1trZXldKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGlnbm9yZUtleXMgJiYgaWdub3JlS2V5cy5pbmRleE9mKGtleSkgPiAtMSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzW1wiZGVmYXVsdFwiXTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0LXN0eWxlc2hlZXQvbGliL3RyYW5zZmVyU3RhdGljUHJvcGVydGllcy5qc1xuICoqIG1vZHVsZSBpZCA9IDE5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIEBjb3B5cmlnaHQgMjAxNSwgUHJvbWV0aGV1cyBSZXNlYXJjaCwgTExDXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxuZXhwb3J0cy5jcmVhdGVTdHlsZXNoZWV0ID0gY3JlYXRlU3R5bGVzaGVldDtcbmV4cG9ydHMuaXNWYWxpZFN0eWxlc2hlZXQgPSBpc1ZhbGlkU3R5bGVzaGVldDtcbmV4cG9ydHMub3ZlcnJpZGVTdHlsZXNoZWV0ID0gb3ZlcnJpZGVTdHlsZXNoZWV0O1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhvYmosIGtleXMpIHsgdmFyIHRhcmdldCA9IHt9OyBmb3IgKHZhciBpIGluIG9iaikgeyBpZiAoa2V5cy5pbmRleE9mKGkpID49IDApIGNvbnRpbnVlOyBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGkpKSBjb250aW51ZTsgdGFyZ2V0W2ldID0gb2JqW2ldOyB9IHJldHVybiB0YXJnZXQ7IH1cblxudmFyIF9pbnZhcmlhbnQgPSByZXF1aXJlKCdpbnZhcmlhbnQnKTtcblxudmFyIF9pbnZhcmlhbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW52YXJpYW50KTtcblxudmFyIF9pc1ZhbGlkUmVhY3RDb21wb25lbnQgPSByZXF1aXJlKCcuL2lzVmFsaWRSZWFjdENvbXBvbmVudCcpO1xuXG52YXIgX2lzVmFsaWRSZWFjdENvbXBvbmVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pc1ZhbGlkUmVhY3RDb21wb25lbnQpO1xuXG52YXIgX3N0eWxlQ29tcG9uZW50ID0gcmVxdWlyZSgnLi9zdHlsZUNvbXBvbmVudCcpO1xuXG52YXIgX3N0eWxlQ29tcG9uZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3N0eWxlQ29tcG9uZW50KTtcblxuLyoqXG4gKiBDcmVhdGUgc3R5bGVzaGVldCBmcm9tIHN0eWxlc2hlZXQgc3BlYy5cbiAqL1xuXG5mdW5jdGlvbiBjcmVhdGVTdHlsZXNoZWV0KHNwZWMpIHtcbiAgdmFyIHN0eWxlc2hlZXQgPSB7fTtcbiAgZm9yICh2YXIga2V5IGluIHNwZWMpIHtcbiAgICBpZiAoIXNwZWMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHZhciBpdGVtID0gc3BlY1trZXldO1xuICAgIGlmICgoMCwgX2lzVmFsaWRSZWFjdENvbXBvbmVudDJbJ2RlZmF1bHQnXSkoaXRlbSkpIHtcbiAgICAgIHN0eWxlc2hlZXRba2V5XSA9IGl0ZW07XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBfaXRlbSRDb21wb25lbnQgPSBpdGVtLkNvbXBvbmVudDtcbiAgICAgIHZhciBDb21wb25lbnQgPSBfaXRlbSRDb21wb25lbnQgPT09IHVuZGVmaW5lZCA/ICdkaXYnIDogX2l0ZW0kQ29tcG9uZW50O1xuXG4gICAgICB2YXIgY29tcG9uZW50U3R5bGVzaGVldCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhpdGVtLCBbJ0NvbXBvbmVudCddKTtcblxuICAgICAgQ29tcG9uZW50ID0gKDAsIF9zdHlsZUNvbXBvbmVudDJbJ2RlZmF1bHQnXSkoQ29tcG9uZW50LCBjb21wb25lbnRTdHlsZXNoZWV0KTtcbiAgICAgIHN0eWxlc2hlZXRba2V5XSA9IENvbXBvbmVudDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0eWxlc2hlZXQ7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgb2JqZWN0IGlzIGEgdmFsaWQgc3R5bGVzaGVldC5cbiAqXG4gKiBPYmplY3QgaXMgYSBzdHlsZXNoZWV0IGlmIGV2ZXJ5IHZhbHVlIGlzIGEgdmFsaWQgUmVhY3QgY29tcG9uZW50LlxuICovXG5cbmZ1bmN0aW9uIGlzVmFsaWRTdHlsZXNoZWV0KG9iaikge1xuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgaWYgKCFvYmouaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmICghKDAsIF9pc1ZhbGlkUmVhY3RDb21wb25lbnQyWydkZWZhdWx0J10pKG9ialtrZXldKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBQcm9kdWNlIGEgbmV3IHN0eWxlc2hlZXQgYnkgb3ZlcnJpZGluZyBrZXlzIGZyb20gdGhlIG9yaWdpbmFsIHN0eWxlc2hlZXQgd2l0aFxuICogdmFsdWVzIGZyb20gc3BlYy5cbiAqXG4gKiBOb3RlIHRoYXQgYXMgc3R5bGVzaGVldCBpcyBhbHNvIGEgdmFsaWQgc3BlYyB0aGVuIHRoaXMgZnVuY3Rpb24gY2FuIGJlIHVzZWRcbiAqIHRvIG92ZXJyaWRlIG9uZSBzdHlsZXNoZWV0IHdpdGggYW5vdGhlci5cbiAqL1xuXG5mdW5jdGlvbiBvdmVycmlkZVN0eWxlc2hlZXQoc3R5bGVzaGVldCwgc3BlYykge1xuICAoMCwgX2ludmFyaWFudDJbJ2RlZmF1bHQnXSkoaXNWYWxpZFN0eWxlc2hlZXQoc3R5bGVzaGVldCksICdvdmVycmlkZVN0eWxlc2hlZXQoLi4uKTogZmlyc3QgYXJndW1lbnQgc2hvdWxkIGJlIGEgdmFsaWQgc3R5bGVzaGVldCcpO1xuICBzdHlsZXNoZWV0ID0gX2V4dGVuZHMoe30sIHN0eWxlc2hlZXQpO1xuICBmb3IgKHZhciBrZXkgaW4gc3BlYykge1xuICAgIGlmICghc3BlYy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgKDAsIF9pbnZhcmlhbnQyWydkZWZhdWx0J10pKHN0eWxlc2hlZXRba2V5XSAhPT0gdW5kZWZpbmVkLCAnb3ZlcnJpZGVTdHlsZXNoZWV0KC4uLik6IGludmFsaWQgb3ZlcnJpZGUsIHN0eWxlc2hlZXQgZG9lcyBub3QgaGF2ZSBrZXkgXCIlc1wiJywga2V5KTtcbiAgICB2YXIgaXRlbSA9IHNwZWNba2V5XTtcbiAgICBpZiAoKDAsIF9pc1ZhbGlkUmVhY3RDb21wb25lbnQyWydkZWZhdWx0J10pKGl0ZW0pKSB7XG4gICAgICBzdHlsZXNoZWV0W2tleV0gPSBpdGVtO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgX3NwZWMka2V5ID0gc3BlY1trZXldO1xuICAgICAgdmFyIF9zcGVjJGtleSRDb21wb25lbnQgPSBfc3BlYyRrZXkuQ29tcG9uZW50O1xuICAgICAgdmFyIENvbXBvbmVudCA9IF9zcGVjJGtleSRDb21wb25lbnQgPT09IHVuZGVmaW5lZCA/IHN0eWxlc2hlZXRba2V5XSA6IF9zcGVjJGtleSRDb21wb25lbnQ7XG5cbiAgICAgIHZhciBjb21wb25lbnRTdHlsZXNoZWV0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9zcGVjJGtleSwgWydDb21wb25lbnQnXSk7XG5cbiAgICAgIHN0eWxlc2hlZXRba2V5XSA9ICgwLCBfc3R5bGVDb21wb25lbnQyWydkZWZhdWx0J10pKENvbXBvbmVudCwgY29tcG9uZW50U3R5bGVzaGVldCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdHlsZXNoZWV0O1xufVxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3Qtc3R5bGVzaGVldC9saWIvU3R5bGVzaGVldC5qc1xuICoqIG1vZHVsZSBpZCA9IDIwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIEBjb3B5cmlnaHQgMjAxNSBQcm9tZXRoZXVzIFJlc2VhcmNoLCBMTENcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gKGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmICgndmFsdWUnIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KSgpO1xuXG52YXIgX2dldCA9IGZ1bmN0aW9uIGdldChfeDIsIF94MywgX3g0KSB7IHZhciBfYWdhaW4gPSB0cnVlOyBfZnVuY3Rpb246IHdoaWxlIChfYWdhaW4pIHsgdmFyIG9iamVjdCA9IF94MiwgcHJvcGVydHkgPSBfeDMsIHJlY2VpdmVyID0gX3g0OyBfYWdhaW4gPSBmYWxzZTsgaWYgKG9iamVjdCA9PT0gbnVsbCkgb2JqZWN0ID0gRnVuY3Rpb24ucHJvdG90eXBlOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wZXJ0eSk7IGlmIChkZXNjID09PSB1bmRlZmluZWQpIHsgdmFyIHBhcmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAocGFyZW50ID09PSBudWxsKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gZWxzZSB7IF94MiA9IHBhcmVudDsgX3gzID0gcHJvcGVydHk7IF94NCA9IHJlY2VpdmVyOyBfYWdhaW4gPSB0cnVlOyBkZXNjID0gcGFyZW50ID0gdW5kZWZpbmVkOyBjb250aW51ZSBfZnVuY3Rpb247IH0gfSBlbHNlIGlmICgndmFsdWUnIGluIGRlc2MpIHsgcmV0dXJuIGRlc2MudmFsdWU7IH0gZWxzZSB7IHZhciBnZXR0ZXIgPSBkZXNjLmdldDsgaWYgKGdldHRlciA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gcmV0dXJuIGdldHRlci5jYWxsKHJlY2VpdmVyKTsgfSB9IH07XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IHN0eWxlQ29tcG9uZW50O1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGVsc2UgeyB2YXIgbmV3T2JqID0ge307IGlmIChvYmogIT0gbnVsbCkgeyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gbmV3T2JqWydkZWZhdWx0J10gPSBvYmo7IHJldHVybiBuZXdPYmo7IH0gfVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uJyk7IH0gfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSAnZnVuY3Rpb24nICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCAnICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgX2ludmFyaWFudCA9IHJlcXVpcmUoJ2ludmFyaWFudCcpO1xuXG52YXIgX2ludmFyaWFudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbnZhcmlhbnQpO1xuXG52YXIgX0RPTVN0eWxlc2hlZXQgPSByZXF1aXJlKCcuL0RPTVN0eWxlc2hlZXQnKTtcblxudmFyIERPTVN0eWxlc2hlZXQgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfRE9NU3R5bGVzaGVldCk7XG5cbnZhciBfU3R5bGVhYmxlRE9NQ29tcG9uZW50MiA9IHJlcXVpcmUoJy4vU3R5bGVhYmxlRE9NQ29tcG9uZW50Jyk7XG5cbnZhciBfU3R5bGVhYmxlRE9NQ29tcG9uZW50MyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1N0eWxlYWJsZURPTUNvbXBvbmVudDIpO1xuXG52YXIgX2lzVmFsaWRSZWFjdENvbXBvbmVudCA9IHJlcXVpcmUoJy4vaXNWYWxpZFJlYWN0Q29tcG9uZW50Jyk7XG5cbnZhciBfaXNWYWxpZFJlYWN0Q29tcG9uZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2lzVmFsaWRSZWFjdENvbXBvbmVudCk7XG5cbnZhciBfZ2V0Q29tcG9uZW50RGlzcGxheU5hbWUgPSByZXF1aXJlKCcuL2dldENvbXBvbmVudERpc3BsYXlOYW1lJyk7XG5cbnZhciBfZ2V0Q29tcG9uZW50RGlzcGxheU5hbWUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2V0Q29tcG9uZW50RGlzcGxheU5hbWUpO1xuXG4vKipcbiAqIEFwcGx5IGEgc3R5bGVzaGVldCB0byBhIGNvbXBvbmVudC5cbiAqL1xuXG5mdW5jdGlvbiBzdHlsZUNvbXBvbmVudChDb21wb25lbnQsIHN0eWxlc2hlZXQpIHtcbiAgdmFyIG5hbWUgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDIgfHwgYXJndW1lbnRzWzJdID09PSB1bmRlZmluZWQgPyBudWxsIDogYXJndW1lbnRzWzJdO1xuXG4gICgwLCBfaW52YXJpYW50MlsnZGVmYXVsdCddKSgoMCwgX2lzVmFsaWRSZWFjdENvbXBvbmVudDJbJ2RlZmF1bHQnXSkoQ29tcG9uZW50KSwgJ0V4cGVjdGVkIGEgdmFsaWQgUmVhY3QgY29tcG9uZW50LCBnb3Q6ICVzJywgdHlwZW9mIENvbXBvbmVudCk7XG4gIGlmICh0eXBlb2YgQ29tcG9uZW50LnN0eWxlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIENvbXBvbmVudC5zdHlsZShzdHlsZXNoZWV0KTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoIURPTVN0eWxlc2hlZXQuaXNWYWxpZFN0eWxlc2hlZXQoc3R5bGVzaGVldCkpIHtcbiAgICAgIG5hbWUgPSBuYW1lIHx8ICgwLCBfZ2V0Q29tcG9uZW50RGlzcGxheU5hbWUyWydkZWZhdWx0J10pKENvbXBvbmVudCk7XG4gICAgICBzdHlsZXNoZWV0ID0gRE9NU3R5bGVzaGVldC5jcmVhdGVTdHlsZXNoZWV0KHN0eWxlc2hlZXQsIG5hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gc3R5bGVET01Db21wb25lbnQoQ29tcG9uZW50LCBzdHlsZXNoZWV0KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzdHlsZURPTUNvbXBvbmVudChDb21wb25lbnQsIHNwZWMpIHtcbiAgcmV0dXJuIChmdW5jdGlvbiAoX1N0eWxlYWJsZURPTUNvbXBvbmVudCkge1xuICAgIF9pbmhlcml0cyhfY2xhc3MsIF9TdHlsZWFibGVET01Db21wb25lbnQpO1xuXG4gICAgZnVuY3Rpb24gX2NsYXNzKCkge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIF9jbGFzcyk7XG5cbiAgICAgIF9nZXQoT2JqZWN0LmdldFByb3RvdHlwZU9mKF9jbGFzcy5wcm90b3R5cGUpLCAnY29uc3RydWN0b3InLCB0aGlzKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhfY2xhc3MsIG51bGwsIFt7XG4gICAgICBrZXk6ICdkaXNwbGF5TmFtZScsXG4gICAgICB2YWx1ZTogJ1N0eWxlYWJsZURPTUNvbXBvbmVudCgnICsgKDAsIF9nZXRDb21wb25lbnREaXNwbGF5TmFtZTJbJ2RlZmF1bHQnXSkoQ29tcG9uZW50KSArICcpJyxcbiAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICB9LCB7XG4gICAgICBrZXk6ICdDb21wb25lbnQnLFxuICAgICAgdmFsdWU6IENvbXBvbmVudCxcbiAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICB9LCB7XG4gICAgICBrZXk6ICdzdHlsZXNoZWV0JyxcbiAgICAgIHZhbHVlOiBzcGVjLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgIH1dKTtcblxuICAgIHJldHVybiBfY2xhc3M7XG4gIH0pKF9TdHlsZWFibGVET01Db21wb25lbnQzWydkZWZhdWx0J10pO1xufVxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC1zdHlsZXNoZWV0L2xpYi9zdHlsZUNvbXBvbmVudC5qc1xuICoqIG1vZHVsZSBpZCA9IDIxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIEBjb3B5cmlnaHQgMjAxNSBQcm9tZXRoZXVzIFJlc2VhcmNoLCBMTENcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZURlY29yYXRlZENsYXNzID0gKGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIGRlc2NyaXB0b3JzLCBpbml0aWFsaXplcnMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBkZXNjcmlwdG9ycy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IGRlc2NyaXB0b3JzW2ldOyB2YXIgZGVjb3JhdG9ycyA9IGRlc2NyaXB0b3IuZGVjb3JhdG9yczsgdmFyIGtleSA9IGRlc2NyaXB0b3Iua2V5OyBkZWxldGUgZGVzY3JpcHRvci5rZXk7IGRlbGV0ZSBkZXNjcmlwdG9yLmRlY29yYXRvcnM7IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoJ3ZhbHVlJyBpbiBkZXNjcmlwdG9yIHx8IGRlc2NyaXB0b3IuaW5pdGlhbGl6ZXIpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBpZiAoZGVjb3JhdG9ycykgeyBmb3IgKHZhciBmID0gMDsgZiA8IGRlY29yYXRvcnMubGVuZ3RoOyBmKyspIHsgdmFyIGRlY29yYXRvciA9IGRlY29yYXRvcnNbZl07IGlmICh0eXBlb2YgZGVjb3JhdG9yID09PSAnZnVuY3Rpb24nKSB7IGRlc2NyaXB0b3IgPSBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIGRlc2NyaXB0b3IpIHx8IGRlc2NyaXB0b3I7IH0gZWxzZSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBkZWNvcmF0b3IgZm9yIG1ldGhvZCAnICsgZGVzY3JpcHRvci5rZXkgKyAnIGlzIG9mIHRoZSBpbnZhbGlkIHR5cGUgJyArIHR5cGVvZiBkZWNvcmF0b3IpOyB9IH0gaWYgKGRlc2NyaXB0b3IuaW5pdGlhbGl6ZXIgIT09IHVuZGVmaW5lZCkgeyBpbml0aWFsaXplcnNba2V5XSA9IGRlc2NyaXB0b3I7IGNvbnRpbnVlOyB9IH0gT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzLCBwcm90b0luaXRpYWxpemVycywgc3RhdGljSW5pdGlhbGl6ZXJzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcywgcHJvdG9Jbml0aWFsaXplcnMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzLCBzdGF0aWNJbml0aWFsaXplcnMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0pKCk7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbmV4cG9ydHMuY3JlYXRlU3R5bGVzaGVldCA9IGNyZWF0ZVN0eWxlc2hlZXQ7XG5leHBvcnRzLmlzVmFsaWRTdHlsZXNoZWV0ID0gaXNWYWxpZFN0eWxlc2hlZXQ7XG5leHBvcnRzLm92ZXJyaWRlU3R5bGVzaGVldCA9IG92ZXJyaWRlU3R5bGVzaGVldDtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbicpOyB9IH1cblxudmFyIF9tZW1vaXplRGVjb3JhdG9yID0gcmVxdWlyZSgnbWVtb2l6ZS1kZWNvcmF0b3InKTtcblxudmFyIF9tZW1vaXplRGVjb3JhdG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX21lbW9pemVEZWNvcmF0b3IpO1xuXG52YXIgX3N0eWxlTG9hZGVyQWRkU3R5bGVzID0gcmVxdWlyZSgnc3R5bGUtbG9hZGVyL2FkZFN0eWxlcycpO1xuXG52YXIgX3N0eWxlTG9hZGVyQWRkU3R5bGVzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3N0eWxlTG9hZGVyQWRkU3R5bGVzKTtcblxudmFyIF9yZWFjdExpYkNTU1Byb3BlcnR5T3BlcmF0aW9ucyA9IHJlcXVpcmUoJ3JlYWN0L2xpYi9DU1NQcm9wZXJ0eU9wZXJhdGlvbnMnKTtcblxudmFyIF9yZWFjdExpYkNTU1Byb3BlcnR5T3BlcmF0aW9uczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdExpYkNTU1Byb3BlcnR5T3BlcmF0aW9ucyk7XG5cbnZhciBfcmVhY3RMaWJEYW5nZXJvdXNTdHlsZVZhbHVlID0gcmVxdWlyZSgncmVhY3QvbGliL2Rhbmdlcm91c1N0eWxlVmFsdWUnKTtcblxudmFyIF9yZWFjdExpYkRhbmdlcm91c1N0eWxlVmFsdWUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3RMaWJEYW5nZXJvdXNTdHlsZVZhbHVlKTtcblxudmFyIF9VdGlscyA9IHJlcXVpcmUoJy4vVXRpbHMnKTtcblxuLyoqXG4gKiBTcGVjaWFsIGtleSB3aGljaCBkZXNpZ25hdGVzIHRoZSBydWxlcyB3aGljaCBzaG91bGQgYmUgYXBwbGllZCBldmVuIGlmIG5vXG4gKiB2YXJpYW50IGlzIGJlaW5nIGFjdGl2ZS5cbiAqL1xudmFyIEJBU0UgPSAnYmFzZSc7XG5cbi8qKlxuICogU3BlY2lhbCBrZXkgd2hpY2ggaXMgdXNlZCB0byBzdG9yZSBjbGFzc05hbWUgaW4gbWFwcGluZy5cbiAqL1xudmFyIENMQVNTTkFNRSA9ICdjbGFzc05hbWUnO1xuXG4vKipcbiAqIFN0eWxlcyB3ZSB3YW50IHRvIGJlIGFkZGVkIHRvIGV2ZXJ5IENTUyBjbGFzcy5cbiAqL1xudmFyIERFRkFVTFRfU1RZTEUgPSB7XG4gIGJveFNpemluZzogJ2JvcmRlci1ib3gnXG59O1xuXG4vKipcbiAqIFZhcmlhbnQgbmFtZXMgd2Ugd2FudCB0byBzZWUgY29tcGlsZWQgYXMgQ1NTIHBzZXVkbyBjbGFzc2VzLlxuICovXG52YXIgU1VQUE9SVEVEX1BTRVVET19DTEFTU0VTID0ge1xuICBmb2N1czogdHJ1ZSxcbiAgaG92ZXI6IHRydWUsXG4gIGFjdGl2ZTogdHJ1ZSxcbiAgY2hlY2tlZDogdHJ1ZSxcbiAgJ2RlZmF1bHQnOiB0cnVlLFxuICBkaXNhYmxlZDogdHJ1ZSxcbiAgZW1wdHk6IHRydWUsXG4gIGVuYWJsZWQ6IHRydWUsXG4gIGZpcnN0Q2hpbGQ6IHRydWUsXG4gIGZ1bGxzY3JlZW46IHRydWUsXG4gIGluZGV0ZXJtaW5hdGU6IHRydWUsXG4gIGludmFsaWQ6IHRydWUsXG4gIGxhc3RDaGlsZDogdHJ1ZSxcbiAgbGVmdDogdHJ1ZSxcbiAgbGluazogdHJ1ZSxcbiAgb25seUNoaWxkOiB0cnVlLFxuICBvcHRpb25hbDogdHJ1ZSxcbiAgcmVxdWlyZWQ6IHRydWUsXG4gIHJpZ2h0OiB0cnVlLFxuICByb290OiB0cnVlLFxuICBzY29wZTogdHJ1ZSxcbiAgdGFyZ2V0OiB0cnVlLFxuICB2YWxpZDogdHJ1ZSxcbiAgdmlzaXRlZDogdHJ1ZVxufTtcblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgc3R5bGVzaGVldCBmcm9tIHN0eWxlc2hlZXQgc3BlYy5cbiAqL1xuXG5mdW5jdGlvbiBjcmVhdGVTdHlsZXNoZWV0KHNwZWMpIHtcbiAgdmFyIGlkID0gYXJndW1lbnRzLmxlbmd0aCA8PSAxIHx8IGFyZ3VtZW50c1sxXSA9PT0gdW5kZWZpbmVkID8gJycgOiBhcmd1bWVudHNbMV07XG5cbiAgaWQgPSAoMCwgX1V0aWxzLnVuaXF1ZUlEKShpZCA/ICdTdHlsZV8nICsgaWQgOiAnU3R5bGUnKTtcbiAgcmV0dXJuIG5ldyBET01TdHlsZXNoZWV0KHBhcnNlU3BlY1RvU3R5bGUoc3BlYyksIGlkKTtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBvYmplY3QgaXMgYSB2YWxpZGEgc3R5bGVzaGVldC5cbiAqL1xuXG5mdW5jdGlvbiBpc1ZhbGlkU3R5bGVzaGVldChvYmopIHtcbiAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIERPTVN0eWxlc2hlZXQ7XG59XG5cbi8qKlxuICogUHJvZHVjZSBhIG5ldyBzdHlsZXNoZWV0IGJ5IG92ZXJyaWRpbmcgYW4gZXhpc3Rpbmcgb25lIHdpdGggYSBuZXcgc3R5bGVzaGVldFxuICogc3BlYy5cbiAqL1xuXG5mdW5jdGlvbiBvdmVycmlkZVN0eWxlc2hlZXQoc3R5bGVzaGVldCwgb3ZlcnJpZGUsIGlkKSB7XG4gIG92ZXJyaWRlID0gaXNWYWxpZFN0eWxlc2hlZXQob3ZlcnJpZGUpID8gb3ZlcnJpZGUuc3R5bGUgOiBwYXJzZVNwZWNUb1N0eWxlKG92ZXJyaWRlKTtcbiAgdmFyIHN0eWxlID0gb3ZlcnJpZGVTdHlsZShzdHlsZXNoZWV0LnN0eWxlLCBvdmVycmlkZSk7XG4gIGlkID0gKDAsIF9VdGlscy51bmlxdWVJRCkoaWQgPyAnU3R5bGVfJyArIGlkIDogJ1N0eWxlJyk7XG4gIHJldHVybiBuZXcgRE9NU3R5bGVzaGVldChzdHlsZSwgaWQpO1xufVxuXG5mdW5jdGlvbiBvdmVycmlkZVN0eWxlKHN0eWxlLCBvdmVycmlkZSkge1xuICB2YXIgbmV4dFN0eWxlID0gX2V4dGVuZHMoe30sIHN0eWxlKTtcbiAgZm9yICh2YXIga2V5IGluIG92ZXJyaWRlKSB7XG4gICAgaWYgKCFvdmVycmlkZS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGtleSA9PT0gQkFTRSkge1xuICAgICAgbmV4dFN0eWxlW2tleV0gPSBfZXh0ZW5kcyh7fSwgbmV4dFN0eWxlW2tleV0sIG92ZXJyaWRlW2tleV0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXh0U3R5bGVba2V5XSA9IG92ZXJyaWRlU3R5bGUobmV4dFN0eWxlW2tleV0sIG92ZXJyaWRlW2tleV0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbmV4dFN0eWxlO1xufVxuXG4vKipcbiAqIERPTSBzdHlsZXNoZWV0IGlzIGEgY29sbGVjdGlvbiBvZiBjbGFzc2VzIHdoaWNoIGFyZSBhcHBsaWVkIHRvIGEgc2luZ2xlIERPTVxuICogZWxlbWVudC5cbiAqL1xuXG52YXIgRE9NU3R5bGVzaGVldCA9IChmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIERPTVN0eWxlc2hlZXQoc3R5bGUsIGlkKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIERPTVN0eWxlc2hlZXQpO1xuXG4gICAgdGhpcy5zdHlsZSA9IHN0eWxlO1xuICAgIHRoaXMuaWQgPSBpZDtcblxuICAgIHRoaXMuX3JlZnMgPSAwO1xuICAgIHRoaXMuX3JlbW92ZSA9IG51bGw7XG4gICAgdGhpcy5fZGlzcG9zZVBlcmZvcm0gPSB0aGlzLl9kaXNwb3NlUGVyZm9ybS5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX2Rpc3Bvc2VUaW1lciA9IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogUmVzb2x2ZSB2YXJpYW50IHRvIENTUyBjbGFzcyBuYW1lLlxuICAgKi9cblxuICBfY3JlYXRlRGVjb3JhdGVkQ2xhc3MoRE9NU3R5bGVzaGVldCwgW3tcbiAgICBrZXk6ICdhc0NsYXNzTmFtZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFzQ2xhc3NOYW1lKCkge1xuICAgICAgdmFyIHZhcmlhbnQgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1swXTtcblxuICAgICAgcmV0dXJuIHJlc29sdmVWYXJpYW50VG9DbGFzc05hbWUodGhpcy5tYXBwaW5nLCB2YXJpYW50KS5qb2luKCcgJyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndXNlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXNlKCkge1xuICAgICAgdGhpcy5fcmVmcyA9IHRoaXMuX3JlZnMgKyAxO1xuICAgICAgaWYgKHRoaXMuX2Rpc3Bvc2VUaW1lciAhPT0gbnVsbCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fZGlzcG9zZVRpbWVyKTtcbiAgICAgICAgdGhpcy5fZGlzcG9zZVRpbWVyID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9yZW1vdmUgPT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5fcmVtb3ZlID0gKDAsIF9zdHlsZUxvYWRlckFkZFN0eWxlczJbJ2RlZmF1bHQnXSkodGhpcy5jc3MpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZGlzcG9zZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XG4gICAgICB0aGlzLl9yZWZzID0gdGhpcy5fcmVmcyAtIDE7XG4gICAgICBpZiAodGhpcy5fZGlzcG9zZVRpbWVyID09PSBudWxsKSB7XG4gICAgICAgIHRoaXMuX2Rpc3Bvc2VUaW1lciA9IHNldFRpbWVvdXQodGhpcy5fZGlzcG9zZVBlcmZvcm0sIDApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnX2Rpc3Bvc2VQZXJmb3JtJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2Rpc3Bvc2VQZXJmb3JtKCkge1xuICAgICAgaWYgKHRoaXMuX3JlZnMgPCAxKSB7XG4gICAgICAgIHRoaXMuX3JlbW92ZSgpO1xuICAgICAgICB0aGlzLl9yZW1vdmUgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ19jb21waWxlZCcsXG4gICAgZGVjb3JhdG9yczogW19tZW1vaXplRGVjb3JhdG9yMlsnZGVmYXVsdCddXSxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBjb21waWxlU3R5bGUodGhpcy5zdHlsZSwgdGhpcy5pZCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnY3NzJyxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBbW3RoaXMuaWQsIHRoaXMuX2NvbXBpbGVkLmNzcy5qb2luKCdcXG4nKV1dO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ21hcHBpbmcnLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2NvbXBpbGVkLm1hcHBpbmc7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIERPTVN0eWxlc2hlZXQ7XG59KSgpO1xuXG5mdW5jdGlvbiByZXNvbHZlVmFyaWFudFRvQ2xhc3NOYW1lKG1hcHBpbmcsIHZhcmlhbnQpIHtcbiAgdmFyIGNsYXNzTGlzdCA9IFtdO1xuXG4gIGZvciAodmFyIGtleSBpbiBtYXBwaW5nKSB7XG4gICAgaWYgKGtleSA9PT0gQ0xBU1NOQU1FKSB7XG4gICAgICBjbGFzc0xpc3QucHVzaChtYXBwaW5nW2tleV0pO1xuICAgIH0gZWxzZSBpZiAodmFyaWFudFtrZXldKSB7XG4gICAgICB2YXIgc3ViQ2xhc3NMaXN0ID0gcmVzb2x2ZVZhcmlhbnRUb0NsYXNzTmFtZShtYXBwaW5nW2tleV0sIHZhcmlhbnQpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdWJDbGFzc0xpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY2xhc3NMaXN0LnB1c2goc3ViQ2xhc3NMaXN0W2ldKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gY2xhc3NMaXN0O1xufVxuXG4vKipcbiAqIFBhcnNlIHN0eWxlIHNwZWMgdG8gc3R5bGUgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBwYXJzZVNwZWNUb1N0eWxlKHNwZWMpIHtcbiAgdmFyIHJvb3QgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDEgfHwgYXJndW1lbnRzWzFdID09PSB1bmRlZmluZWQgPyB0cnVlIDogYXJndW1lbnRzWzFdO1xuXG4gIHZhciBzdHlsZUJhc2UgPSByb290ID8gX2V4dGVuZHMoe30sIERFRkFVTFRfU1RZTEUpIDoge307XG4gIHZhciBzdHlsZSA9IF9kZWZpbmVQcm9wZXJ0eSh7fSwgQkFTRSwgc3R5bGVCYXNlKTtcbiAgZm9yICh2YXIga2V5IGluIHNwZWMpIHtcbiAgICBpZiAoIXNwZWMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHZhciBpdGVtID0gc3BlY1trZXldO1xuICAgIGlmICgoMCwgX1V0aWxzLmlzUGxhaW5PYmplY3QpKGl0ZW0pKSB7XG4gICAgICBzdHlsZVtrZXldID0gcGFyc2VTcGVjVG9TdHlsZShpdGVtLCBmYWxzZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0eWxlQmFzZVtrZXldID0gX3ZhbHVlKGtleSwgaXRlbSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdHlsZTtcbn1cblxuLyoqXG4gKiBDb21waWxlIHN0eWxlIGludG8gQ1NTIHN0cmluZyB3aXRoIG1hcHBpbmcgZnJvbSB2YXJpYW50IG5hbWVzIHRvIENTUyBjbGFzc1xuICogbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGNvbXBpbGVTdHlsZShzdHlsZSwgaWQpIHtcbiAgdmFyIHBhdGggPSBhcmd1bWVudHMubGVuZ3RoIDw9IDIgfHwgYXJndW1lbnRzWzJdID09PSB1bmRlZmluZWQgPyBbXSA6IGFyZ3VtZW50c1syXTtcbiAgdmFyIHZhcmlhbnQgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDMgfHwgYXJndW1lbnRzWzNdID09PSB1bmRlZmluZWQgPyBudWxsIDogYXJndW1lbnRzWzNdO1xuXG4gIHZhciBtYXBwaW5nID0ge307XG4gIHZhciBjc3MgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIHN0eWxlKSB7XG4gICAgaWYgKCFzdHlsZS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdmFyIHZhbHVlID0gc3R5bGVba2V5XTtcbiAgICBpZiAoa2V5ID09PSBCQVNFKSB7XG4gICAgICBpZiAodmFyaWFudCAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgY2xhc3NOYW1lID0gX2NsYXNzTmFtZShpZCwgcGF0aCwgdmFyaWFudCk7XG4gICAgICAgIG1hcHBpbmdbdmFyaWFudF0gPSBtYXBwaW5nW3ZhcmlhbnRdIHx8IHt9O1xuICAgICAgICBtYXBwaW5nW3ZhcmlhbnRdW0NMQVNTTkFNRV0gPSBjbGFzc05hbWU7XG5cbiAgICAgICAgaWYgKFNVUFBPUlRFRF9QU0VVRE9fQ0xBU1NFU1t2YXJpYW50XSkge1xuICAgICAgICAgIHZhciBwc2V1ZG9DbGFzc05hbWUgPSBfY2xhc3NOYW1lKGlkLCBwYXRoLCB2YXJpYW50LCB0cnVlKTtcbiAgICAgICAgICBjc3MucHVzaChjb21waWxlQ2xhc3MoJy4nICsgY2xhc3NOYW1lICsgJywgLicgKyBwc2V1ZG9DbGFzc05hbWUsIHZhbHVlKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3NzLnB1c2goY29tcGlsZUNsYXNzKCcuJyArIGNsYXNzTmFtZSwgdmFsdWUpKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3NzLnB1c2goY29tcGlsZUNsYXNzKCcuJyArIGlkLCB2YWx1ZSkpO1xuICAgICAgICBtYXBwaW5nW0NMQVNTTkFNRV0gPSBpZDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG5leHRQYXRoID0gdmFyaWFudCA9PT0gbnVsbCA/IHBhdGggOiBwYXRoLmNvbmNhdCh2YXJpYW50KTtcbiAgICAgIHZhciBzdWJSZXN1bHQgPSBjb21waWxlU3R5bGUodmFsdWUsIGlkLCBuZXh0UGF0aCwga2V5KTtcbiAgICAgIG1hcHBpbmdba2V5XSA9IHN1YlJlc3VsdC5tYXBwaW5nO1xuICAgICAgY3NzID0gY3NzLmNvbmNhdChzdWJSZXN1bHQuY3NzKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHsgY3NzOiBjc3MsIG1hcHBpbmc6IG1hcHBpbmcgfTtcbn1cblxuLyoqXG4gKiBDb21waWxlIGNsYXNzIG5hbWUgYW5kIHJ1bGUgc2V0IGludG8gQ1NTIGNsYXNzLlxuICovXG5mdW5jdGlvbiBjb21waWxlQ2xhc3MoY2xhc3NOYW1lLCBydWxlU2V0KSB7XG4gIHZhciBjc3MgPSBjbGFzc05hbWUgKyAnIHsgJyArIF9yZWFjdExpYkNTU1Byb3BlcnR5T3BlcmF0aW9uczJbJ2RlZmF1bHQnXS5jcmVhdGVNYXJrdXBGb3JTdHlsZXMocnVsZVNldCkgKyAnIH0nO1xuICByZXR1cm4gY3NzO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIENTUyBjbGFzcyBuYW1lLlxuICovXG5mdW5jdGlvbiBfY2xhc3NOYW1lKGlkLCBwYXRoLCB2YXJpYW50KSB7XG4gIHZhciBhc1BzZXVkbyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMyB8fCBhcmd1bWVudHNbM10gPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogYXJndW1lbnRzWzNdO1xuXG4gIHZhciBjbGFzc05hbWUgPSAnJyArIGlkO1xuICBpZiAocGF0aC5sZW5ndGggPiAwKSB7XG4gICAgY2xhc3NOYW1lID0gY2xhc3NOYW1lICsgKCctLScgKyBwYXRoLmpvaW4oJy0tJykpO1xuICB9XG4gIGlmICh2YXJpYW50KSB7XG4gICAgaWYgKGFzUHNldWRvKSB7XG4gICAgICBjbGFzc05hbWUgPSBjbGFzc05hbWUgKyAoJzonICsgKDAsIF9VdGlscy50b0Rhc2hDYXNlKSh2YXJpYW50KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNsYXNzTmFtZSA9IGNsYXNzTmFtZSArICgnLS0nICsgdmFyaWFudCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBjbGFzc05hbWU7XG59XG5cbi8qKlxuICogUHJvY2VzcyBydWxlU2V0IHZhbHVlLlxuICovXG5mdW5jdGlvbiBfdmFsdWUoa2V5LCB2YWx1ZSkge1xuICBpZiAoKDAsIF9VdGlscy5pc0FycmF5KSh2YWx1ZSkgJiYgdmFsdWUubGVuZ3RoID4gMCkge1xuICAgIHZhciByZXN0ID0gdmFsdWUuc2xpY2UoMSkubWFwKGZ1bmN0aW9uICh2KSB7XG4gICAgICByZXR1cm4ga2V5ICsgJzonICsgKDAsIF9yZWFjdExpYkRhbmdlcm91c1N0eWxlVmFsdWUyWydkZWZhdWx0J10pKGtleSwgdik7XG4gICAgfSk7XG4gICAgdmFsdWUgPSBbKDAsIF9yZWFjdExpYkRhbmdlcm91c1N0eWxlVmFsdWUyWydkZWZhdWx0J10pKGtleSwgdmFsdWVbMF0pXS5jb25jYXQocmVzdCkuam9pbignOycpO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0LXN0eWxlc2hlZXQvbGliL0RPTVN0eWxlc2hlZXQuanNcbiAqKiBtb2R1bGUgaWQgPSAyMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IG1lbW9pemU7XG4vKipcbiAqIEBjb3B5cmlnaHQgMjAxNSwgQW5kcmV5IFBvcHAgPDhtYXlkYXlAZ21haWwuY29tPlxuICovXG5cbnZhciBTRU5USU5FTCA9IHt9O1xuXG5mdW5jdGlvbiBtZW1vaXplKHRhcmdldCwgbmFtZSwgZGVzY3JpcHRvcikge1xuICBpZiAodHlwZW9mIGRlc2NyaXB0b3IudmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gX21lbW9pemVNZXRob2QodGFyZ2V0LCBuYW1lLCBkZXNjcmlwdG9yKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZGVzY3JpcHRvci5nZXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gX21lbW9pemVHZXR0ZXIodGFyZ2V0LCBuYW1lLCBkZXNjcmlwdG9yKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0BtZW1vaXplIGRlY29yYXRvciBjYW4gYmUgYXBwbGllZCB0byBtZXRob2RzIG9yIGdldHRlcnMsIGdvdCAnICsgU3RyaW5nKGRlc2NyaXB0b3IudmFsdWUpICsgJyBpbnN0ZWFkJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gX21lbW9pemVHZXR0ZXIodGFyZ2V0LCBuYW1lLCBkZXNjcmlwdG9yKSB7XG4gIHZhciBtZW1vaXplZE5hbWUgPSAnX21lbW9pemVkXycgKyBuYW1lO1xuICB2YXIgZ2V0ID0gZGVzY3JpcHRvci5nZXQ7XG4gIHRhcmdldFttZW1vaXplZE5hbWVdID0gU0VOVElORUw7XG4gIHJldHVybiBfZXh0ZW5kcyh7fSwgZGVzY3JpcHRvciwge1xuICAgIGdldDogKGZ1bmN0aW9uIChfZ2V0KSB7XG4gICAgICBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBfZ2V0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIGdldC50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9nZXQudG9TdHJpbmcoKTtcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBnZXQ7XG4gICAgfSkoZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHRoaXNbbWVtb2l6ZWROYW1lXSA9PT0gU0VOVElORUwpIHtcbiAgICAgICAgdGhpc1ttZW1vaXplZE5hbWVdID0gZ2V0LmNhbGwodGhpcyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpc1ttZW1vaXplZE5hbWVdO1xuICAgIH0pXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBfbWVtb2l6ZU1ldGhvZCh0YXJnZXQsIG5hbWUsIGRlc2NyaXB0b3IpIHtcbiAgaWYgKGRlc2NyaXB0b3IudmFsdWUubGVuZ3RoID4gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignQG1lbW9pemUgZGVjb3JhdG9yIGNhbiBvbmx5IGJlIGFwcGxpZWQgdG8gbWV0aG9kcyBvZiB6ZXJvIGFyZ3VtZW50cycpO1xuICB9XG4gIHZhciBtZW1vaXplZE5hbWUgPSAnX21lbW9pemVkXycgKyBuYW1lO1xuICB2YXIgdmFsdWUgPSBkZXNjcmlwdG9yLnZhbHVlO1xuICB0YXJnZXRbbWVtb2l6ZWROYW1lXSA9IFNFTlRJTkVMO1xuICByZXR1cm4gX2V4dGVuZHMoe30sIGRlc2NyaXB0b3IsIHtcbiAgICB2YWx1ZTogKGZ1bmN0aW9uIChfdmFsdWUpIHtcbiAgICAgIGZ1bmN0aW9uIHZhbHVlKCkge1xuICAgICAgICByZXR1cm4gX3ZhbHVlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHZhbHVlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3ZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSkoZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHRoaXNbbWVtb2l6ZWROYW1lXSA9PT0gU0VOVElORUwpIHtcbiAgICAgICAgdGhpc1ttZW1vaXplZE5hbWVdID0gdmFsdWUuY2FsbCh0aGlzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzW21lbW9pemVkTmFtZV07XG4gICAgfSlcbiAgfSk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L21lbW9pemUtZGVjb3JhdG9yL2xpYi9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDIzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKlxyXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXHJcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxyXG4qL1xyXG52YXIgc3R5bGVzSW5Eb20gPSB7fSxcclxuXHRtZW1vaXplID0gZnVuY3Rpb24oZm4pIHtcclxuXHRcdHZhciBtZW1vO1xyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0aWYgKHR5cGVvZiBtZW1vID09PSBcInVuZGVmaW5lZFwiKSBtZW1vID0gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuXHRcdFx0cmV0dXJuIG1lbW87XHJcblx0XHR9O1xyXG5cdH0sXHJcblx0aXNPbGRJRSA9IG1lbW9pemUoZnVuY3Rpb24oKSB7XHJcblx0XHRyZXR1cm4gL21zaWUgWzYtOV1cXGIvLnRlc3Qod2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKSk7XHJcblx0fSksXHJcblx0Z2V0SGVhZEVsZW1lbnQgPSBtZW1vaXplKGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiBkb2N1bWVudC5oZWFkIHx8IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiaGVhZFwiKVswXTtcclxuXHR9KSxcclxuXHRzaW5nbGV0b25FbGVtZW50ID0gbnVsbCxcclxuXHRzaW5nbGV0b25Db3VudGVyID0gMDtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obGlzdCwgb3B0aW9ucykge1xyXG5cdGlmKHR5cGVvZiBERUJVRyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBERUJVRykge1xyXG5cdFx0aWYodHlwZW9mIGRvY3VtZW50ICE9PSBcIm9iamVjdFwiKSB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgc3R5bGUtbG9hZGVyIGNhbm5vdCBiZSB1c2VkIGluIGEgbm9uLWJyb3dzZXIgZW52aXJvbm1lbnRcIik7XHJcblx0fVxyXG5cclxuXHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuXHQvLyBGb3JjZSBzaW5nbGUtdGFnIHNvbHV0aW9uIG9uIElFNi05LCB3aGljaCBoYXMgYSBoYXJkIGxpbWl0IG9uIHRoZSAjIG9mIDxzdHlsZT5cclxuXHQvLyB0YWdzIGl0IHdpbGwgYWxsb3cgb24gYSBwYWdlXHJcblx0aWYgKHR5cGVvZiBvcHRpb25zLnNpbmdsZXRvbiA9PT0gXCJ1bmRlZmluZWRcIikgb3B0aW9ucy5zaW5nbGV0b24gPSBpc09sZElFKCk7XHJcblxyXG5cdHZhciBzdHlsZXMgPSBsaXN0VG9TdHlsZXMobGlzdCk7XHJcblx0YWRkU3R5bGVzVG9Eb20oc3R5bGVzLCBvcHRpb25zKTtcclxuXHJcblx0cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZShuZXdMaXN0KSB7XHJcblx0XHR2YXIgbWF5UmVtb3ZlID0gW107XHJcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdHZhciBpdGVtID0gc3R5bGVzW2ldO1xyXG5cdFx0XHR2YXIgZG9tU3R5bGUgPSBzdHlsZXNJbkRvbVtpdGVtLmlkXTtcclxuXHRcdFx0ZG9tU3R5bGUucmVmcy0tO1xyXG5cdFx0XHRtYXlSZW1vdmUucHVzaChkb21TdHlsZSk7XHJcblx0XHR9XHJcblx0XHRpZihuZXdMaXN0KSB7XHJcblx0XHRcdHZhciBuZXdTdHlsZXMgPSBsaXN0VG9TdHlsZXMobmV3TGlzdCk7XHJcblx0XHRcdGFkZFN0eWxlc1RvRG9tKG5ld1N0eWxlcywgb3B0aW9ucyk7XHJcblx0XHR9XHJcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgbWF5UmVtb3ZlLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdHZhciBkb21TdHlsZSA9IG1heVJlbW92ZVtpXTtcclxuXHRcdFx0aWYoZG9tU3R5bGUucmVmcyA9PT0gMCkge1xyXG5cdFx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKylcclxuXHRcdFx0XHRcdGRvbVN0eWxlLnBhcnRzW2pdKCk7XHJcblx0XHRcdFx0ZGVsZXRlIHN0eWxlc0luRG9tW2RvbVN0eWxlLmlkXTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFkZFN0eWxlc1RvRG9tKHN0eWxlcywgb3B0aW9ucykge1xyXG5cdGZvcih2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcclxuXHRcdHZhciBpdGVtID0gc3R5bGVzW2ldO1xyXG5cdFx0dmFyIGRvbVN0eWxlID0gc3R5bGVzSW5Eb21baXRlbS5pZF07XHJcblx0XHRpZihkb21TdHlsZSkge1xyXG5cdFx0XHRkb21TdHlsZS5yZWZzKys7XHJcblx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKykge1xyXG5cdFx0XHRcdGRvbVN0eWxlLnBhcnRzW2pdKGl0ZW0ucGFydHNbal0pO1xyXG5cdFx0XHR9XHJcblx0XHRcdGZvcig7IGogPCBpdGVtLnBhcnRzLmxlbmd0aDsgaisrKSB7XHJcblx0XHRcdFx0ZG9tU3R5bGUucGFydHMucHVzaChhZGRTdHlsZShpdGVtLnBhcnRzW2pdLCBvcHRpb25zKSk7XHJcblx0XHRcdH1cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHZhciBwYXJ0cyA9IFtdO1xyXG5cdFx0XHRmb3IodmFyIGogPSAwOyBqIDwgaXRlbS5wYXJ0cy5sZW5ndGg7IGorKykge1xyXG5cdFx0XHRcdHBhcnRzLnB1c2goYWRkU3R5bGUoaXRlbS5wYXJ0c1tqXSwgb3B0aW9ucykpO1xyXG5cdFx0XHR9XHJcblx0XHRcdHN0eWxlc0luRG9tW2l0ZW0uaWRdID0ge2lkOiBpdGVtLmlkLCByZWZzOiAxLCBwYXJ0czogcGFydHN9O1xyXG5cdFx0fVxyXG5cdH1cclxufVxyXG5cclxuZnVuY3Rpb24gbGlzdFRvU3R5bGVzKGxpc3QpIHtcclxuXHR2YXIgc3R5bGVzID0gW107XHJcblx0dmFyIG5ld1N0eWxlcyA9IHt9O1xyXG5cdGZvcih2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XHJcblx0XHR2YXIgaXRlbSA9IGxpc3RbaV07XHJcblx0XHR2YXIgaWQgPSBpdGVtWzBdO1xyXG5cdFx0dmFyIGNzcyA9IGl0ZW1bMV07XHJcblx0XHR2YXIgbWVkaWEgPSBpdGVtWzJdO1xyXG5cdFx0dmFyIHNvdXJjZU1hcCA9IGl0ZW1bM107XHJcblx0XHR2YXIgcGFydCA9IHtjc3M6IGNzcywgbWVkaWE6IG1lZGlhLCBzb3VyY2VNYXA6IHNvdXJjZU1hcH07XHJcblx0XHRpZighbmV3U3R5bGVzW2lkXSlcclxuXHRcdFx0c3R5bGVzLnB1c2gobmV3U3R5bGVzW2lkXSA9IHtpZDogaWQsIHBhcnRzOiBbcGFydF19KTtcclxuXHRcdGVsc2VcclxuXHRcdFx0bmV3U3R5bGVzW2lkXS5wYXJ0cy5wdXNoKHBhcnQpO1xyXG5cdH1cclxuXHRyZXR1cm4gc3R5bGVzO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjcmVhdGVTdHlsZUVsZW1lbnQoKSB7XHJcblx0dmFyIHN0eWxlRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcclxuXHR2YXIgaGVhZCA9IGdldEhlYWRFbGVtZW50KCk7XHJcblx0c3R5bGVFbGVtZW50LnR5cGUgPSBcInRleHQvY3NzXCI7XHJcblx0aGVhZC5hcHBlbmRDaGlsZChzdHlsZUVsZW1lbnQpO1xyXG5cdHJldHVybiBzdHlsZUVsZW1lbnQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZUxpbmtFbGVtZW50KCkge1xyXG5cdHZhciBsaW5rRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJsaW5rXCIpO1xyXG5cdHZhciBoZWFkID0gZ2V0SGVhZEVsZW1lbnQoKTtcclxuXHRsaW5rRWxlbWVudC5yZWwgPSBcInN0eWxlc2hlZXRcIjtcclxuXHRoZWFkLmFwcGVuZENoaWxkKGxpbmtFbGVtZW50KTtcclxuXHRyZXR1cm4gbGlua0VsZW1lbnQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFkZFN0eWxlKG9iaiwgb3B0aW9ucykge1xyXG5cdHZhciBzdHlsZUVsZW1lbnQsIHVwZGF0ZSwgcmVtb3ZlO1xyXG5cclxuXHRpZiAob3B0aW9ucy5zaW5nbGV0b24pIHtcclxuXHRcdHZhciBzdHlsZUluZGV4ID0gc2luZ2xldG9uQ291bnRlcisrO1xyXG5cdFx0c3R5bGVFbGVtZW50ID0gc2luZ2xldG9uRWxlbWVudCB8fCAoc2luZ2xldG9uRWxlbWVudCA9IGNyZWF0ZVN0eWxlRWxlbWVudCgpKTtcclxuXHRcdHVwZGF0ZSA9IGFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLCBzdHlsZUVsZW1lbnQsIHN0eWxlSW5kZXgsIGZhbHNlKTtcclxuXHRcdHJlbW92ZSA9IGFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLCBzdHlsZUVsZW1lbnQsIHN0eWxlSW5kZXgsIHRydWUpO1xyXG5cdH0gZWxzZSBpZihvYmouc291cmNlTWFwICYmXHJcblx0XHR0eXBlb2YgVVJMID09PSBcImZ1bmN0aW9uXCIgJiZcclxuXHRcdHR5cGVvZiBVUkwuY3JlYXRlT2JqZWN0VVJMID09PSBcImZ1bmN0aW9uXCIgJiZcclxuXHRcdHR5cGVvZiBVUkwucmV2b2tlT2JqZWN0VVJMID09PSBcImZ1bmN0aW9uXCIgJiZcclxuXHRcdHR5cGVvZiBCbG9iID09PSBcImZ1bmN0aW9uXCIgJiZcclxuXHRcdHR5cGVvZiBidG9hID09PSBcImZ1bmN0aW9uXCIpIHtcclxuXHRcdHN0eWxlRWxlbWVudCA9IGNyZWF0ZUxpbmtFbGVtZW50KCk7XHJcblx0XHR1cGRhdGUgPSB1cGRhdGVMaW5rLmJpbmQobnVsbCwgc3R5bGVFbGVtZW50KTtcclxuXHRcdHJlbW92ZSA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRzdHlsZUVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzdHlsZUVsZW1lbnQpO1xyXG5cdFx0XHRpZihzdHlsZUVsZW1lbnQuaHJlZilcclxuXHRcdFx0XHRVUkwucmV2b2tlT2JqZWN0VVJMKHN0eWxlRWxlbWVudC5ocmVmKTtcclxuXHRcdH07XHJcblx0fSBlbHNlIHtcclxuXHRcdHN0eWxlRWxlbWVudCA9IGNyZWF0ZVN0eWxlRWxlbWVudCgpO1xyXG5cdFx0dXBkYXRlID0gYXBwbHlUb1RhZy5iaW5kKG51bGwsIHN0eWxlRWxlbWVudCk7XHJcblx0XHRyZW1vdmUgPSBmdW5jdGlvbigpIHtcclxuXHRcdFx0c3R5bGVFbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3R5bGVFbGVtZW50KTtcclxuXHRcdH07XHJcblx0fVxyXG5cclxuXHR1cGRhdGUob2JqKTtcclxuXHJcblx0cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZVN0eWxlKG5ld09iaikge1xyXG5cdFx0aWYobmV3T2JqKSB7XHJcblx0XHRcdGlmKG5ld09iai5jc3MgPT09IG9iai5jc3MgJiYgbmV3T2JqLm1lZGlhID09PSBvYmoubWVkaWEgJiYgbmV3T2JqLnNvdXJjZU1hcCA9PT0gb2JqLnNvdXJjZU1hcClcclxuXHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdHVwZGF0ZShvYmogPSBuZXdPYmopO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0cmVtb3ZlKCk7XHJcblx0XHR9XHJcblx0fTtcclxufVxyXG5cclxudmFyIHJlcGxhY2VUZXh0ID0gKGZ1bmN0aW9uICgpIHtcclxuXHR2YXIgdGV4dFN0b3JlID0gW107XHJcblxyXG5cdHJldHVybiBmdW5jdGlvbiAoaW5kZXgsIHJlcGxhY2VtZW50KSB7XHJcblx0XHR0ZXh0U3RvcmVbaW5kZXhdID0gcmVwbGFjZW1lbnQ7XHJcblx0XHRyZXR1cm4gdGV4dFN0b3JlLmZpbHRlcihCb29sZWFuKS5qb2luKCdcXG4nKTtcclxuXHR9O1xyXG59KSgpO1xyXG5cclxuZnVuY3Rpb24gYXBwbHlUb1NpbmdsZXRvblRhZyhzdHlsZUVsZW1lbnQsIGluZGV4LCByZW1vdmUsIG9iaikge1xyXG5cdHZhciBjc3MgPSByZW1vdmUgPyBcIlwiIDogb2JqLmNzcztcclxuXHJcblx0aWYgKHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0KSB7XHJcblx0XHRzdHlsZUVsZW1lbnQuc3R5bGVTaGVldC5jc3NUZXh0ID0gcmVwbGFjZVRleHQoaW5kZXgsIGNzcyk7XHJcblx0fSBlbHNlIHtcclxuXHRcdHZhciBjc3NOb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKTtcclxuXHRcdHZhciBjaGlsZE5vZGVzID0gc3R5bGVFbGVtZW50LmNoaWxkTm9kZXM7XHJcblx0XHRpZiAoY2hpbGROb2Rlc1tpbmRleF0pIHN0eWxlRWxlbWVudC5yZW1vdmVDaGlsZChjaGlsZE5vZGVzW2luZGV4XSk7XHJcblx0XHRpZiAoY2hpbGROb2Rlcy5sZW5ndGgpIHtcclxuXHRcdFx0c3R5bGVFbGVtZW50Lmluc2VydEJlZm9yZShjc3NOb2RlLCBjaGlsZE5vZGVzW2luZGV4XSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRzdHlsZUVsZW1lbnQuYXBwZW5kQ2hpbGQoY3NzTm9kZSk7XHJcblx0XHR9XHJcblx0fVxyXG59XHJcblxyXG5mdW5jdGlvbiBhcHBseVRvVGFnKHN0eWxlRWxlbWVudCwgb2JqKSB7XHJcblx0dmFyIGNzcyA9IG9iai5jc3M7XHJcblx0dmFyIG1lZGlhID0gb2JqLm1lZGlhO1xyXG5cdHZhciBzb3VyY2VNYXAgPSBvYmouc291cmNlTWFwO1xyXG5cclxuXHRpZihtZWRpYSkge1xyXG5cdFx0c3R5bGVFbGVtZW50LnNldEF0dHJpYnV0ZShcIm1lZGlhXCIsIG1lZGlhKVxyXG5cdH1cclxuXHJcblx0aWYoc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQpIHtcclxuXHRcdHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0LmNzc1RleHQgPSBjc3M7XHJcblx0fSBlbHNlIHtcclxuXHRcdHdoaWxlKHN0eWxlRWxlbWVudC5maXJzdENoaWxkKSB7XHJcblx0XHRcdHN0eWxlRWxlbWVudC5yZW1vdmVDaGlsZChzdHlsZUVsZW1lbnQuZmlyc3RDaGlsZCk7XHJcblx0XHR9XHJcblx0XHRzdHlsZUVsZW1lbnQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKSk7XHJcblx0fVxyXG59XHJcblxyXG5mdW5jdGlvbiB1cGRhdGVMaW5rKGxpbmtFbGVtZW50LCBvYmopIHtcclxuXHR2YXIgY3NzID0gb2JqLmNzcztcclxuXHR2YXIgbWVkaWEgPSBvYmoubWVkaWE7XHJcblx0dmFyIHNvdXJjZU1hcCA9IG9iai5zb3VyY2VNYXA7XHJcblxyXG5cdGlmKHNvdXJjZU1hcCkge1xyXG5cdFx0Ly8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjY2MDM4NzVcclxuXHRcdGNzcyArPSBcIlxcbi8qIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsXCIgKyBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpICsgXCIgKi9cIjtcclxuXHR9XHJcblxyXG5cdHZhciBibG9iID0gbmV3IEJsb2IoW2Nzc10sIHsgdHlwZTogXCJ0ZXh0L2Nzc1wiIH0pO1xyXG5cclxuXHR2YXIgb2xkU3JjID0gbGlua0VsZW1lbnQuaHJlZjtcclxuXHJcblx0bGlua0VsZW1lbnQuaHJlZiA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XHJcblxyXG5cdGlmKG9sZFNyYylcclxuXHRcdFVSTC5yZXZva2VPYmplY3RVUkwob2xkU3JjKTtcclxufVxyXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9zdHlsZS1sb2FkZXIvYWRkU3R5bGVzLmpzXG4gKiogbW9kdWxlIGlkID0gMjRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBDU1NQcm9wZXJ0eU9wZXJhdGlvbnNcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgQ1NTUHJvcGVydHkgPSByZXF1aXJlKCcuL0NTU1Byb3BlcnR5Jyk7XG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xudmFyIFJlYWN0UGVyZiA9IHJlcXVpcmUoJy4vUmVhY3RQZXJmJyk7XG5cbnZhciBjYW1lbGl6ZVN0eWxlTmFtZSA9IHJlcXVpcmUoJ2ZianMvbGliL2NhbWVsaXplU3R5bGVOYW1lJyk7XG52YXIgZGFuZ2Vyb3VzU3R5bGVWYWx1ZSA9IHJlcXVpcmUoJy4vZGFuZ2Vyb3VzU3R5bGVWYWx1ZScpO1xudmFyIGh5cGhlbmF0ZVN0eWxlTmFtZSA9IHJlcXVpcmUoJ2ZianMvbGliL2h5cGhlbmF0ZVN0eWxlTmFtZScpO1xudmFyIG1lbW9pemVTdHJpbmdPbmx5ID0gcmVxdWlyZSgnZmJqcy9saWIvbWVtb2l6ZVN0cmluZ09ubHknKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG52YXIgcHJvY2Vzc1N0eWxlTmFtZSA9IG1lbW9pemVTdHJpbmdPbmx5KGZ1bmN0aW9uIChzdHlsZU5hbWUpIHtcbiAgcmV0dXJuIGh5cGhlbmF0ZVN0eWxlTmFtZShzdHlsZU5hbWUpO1xufSk7XG5cbnZhciBoYXNTaG9ydGhhbmRQcm9wZXJ0eUJ1ZyA9IGZhbHNlO1xudmFyIHN0eWxlRmxvYXRBY2Nlc3NvciA9ICdjc3NGbG9hdCc7XG5pZiAoRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NKSB7XG4gIHZhciB0ZW1wU3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKS5zdHlsZTtcbiAgdHJ5IHtcbiAgICAvLyBJRTggdGhyb3dzIFwiSW52YWxpZCBhcmd1bWVudC5cIiBpZiByZXNldHRpbmcgc2hvcnRoYW5kIHN0eWxlIHByb3BlcnRpZXMuXG4gICAgdGVtcFN0eWxlLmZvbnQgPSAnJztcbiAgfSBjYXRjaCAoZSkge1xuICAgIGhhc1Nob3J0aGFuZFByb3BlcnR5QnVnID0gdHJ1ZTtcbiAgfVxuICAvLyBJRTggb25seSBzdXBwb3J0cyBhY2Nlc3NpbmcgY3NzRmxvYXQgKHN0YW5kYXJkKSBhcyBzdHlsZUZsb2F0XG4gIGlmIChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUuY3NzRmxvYXQgPT09IHVuZGVmaW5lZCkge1xuICAgIHN0eWxlRmxvYXRBY2Nlc3NvciA9ICdzdHlsZUZsb2F0JztcbiAgfVxufVxuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAvLyAnbXNUcmFuc2Zvcm0nIGlzIGNvcnJlY3QsIGJ1dCB0aGUgb3RoZXIgcHJlZml4ZXMgc2hvdWxkIGJlIGNhcGl0YWxpemVkXG4gIHZhciBiYWRWZW5kb3JlZFN0eWxlTmFtZVBhdHRlcm4gPSAvXig/OndlYmtpdHxtb3p8bylbQS1aXS87XG5cbiAgLy8gc3R5bGUgdmFsdWVzIHNob3VsZG4ndCBjb250YWluIGEgc2VtaWNvbG9uXG4gIHZhciBiYWRTdHlsZVZhbHVlV2l0aFNlbWljb2xvblBhdHRlcm4gPSAvO1xccyokLztcblxuICB2YXIgd2FybmVkU3R5bGVOYW1lcyA9IHt9O1xuICB2YXIgd2FybmVkU3R5bGVWYWx1ZXMgPSB7fTtcblxuICB2YXIgd2Fybkh5cGhlbmF0ZWRTdHlsZU5hbWUgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIGlmICh3YXJuZWRTdHlsZU5hbWVzLmhhc093blByb3BlcnR5KG5hbWUpICYmIHdhcm5lZFN0eWxlTmFtZXNbbmFtZV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3YXJuZWRTdHlsZU5hbWVzW25hbWVdID0gdHJ1ZTtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ1Vuc3VwcG9ydGVkIHN0eWxlIHByb3BlcnR5ICVzLiBEaWQgeW91IG1lYW4gJXM/JywgbmFtZSwgY2FtZWxpemVTdHlsZU5hbWUobmFtZSkpIDogdW5kZWZpbmVkO1xuICB9O1xuXG4gIHZhciB3YXJuQmFkVmVuZG9yZWRTdHlsZU5hbWUgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIGlmICh3YXJuZWRTdHlsZU5hbWVzLmhhc093blByb3BlcnR5KG5hbWUpICYmIHdhcm5lZFN0eWxlTmFtZXNbbmFtZV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3YXJuZWRTdHlsZU5hbWVzW25hbWVdID0gdHJ1ZTtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ1Vuc3VwcG9ydGVkIHZlbmRvci1wcmVmaXhlZCBzdHlsZSBwcm9wZXJ0eSAlcy4gRGlkIHlvdSBtZWFuICVzPycsIG5hbWUsIG5hbWUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBuYW1lLnNsaWNlKDEpKSA6IHVuZGVmaW5lZDtcbiAgfTtcblxuICB2YXIgd2FyblN0eWxlVmFsdWVXaXRoU2VtaWNvbG9uID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKHdhcm5lZFN0eWxlVmFsdWVzLmhhc093blByb3BlcnR5KHZhbHVlKSAmJiB3YXJuZWRTdHlsZVZhbHVlc1t2YWx1ZV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3YXJuZWRTdHlsZVZhbHVlc1t2YWx1ZV0gPSB0cnVlO1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnU3R5bGUgcHJvcGVydHkgdmFsdWVzIHNob3VsZG5cXCd0IGNvbnRhaW4gYSBzZW1pY29sb24uICcgKyAnVHJ5IFwiJXM6ICVzXCIgaW5zdGVhZC4nLCBuYW1lLCB2YWx1ZS5yZXBsYWNlKGJhZFN0eWxlVmFsdWVXaXRoU2VtaWNvbG9uUGF0dGVybiwgJycpKSA6IHVuZGVmaW5lZDtcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgKi9cbiAgdmFyIHdhcm5WYWxpZFN0eWxlID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKG5hbWUuaW5kZXhPZignLScpID4gLTEpIHtcbiAgICAgIHdhcm5IeXBoZW5hdGVkU3R5bGVOYW1lKG5hbWUpO1xuICAgIH0gZWxzZSBpZiAoYmFkVmVuZG9yZWRTdHlsZU5hbWVQYXR0ZXJuLnRlc3QobmFtZSkpIHtcbiAgICAgIHdhcm5CYWRWZW5kb3JlZFN0eWxlTmFtZShuYW1lKTtcbiAgICB9IGVsc2UgaWYgKGJhZFN0eWxlVmFsdWVXaXRoU2VtaWNvbG9uUGF0dGVybi50ZXN0KHZhbHVlKSkge1xuICAgICAgd2FyblN0eWxlVmFsdWVXaXRoU2VtaWNvbG9uKG5hbWUsIHZhbHVlKTtcbiAgICB9XG4gIH07XG59XG5cbi8qKlxuICogT3BlcmF0aW9ucyBmb3IgZGVhbGluZyB3aXRoIENTUyBwcm9wZXJ0aWVzLlxuICovXG52YXIgQ1NTUHJvcGVydHlPcGVyYXRpb25zID0ge1xuXG4gIC8qKlxuICAgKiBTZXJpYWxpemVzIGEgbWFwcGluZyBvZiBzdHlsZSBwcm9wZXJ0aWVzIGZvciB1c2UgYXMgaW5saW5lIHN0eWxlczpcbiAgICpcbiAgICogICA+IGNyZWF0ZU1hcmt1cEZvclN0eWxlcyh7d2lkdGg6ICcyMDBweCcsIGhlaWdodDogMH0pXG4gICAqICAgXCJ3aWR0aDoyMDBweDtoZWlnaHQ6MDtcIlxuICAgKlxuICAgKiBVbmRlZmluZWQgdmFsdWVzIGFyZSBpZ25vcmVkIHNvIHRoYXQgZGVjbGFyYXRpdmUgcHJvZ3JhbW1pbmcgaXMgZWFzaWVyLlxuICAgKiBUaGUgcmVzdWx0IHNob3VsZCBiZSBIVE1MLWVzY2FwZWQgYmVmb3JlIGluc2VydGlvbiBpbnRvIHRoZSBET00uXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBzdHlsZXNcbiAgICogQHJldHVybiB7P3N0cmluZ31cbiAgICovXG4gIGNyZWF0ZU1hcmt1cEZvclN0eWxlczogZnVuY3Rpb24gKHN0eWxlcykge1xuICAgIHZhciBzZXJpYWxpemVkID0gJyc7XG4gICAgZm9yICh2YXIgc3R5bGVOYW1lIGluIHN0eWxlcykge1xuICAgICAgaWYgKCFzdHlsZXMuaGFzT3duUHJvcGVydHkoc3R5bGVOYW1lKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHZhciBzdHlsZVZhbHVlID0gc3R5bGVzW3N0eWxlTmFtZV07XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB3YXJuVmFsaWRTdHlsZShzdHlsZU5hbWUsIHN0eWxlVmFsdWUpO1xuICAgICAgfVxuICAgICAgaWYgKHN0eWxlVmFsdWUgIT0gbnVsbCkge1xuICAgICAgICBzZXJpYWxpemVkICs9IHByb2Nlc3NTdHlsZU5hbWUoc3R5bGVOYW1lKSArICc6JztcbiAgICAgICAgc2VyaWFsaXplZCArPSBkYW5nZXJvdXNTdHlsZVZhbHVlKHN0eWxlTmFtZSwgc3R5bGVWYWx1ZSkgKyAnOyc7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzZXJpYWxpemVkIHx8IG51bGw7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHZhbHVlIGZvciBtdWx0aXBsZSBzdHlsZXMgb24gYSBub2RlLiAgSWYgYSB2YWx1ZSBpcyBzcGVjaWZpZWQgYXNcbiAgICogJycgKGVtcHR5IHN0cmluZyksIHRoZSBjb3JyZXNwb25kaW5nIHN0eWxlIHByb3BlcnR5IHdpbGwgYmUgdW5zZXQuXG4gICAqXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZVxuICAgKiBAcGFyYW0ge29iamVjdH0gc3R5bGVzXG4gICAqL1xuICBzZXRWYWx1ZUZvclN0eWxlczogZnVuY3Rpb24gKG5vZGUsIHN0eWxlcykge1xuICAgIHZhciBzdHlsZSA9IG5vZGUuc3R5bGU7XG4gICAgZm9yICh2YXIgc3R5bGVOYW1lIGluIHN0eWxlcykge1xuICAgICAgaWYgKCFzdHlsZXMuaGFzT3duUHJvcGVydHkoc3R5bGVOYW1lKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHdhcm5WYWxpZFN0eWxlKHN0eWxlTmFtZSwgc3R5bGVzW3N0eWxlTmFtZV0pO1xuICAgICAgfVxuICAgICAgdmFyIHN0eWxlVmFsdWUgPSBkYW5nZXJvdXNTdHlsZVZhbHVlKHN0eWxlTmFtZSwgc3R5bGVzW3N0eWxlTmFtZV0pO1xuICAgICAgaWYgKHN0eWxlTmFtZSA9PT0gJ2Zsb2F0Jykge1xuICAgICAgICBzdHlsZU5hbWUgPSBzdHlsZUZsb2F0QWNjZXNzb3I7XG4gICAgICB9XG4gICAgICBpZiAoc3R5bGVWYWx1ZSkge1xuICAgICAgICBzdHlsZVtzdHlsZU5hbWVdID0gc3R5bGVWYWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBleHBhbnNpb24gPSBoYXNTaG9ydGhhbmRQcm9wZXJ0eUJ1ZyAmJiBDU1NQcm9wZXJ0eS5zaG9ydGhhbmRQcm9wZXJ0eUV4cGFuc2lvbnNbc3R5bGVOYW1lXTtcbiAgICAgICAgaWYgKGV4cGFuc2lvbikge1xuICAgICAgICAgIC8vIFNob3J0aGFuZCBwcm9wZXJ0eSB0aGF0IElFOCB3b24ndCBsaWtlIHVuc2V0dGluZywgc28gdW5zZXQgZWFjaFxuICAgICAgICAgIC8vIGNvbXBvbmVudCB0byBwbGFjYXRlIGl0XG4gICAgICAgICAgZm9yICh2YXIgaW5kaXZpZHVhbFN0eWxlTmFtZSBpbiBleHBhbnNpb24pIHtcbiAgICAgICAgICAgIHN0eWxlW2luZGl2aWR1YWxTdHlsZU5hbWVdID0gJyc7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0eWxlW3N0eWxlTmFtZV0gPSAnJztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG59O1xuXG5SZWFjdFBlcmYubWVhc3VyZU1ldGhvZHMoQ1NTUHJvcGVydHlPcGVyYXRpb25zLCAnQ1NTUHJvcGVydHlPcGVyYXRpb25zJywge1xuICBzZXRWYWx1ZUZvclN0eWxlczogJ3NldFZhbHVlRm9yU3R5bGVzJ1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gQ1NTUHJvcGVydHlPcGVyYXRpb25zO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9DU1NQcm9wZXJ0eU9wZXJhdGlvbnMuanNcbiAqKiBtb2R1bGUgaWQgPSAyNVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIENTU1Byb3BlcnR5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENTUyBwcm9wZXJ0aWVzIHdoaWNoIGFjY2VwdCBudW1iZXJzIGJ1dCBhcmUgbm90IGluIHVuaXRzIG9mIFwicHhcIi5cbiAqL1xudmFyIGlzVW5pdGxlc3NOdW1iZXIgPSB7XG4gIGFuaW1hdGlvbkl0ZXJhdGlvbkNvdW50OiB0cnVlLFxuICBib3hGbGV4OiB0cnVlLFxuICBib3hGbGV4R3JvdXA6IHRydWUsXG4gIGJveE9yZGluYWxHcm91cDogdHJ1ZSxcbiAgY29sdW1uQ291bnQ6IHRydWUsXG4gIGZsZXg6IHRydWUsXG4gIGZsZXhHcm93OiB0cnVlLFxuICBmbGV4UG9zaXRpdmU6IHRydWUsXG4gIGZsZXhTaHJpbms6IHRydWUsXG4gIGZsZXhOZWdhdGl2ZTogdHJ1ZSxcbiAgZmxleE9yZGVyOiB0cnVlLFxuICBmb250V2VpZ2h0OiB0cnVlLFxuICBsaW5lQ2xhbXA6IHRydWUsXG4gIGxpbmVIZWlnaHQ6IHRydWUsXG4gIG9wYWNpdHk6IHRydWUsXG4gIG9yZGVyOiB0cnVlLFxuICBvcnBoYW5zOiB0cnVlLFxuICB0YWJTaXplOiB0cnVlLFxuICB3aWRvd3M6IHRydWUsXG4gIHpJbmRleDogdHJ1ZSxcbiAgem9vbTogdHJ1ZSxcblxuICAvLyBTVkctcmVsYXRlZCBwcm9wZXJ0aWVzXG4gIGZpbGxPcGFjaXR5OiB0cnVlLFxuICBzdG9wT3BhY2l0eTogdHJ1ZSxcbiAgc3Ryb2tlRGFzaG9mZnNldDogdHJ1ZSxcbiAgc3Ryb2tlT3BhY2l0eTogdHJ1ZSxcbiAgc3Ryb2tlV2lkdGg6IHRydWVcbn07XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHByZWZpeCB2ZW5kb3Itc3BlY2lmaWMgcHJlZml4LCBlZzogV2Via2l0XG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IHN0eWxlIG5hbWUsIGVnOiB0cmFuc2l0aW9uRHVyYXRpb25cbiAqIEByZXR1cm4ge3N0cmluZ30gc3R5bGUgbmFtZSBwcmVmaXhlZCB3aXRoIGBwcmVmaXhgLCBwcm9wZXJseSBjYW1lbENhc2VkLCBlZzpcbiAqIFdlYmtpdFRyYW5zaXRpb25EdXJhdGlvblxuICovXG5mdW5jdGlvbiBwcmVmaXhLZXkocHJlZml4LCBrZXkpIHtcbiAgcmV0dXJuIHByZWZpeCArIGtleS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIGtleS5zdWJzdHJpbmcoMSk7XG59XG5cbi8qKlxuICogU3VwcG9ydCBzdHlsZSBuYW1lcyB0aGF0IG1heSBjb21lIHBhc3NlZCBpbiBwcmVmaXhlZCBieSBhZGRpbmcgcGVybXV0YXRpb25zXG4gKiBvZiB2ZW5kb3IgcHJlZml4ZXMuXG4gKi9cbnZhciBwcmVmaXhlcyA9IFsnV2Via2l0JywgJ21zJywgJ01veicsICdPJ107XG5cbi8vIFVzaW5nIE9iamVjdC5rZXlzIGhlcmUsIG9yIGVsc2UgdGhlIHZhbmlsbGEgZm9yLWluIGxvb3AgbWFrZXMgSUU4IGdvIGludG8gYW5cbi8vIGluZmluaXRlIGxvb3AsIGJlY2F1c2UgaXQgaXRlcmF0ZXMgb3ZlciB0aGUgbmV3bHkgYWRkZWQgcHJvcHMgdG9vLlxuT2JqZWN0LmtleXMoaXNVbml0bGVzc051bWJlcikuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICBwcmVmaXhlcy5mb3JFYWNoKGZ1bmN0aW9uIChwcmVmaXgpIHtcbiAgICBpc1VuaXRsZXNzTnVtYmVyW3ByZWZpeEtleShwcmVmaXgsIHByb3ApXSA9IGlzVW5pdGxlc3NOdW1iZXJbcHJvcF07XG4gIH0pO1xufSk7XG5cbi8qKlxuICogTW9zdCBzdHlsZSBwcm9wZXJ0aWVzIGNhbiBiZSB1bnNldCBieSBkb2luZyAuc3R5bGVbcHJvcF0gPSAnJyBidXQgSUU4XG4gKiBkb2Vzbid0IGxpa2UgZG9pbmcgdGhhdCB3aXRoIHNob3J0aGFuZCBwcm9wZXJ0aWVzIHNvIGZvciB0aGUgcHJvcGVydGllcyB0aGF0XG4gKiBJRTggYnJlYWtzIG9uLCB3aGljaCBhcmUgbGlzdGVkIGhlcmUsIHdlIGluc3RlYWQgdW5zZXQgZWFjaCBvZiB0aGVcbiAqIGluZGl2aWR1YWwgcHJvcGVydGllcy4gU2VlIGh0dHA6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzEyMzg1LlxuICogVGhlIDQtdmFsdWUgJ2Nsb2NrJyBwcm9wZXJ0aWVzIGxpa2UgbWFyZ2luLCBwYWRkaW5nLCBib3JkZXItd2lkdGggc2VlbSB0b1xuICogYmVoYXZlIHdpdGhvdXQgYW55IHByb2JsZW1zLiBDdXJpb3VzbHksIGxpc3Qtc3R5bGUgd29ya3MgdG9vIHdpdGhvdXQgYW55XG4gKiBzcGVjaWFsIHByb2RkaW5nLlxuICovXG52YXIgc2hvcnRoYW5kUHJvcGVydHlFeHBhbnNpb25zID0ge1xuICBiYWNrZ3JvdW5kOiB7XG4gICAgYmFja2dyb3VuZEF0dGFjaG1lbnQ6IHRydWUsXG4gICAgYmFja2dyb3VuZENvbG9yOiB0cnVlLFxuICAgIGJhY2tncm91bmRJbWFnZTogdHJ1ZSxcbiAgICBiYWNrZ3JvdW5kUG9zaXRpb25YOiB0cnVlLFxuICAgIGJhY2tncm91bmRQb3NpdGlvblk6IHRydWUsXG4gICAgYmFja2dyb3VuZFJlcGVhdDogdHJ1ZVxuICB9LFxuICBiYWNrZ3JvdW5kUG9zaXRpb246IHtcbiAgICBiYWNrZ3JvdW5kUG9zaXRpb25YOiB0cnVlLFxuICAgIGJhY2tncm91bmRQb3NpdGlvblk6IHRydWVcbiAgfSxcbiAgYm9yZGVyOiB7XG4gICAgYm9yZGVyV2lkdGg6IHRydWUsXG4gICAgYm9yZGVyU3R5bGU6IHRydWUsXG4gICAgYm9yZGVyQ29sb3I6IHRydWVcbiAgfSxcbiAgYm9yZGVyQm90dG9tOiB7XG4gICAgYm9yZGVyQm90dG9tV2lkdGg6IHRydWUsXG4gICAgYm9yZGVyQm90dG9tU3R5bGU6IHRydWUsXG4gICAgYm9yZGVyQm90dG9tQ29sb3I6IHRydWVcbiAgfSxcbiAgYm9yZGVyTGVmdDoge1xuICAgIGJvcmRlckxlZnRXaWR0aDogdHJ1ZSxcbiAgICBib3JkZXJMZWZ0U3R5bGU6IHRydWUsXG4gICAgYm9yZGVyTGVmdENvbG9yOiB0cnVlXG4gIH0sXG4gIGJvcmRlclJpZ2h0OiB7XG4gICAgYm9yZGVyUmlnaHRXaWR0aDogdHJ1ZSxcbiAgICBib3JkZXJSaWdodFN0eWxlOiB0cnVlLFxuICAgIGJvcmRlclJpZ2h0Q29sb3I6IHRydWVcbiAgfSxcbiAgYm9yZGVyVG9wOiB7XG4gICAgYm9yZGVyVG9wV2lkdGg6IHRydWUsXG4gICAgYm9yZGVyVG9wU3R5bGU6IHRydWUsXG4gICAgYm9yZGVyVG9wQ29sb3I6IHRydWVcbiAgfSxcbiAgZm9udDoge1xuICAgIGZvbnRTdHlsZTogdHJ1ZSxcbiAgICBmb250VmFyaWFudDogdHJ1ZSxcbiAgICBmb250V2VpZ2h0OiB0cnVlLFxuICAgIGZvbnRTaXplOiB0cnVlLFxuICAgIGxpbmVIZWlnaHQ6IHRydWUsXG4gICAgZm9udEZhbWlseTogdHJ1ZVxuICB9LFxuICBvdXRsaW5lOiB7XG4gICAgb3V0bGluZVdpZHRoOiB0cnVlLFxuICAgIG91dGxpbmVTdHlsZTogdHJ1ZSxcbiAgICBvdXRsaW5lQ29sb3I6IHRydWVcbiAgfVxufTtcblxudmFyIENTU1Byb3BlcnR5ID0ge1xuICBpc1VuaXRsZXNzTnVtYmVyOiBpc1VuaXRsZXNzTnVtYmVyLFxuICBzaG9ydGhhbmRQcm9wZXJ0eUV4cGFuc2lvbnM6IHNob3J0aGFuZFByb3BlcnR5RXhwYW5zaW9uc1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDU1NQcm9wZXJ0eTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvQ1NTUHJvcGVydHkuanNcbiAqKiBtb2R1bGUgaWQgPSAyNlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIEV4ZWN1dGlvbkVudmlyb25tZW50XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgY2FuVXNlRE9NID0gISEodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmRvY3VtZW50ICYmIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KTtcblxuLyoqXG4gKiBTaW1wbGUsIGxpZ2h0d2VpZ2h0IG1vZHVsZSBhc3Npc3Rpbmcgd2l0aCB0aGUgZGV0ZWN0aW9uIGFuZCBjb250ZXh0IG9mXG4gKiBXb3JrZXIuIEhlbHBzIGF2b2lkIGNpcmN1bGFyIGRlcGVuZGVuY2llcyBhbmQgYWxsb3dzIGNvZGUgdG8gcmVhc29uIGFib3V0XG4gKiB3aGV0aGVyIG9yIG5vdCB0aGV5IGFyZSBpbiBhIFdvcmtlciwgZXZlbiBpZiB0aGV5IG5ldmVyIGluY2x1ZGUgdGhlIG1haW5cbiAqIGBSZWFjdFdvcmtlcmAgZGVwZW5kZW5jeS5cbiAqL1xudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0ge1xuXG4gIGNhblVzZURPTTogY2FuVXNlRE9NLFxuXG4gIGNhblVzZVdvcmtlcnM6IHR5cGVvZiBXb3JrZXIgIT09ICd1bmRlZmluZWQnLFxuXG4gIGNhblVzZUV2ZW50TGlzdGVuZXJzOiBjYW5Vc2VET00gJiYgISEod2luZG93LmFkZEV2ZW50TGlzdGVuZXIgfHwgd2luZG93LmF0dGFjaEV2ZW50KSxcblxuICBjYW5Vc2VWaWV3cG9ydDogY2FuVXNlRE9NICYmICEhd2luZG93LnNjcmVlbixcblxuICBpc0luV29ya2VyOiAhY2FuVXNlRE9NIC8vIEZvciBub3csIHRoaXMgaXMgdHJ1ZSAtIG1pZ2h0IGNoYW5nZSBpbiB0aGUgZnV0dXJlLlxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV4ZWN1dGlvbkVudmlyb25tZW50O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50LmpzXG4gKiogbW9kdWxlIGlkID0gMjdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdFBlcmZcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFJlYWN0UGVyZiBpcyBhIGdlbmVyYWwgQU9QIHN5c3RlbSBkZXNpZ25lZCB0byBtZWFzdXJlIHBlcmZvcm1hbmNlLiBUaGlzXG4gKiBtb2R1bGUgb25seSBoYXMgdGhlIGhvb2tzOiBzZWUgUmVhY3REZWZhdWx0UGVyZiBmb3IgdGhlIGFuYWx5c2lzIHRvb2wuXG4gKi9cbnZhciBSZWFjdFBlcmYgPSB7XG4gIC8qKlxuICAgKiBCb29sZWFuIHRvIGVuYWJsZS9kaXNhYmxlIG1lYXN1cmVtZW50LiBTZXQgdG8gZmFsc2UgYnkgZGVmYXVsdCB0byBwcmV2ZW50XG4gICAqIGFjY2lkZW50YWwgbG9nZ2luZyBhbmQgcGVyZiBsb3NzLlxuICAgKi9cbiAgZW5hYmxlTWVhc3VyZTogZmFsc2UsXG5cbiAgLyoqXG4gICAqIEhvbGRzIG9udG8gdGhlIG1lYXN1cmUgZnVuY3Rpb24gaW4gdXNlLiBCeSBkZWZhdWx0LCBkb24ndCBtZWFzdXJlXG4gICAqIGFueXRoaW5nLCBidXQgd2UnbGwgb3ZlcnJpZGUgdGhpcyBpZiB3ZSBpbmplY3QgYSBtZWFzdXJlIGZ1bmN0aW9uLlxuICAgKi9cbiAgc3RvcmVkTWVhc3VyZTogX25vTWVhc3VyZSxcblxuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IG9iamVjdFxuICAgKiBAcGFyYW0ge3N0cmluZ30gb2JqZWN0TmFtZVxuICAgKiBAcGFyYW0ge29iamVjdDxzdHJpbmc+fSBtZXRob2ROYW1lc1xuICAgKi9cbiAgbWVhc3VyZU1ldGhvZHM6IGZ1bmN0aW9uIChvYmplY3QsIG9iamVjdE5hbWUsIG1ldGhvZE5hbWVzKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGZvciAodmFyIGtleSBpbiBtZXRob2ROYW1lcykge1xuICAgICAgICBpZiAoIW1ldGhvZE5hbWVzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBvYmplY3Rba2V5XSA9IFJlYWN0UGVyZi5tZWFzdXJlKG9iamVjdE5hbWUsIG1ldGhvZE5hbWVzW2tleV0sIG9iamVjdFtrZXldKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFVzZSB0aGlzIHRvIHdyYXAgbWV0aG9kcyB5b3Ugd2FudCB0byBtZWFzdXJlLiBaZXJvIG92ZXJoZWFkIGluIHByb2R1Y3Rpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvYmpOYW1lXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmbk5hbWVcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gZnVuY1xuICAgKiBAcmV0dXJuIHtmdW5jdGlvbn1cbiAgICovXG4gIG1lYXN1cmU6IGZ1bmN0aW9uIChvYmpOYW1lLCBmbk5hbWUsIGZ1bmMpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIG1lYXN1cmVkRnVuYyA9IG51bGw7XG4gICAgICB2YXIgd3JhcHBlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKFJlYWN0UGVyZi5lbmFibGVNZWFzdXJlKSB7XG4gICAgICAgICAgaWYgKCFtZWFzdXJlZEZ1bmMpIHtcbiAgICAgICAgICAgIG1lYXN1cmVkRnVuYyA9IFJlYWN0UGVyZi5zdG9yZWRNZWFzdXJlKG9iak5hbWUsIGZuTmFtZSwgZnVuYyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBtZWFzdXJlZEZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfTtcbiAgICAgIHdyYXBwZXIuZGlzcGxheU5hbWUgPSBvYmpOYW1lICsgJ18nICsgZm5OYW1lO1xuICAgICAgcmV0dXJuIHdyYXBwZXI7XG4gICAgfVxuICAgIHJldHVybiBmdW5jO1xuICB9LFxuXG4gIGluamVjdGlvbjoge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IG1lYXN1cmVcbiAgICAgKi9cbiAgICBpbmplY3RNZWFzdXJlOiBmdW5jdGlvbiAobWVhc3VyZSkge1xuICAgICAgUmVhY3RQZXJmLnN0b3JlZE1lYXN1cmUgPSBtZWFzdXJlO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBTaW1wbHkgcGFzc2VzIHRocm91Z2ggdGhlIG1lYXN1cmVkIGZ1bmN0aW9uLCB3aXRob3V0IG1lYXN1cmluZyBpdC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gb2JqTmFtZVxuICogQHBhcmFtIHtzdHJpbmd9IGZuTmFtZVxuICogQHBhcmFtIHtmdW5jdGlvbn0gZnVuY1xuICogQHJldHVybiB7ZnVuY3Rpb259XG4gKi9cbmZ1bmN0aW9uIF9ub01lYXN1cmUob2JqTmFtZSwgZm5OYW1lLCBmdW5jKSB7XG4gIHJldHVybiBmdW5jO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0UGVyZjtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RQZXJmLmpzXG4gKiogbW9kdWxlIGlkID0gMjhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBjYW1lbGl6ZVN0eWxlTmFtZVxuICogQHR5cGVjaGVja3NcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBjYW1lbGl6ZSA9IHJlcXVpcmUoJy4vY2FtZWxpemUnKTtcblxudmFyIG1zUGF0dGVybiA9IC9eLW1zLS87XG5cbi8qKlxuICogQ2FtZWxjYXNlcyBhIGh5cGhlbmF0ZWQgQ1NTIHByb3BlcnR5IG5hbWUsIGZvciBleGFtcGxlOlxuICpcbiAqICAgPiBjYW1lbGl6ZVN0eWxlTmFtZSgnYmFja2dyb3VuZC1jb2xvcicpXG4gKiAgIDwgXCJiYWNrZ3JvdW5kQ29sb3JcIlxuICogICA+IGNhbWVsaXplU3R5bGVOYW1lKCctbW96LXRyYW5zaXRpb24nKVxuICogICA8IFwiTW96VHJhbnNpdGlvblwiXG4gKiAgID4gY2FtZWxpemVTdHlsZU5hbWUoJy1tcy10cmFuc2l0aW9uJylcbiAqICAgPCBcIm1zVHJhbnNpdGlvblwiXG4gKlxuICogQXMgQW5kaSBTbWl0aCBzdWdnZXN0c1xuICogKGh0dHA6Ly93d3cuYW5kaXNtaXRoLmNvbS9ibG9nLzIwMTIvMDIvbW9kZXJuaXpyLXByZWZpeGVkLyksIGFuIGAtbXNgIHByZWZpeFxuICogaXMgY29udmVydGVkIHRvIGxvd2VyY2FzZSBgbXNgLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmdcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gY2FtZWxpemVTdHlsZU5hbWUoc3RyaW5nKSB7XG4gIHJldHVybiBjYW1lbGl6ZShzdHJpbmcucmVwbGFjZShtc1BhdHRlcm4sICdtcy0nKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2FtZWxpemVTdHlsZU5hbWU7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vZmJqcy9saWIvY2FtZWxpemVTdHlsZU5hbWUuanNcbiAqKiBtb2R1bGUgaWQgPSAyOVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGNhbWVsaXplXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgX2h5cGhlblBhdHRlcm4gPSAvLSguKS9nO1xuXG4vKipcbiAqIENhbWVsY2FzZXMgYSBoeXBoZW5hdGVkIHN0cmluZywgZm9yIGV4YW1wbGU6XG4gKlxuICogICA+IGNhbWVsaXplKCdiYWNrZ3JvdW5kLWNvbG9yJylcbiAqICAgPCBcImJhY2tncm91bmRDb2xvclwiXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZ1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBjYW1lbGl6ZShzdHJpbmcpIHtcbiAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKF9oeXBoZW5QYXR0ZXJuLCBmdW5jdGlvbiAoXywgY2hhcmFjdGVyKSB7XG4gICAgcmV0dXJuIGNoYXJhY3Rlci50b1VwcGVyQ2FzZSgpO1xuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjYW1lbGl6ZTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9mYmpzL2xpYi9jYW1lbGl6ZS5qc1xuICoqIG1vZHVsZSBpZCA9IDMwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgZGFuZ2Vyb3VzU3R5bGVWYWx1ZVxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBDU1NQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vQ1NTUHJvcGVydHknKTtcblxudmFyIGlzVW5pdGxlc3NOdW1iZXIgPSBDU1NQcm9wZXJ0eS5pc1VuaXRsZXNzTnVtYmVyO1xuXG4vKipcbiAqIENvbnZlcnQgYSB2YWx1ZSBpbnRvIHRoZSBwcm9wZXIgY3NzIHdyaXRhYmxlIHZhbHVlLiBUaGUgc3R5bGUgbmFtZSBgbmFtZWBcbiAqIHNob3VsZCBiZSBsb2dpY2FsIChubyBoeXBoZW5zKSwgYXMgc3BlY2lmaWVkXG4gKiBpbiBgQ1NTUHJvcGVydHkuaXNVbml0bGVzc051bWJlcmAuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgQ1NTIHByb3BlcnR5IG5hbWUgc3VjaCBhcyBgdG9wTWFyZ2luYC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgQ1NTIHByb3BlcnR5IHZhbHVlIHN1Y2ggYXMgYDEwcHhgLlxuICogQHJldHVybiB7c3RyaW5nfSBOb3JtYWxpemVkIHN0eWxlIHZhbHVlIHdpdGggZGltZW5zaW9ucyBhcHBsaWVkLlxuICovXG5mdW5jdGlvbiBkYW5nZXJvdXNTdHlsZVZhbHVlKG5hbWUsIHZhbHVlKSB7XG4gIC8vIE5vdGUgdGhhdCB3ZSd2ZSByZW1vdmVkIGVzY2FwZVRleHRGb3JCcm93c2VyKCkgY2FsbHMgaGVyZSBzaW5jZSB0aGVcbiAgLy8gd2hvbGUgc3RyaW5nIHdpbGwgYmUgZXNjYXBlZCB3aGVuIHRoZSBhdHRyaWJ1dGUgaXMgaW5qZWN0ZWQgaW50b1xuICAvLyB0aGUgbWFya3VwLiBJZiB5b3UgcHJvdmlkZSB1bnNhZmUgdXNlciBkYXRhIGhlcmUgdGhleSBjYW4gaW5qZWN0XG4gIC8vIGFyYml0cmFyeSBDU1Mgd2hpY2ggbWF5IGJlIHByb2JsZW1hdGljIChJIGNvdWxkbid0IHJlcHJvIHRoaXMpOlxuICAvLyBodHRwczovL3d3dy5vd2FzcC5vcmcvaW5kZXgucGhwL1hTU19GaWx0ZXJfRXZhc2lvbl9DaGVhdF9TaGVldFxuICAvLyBodHRwOi8vd3d3LnRoZXNwYW5uZXIuY28udWsvMjAwNy8xMS8yNi91bHRpbWF0ZS14c3MtY3NzLWluamVjdGlvbi9cbiAgLy8gVGhpcyBpcyBub3QgYW4gWFNTIGhvbGUgYnV0IGluc3RlYWQgYSBwb3RlbnRpYWwgQ1NTIGluamVjdGlvbiBpc3N1ZVxuICAvLyB3aGljaCBoYXMgbGVhZCB0byBhIGdyZWF0ZXIgZGlzY3Vzc2lvbiBhYm91dCBob3cgd2UncmUgZ29pbmcgdG9cbiAgLy8gdHJ1c3QgVVJMcyBtb3ZpbmcgZm9yd2FyZC4gU2VlICMyMTE1OTAxXG5cbiAgdmFyIGlzRW1wdHkgPSB2YWx1ZSA9PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nIHx8IHZhbHVlID09PSAnJztcbiAgaWYgKGlzRW1wdHkpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICB2YXIgaXNOb25OdW1lcmljID0gaXNOYU4odmFsdWUpO1xuICBpZiAoaXNOb25OdW1lcmljIHx8IHZhbHVlID09PSAwIHx8IGlzVW5pdGxlc3NOdW1iZXIuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgaXNVbml0bGVzc051bWJlcltuYW1lXSkge1xuICAgIHJldHVybiAnJyArIHZhbHVlOyAvLyBjYXN0IHRvIHN0cmluZ1xuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICB2YWx1ZSA9IHZhbHVlLnRyaW0oKTtcbiAgfVxuICByZXR1cm4gdmFsdWUgKyAncHgnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGRhbmdlcm91c1N0eWxlVmFsdWU7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL2Rhbmdlcm91c1N0eWxlVmFsdWUuanNcbiAqKiBtb2R1bGUgaWQgPSAzMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGh5cGhlbmF0ZVN0eWxlTmFtZVxuICogQHR5cGVjaGVja3NcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBoeXBoZW5hdGUgPSByZXF1aXJlKCcuL2h5cGhlbmF0ZScpO1xuXG52YXIgbXNQYXR0ZXJuID0gL15tcy0vO1xuXG4vKipcbiAqIEh5cGhlbmF0ZXMgYSBjYW1lbGNhc2VkIENTUyBwcm9wZXJ0eSBuYW1lLCBmb3IgZXhhbXBsZTpcbiAqXG4gKiAgID4gaHlwaGVuYXRlU3R5bGVOYW1lKCdiYWNrZ3JvdW5kQ29sb3InKVxuICogICA8IFwiYmFja2dyb3VuZC1jb2xvclwiXG4gKiAgID4gaHlwaGVuYXRlU3R5bGVOYW1lKCdNb3pUcmFuc2l0aW9uJylcbiAqICAgPCBcIi1tb3otdHJhbnNpdGlvblwiXG4gKiAgID4gaHlwaGVuYXRlU3R5bGVOYW1lKCdtc1RyYW5zaXRpb24nKVxuICogICA8IFwiLW1zLXRyYW5zaXRpb25cIlxuICpcbiAqIEFzIE1vZGVybml6ciBzdWdnZXN0cyAoaHR0cDovL21vZGVybml6ci5jb20vZG9jcy8jcHJlZml4ZWQpLCBhbiBgbXNgIHByZWZpeFxuICogaXMgY29udmVydGVkIHRvIGAtbXMtYC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGh5cGhlbmF0ZVN0eWxlTmFtZShzdHJpbmcpIHtcbiAgcmV0dXJuIGh5cGhlbmF0ZShzdHJpbmcpLnJlcGxhY2UobXNQYXR0ZXJuLCAnLW1zLScpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGh5cGhlbmF0ZVN0eWxlTmFtZTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9mYmpzL2xpYi9oeXBoZW5hdGVTdHlsZU5hbWUuanNcbiAqKiBtb2R1bGUgaWQgPSAzMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGh5cGhlbmF0ZVxuICogQHR5cGVjaGVja3NcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfdXBwZXJjYXNlUGF0dGVybiA9IC8oW0EtWl0pL2c7XG5cbi8qKlxuICogSHlwaGVuYXRlcyBhIGNhbWVsY2FzZWQgc3RyaW5nLCBmb3IgZXhhbXBsZTpcbiAqXG4gKiAgID4gaHlwaGVuYXRlKCdiYWNrZ3JvdW5kQ29sb3InKVxuICogICA8IFwiYmFja2dyb3VuZC1jb2xvclwiXG4gKlxuICogRm9yIENTUyBzdHlsZSBuYW1lcywgdXNlIGBoeXBoZW5hdGVTdHlsZU5hbWVgIGluc3RlYWQgd2hpY2ggd29ya3MgcHJvcGVybHlcbiAqIHdpdGggYWxsIHZlbmRvciBwcmVmaXhlcywgaW5jbHVkaW5nIGBtc2AuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZ1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBoeXBoZW5hdGUoc3RyaW5nKSB7XG4gIHJldHVybiBzdHJpbmcucmVwbGFjZShfdXBwZXJjYXNlUGF0dGVybiwgJy0kMScpLnRvTG93ZXJDYXNlKCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaHlwaGVuYXRlO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2ZianMvbGliL2h5cGhlbmF0ZS5qc1xuICoqIG1vZHVsZSBpZCA9IDMzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgbWVtb2l6ZVN0cmluZ09ubHlcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIE1lbW9pemVzIHRoZSByZXR1cm4gdmFsdWUgb2YgYSBmdW5jdGlvbiB0aGF0IGFjY2VwdHMgb25lIHN0cmluZyBhcmd1bWVudC5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFja1xuICogQHJldHVybiB7ZnVuY3Rpb259XG4gKi9cbmZ1bmN0aW9uIG1lbW9pemVTdHJpbmdPbmx5KGNhbGxiYWNrKSB7XG4gIHZhciBjYWNoZSA9IHt9O1xuICByZXR1cm4gZnVuY3Rpb24gKHN0cmluZykge1xuICAgIGlmICghY2FjaGUuaGFzT3duUHJvcGVydHkoc3RyaW5nKSkge1xuICAgICAgY2FjaGVbc3RyaW5nXSA9IGNhbGxiYWNrLmNhbGwodGhpcywgc3RyaW5nKTtcbiAgICB9XG4gICAgcmV0dXJuIGNhY2hlW3N0cmluZ107XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWVtb2l6ZVN0cmluZ09ubHk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vZmJqcy9saWIvbWVtb2l6ZVN0cmluZ09ubHkuanNcbiAqKiBtb2R1bGUgaWQgPSAzNFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNC0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIHdhcm5pbmdcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9lbXB0eUZ1bmN0aW9uJyk7XG5cbi8qKlxuICogU2ltaWxhciB0byBpbnZhcmlhbnQgYnV0IG9ubHkgbG9ncyBhIHdhcm5pbmcgaWYgdGhlIGNvbmRpdGlvbiBpcyBub3QgbWV0LlxuICogVGhpcyBjYW4gYmUgdXNlZCB0byBsb2cgaXNzdWVzIGluIGRldmVsb3BtZW50IGVudmlyb25tZW50cyBpbiBjcml0aWNhbFxuICogcGF0aHMuIFJlbW92aW5nIHRoZSBsb2dnaW5nIGNvZGUgZm9yIHByb2R1Y3Rpb24gZW52aXJvbm1lbnRzIHdpbGwga2VlcCB0aGVcbiAqIHNhbWUgbG9naWMgYW5kIGZvbGxvdyB0aGUgc2FtZSBjb2RlIHBhdGhzLlxuICovXG5cbnZhciB3YXJuaW5nID0gZW1wdHlGdW5jdGlvbjtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgd2FybmluZyA9IGZ1bmN0aW9uIChjb25kaXRpb24sIGZvcm1hdCkge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiA+IDIgPyBfbGVuIC0gMiA6IDApLCBfa2V5ID0gMjsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5IC0gMl0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2B3YXJuaW5nKGNvbmRpdGlvbiwgZm9ybWF0LCAuLi5hcmdzKWAgcmVxdWlyZXMgYSB3YXJuaW5nICcgKyAnbWVzc2FnZSBhcmd1bWVudCcpO1xuICAgIH1cblxuICAgIGlmIChmb3JtYXQuaW5kZXhPZignRmFpbGVkIENvbXBvc2l0ZSBwcm9wVHlwZTogJykgPT09IDApIHtcbiAgICAgIHJldHVybjsgLy8gSWdub3JlIENvbXBvc2l0ZUNvbXBvbmVudCBwcm9wdHlwZSBjaGVjay5cbiAgICB9XG5cbiAgICBpZiAoIWNvbmRpdGlvbikge1xuICAgICAgdmFyIGFyZ0luZGV4ID0gMDtcbiAgICAgIHZhciBtZXNzYWdlID0gJ1dhcm5pbmc6ICcgKyBmb3JtYXQucmVwbGFjZSgvJXMvZywgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gYXJnc1thcmdJbmRleCsrXTtcbiAgICAgIH0pO1xuICAgICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UpO1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gLS0tIFdlbGNvbWUgdG8gZGVidWdnaW5nIFJlYWN0IC0tLVxuICAgICAgICAvLyBUaGlzIGVycm9yIHdhcyB0aHJvd24gYXMgYSBjb252ZW5pZW5jZSBzbyB0aGF0IHlvdSBjYW4gdXNlIHRoaXMgc3RhY2tcbiAgICAgICAgLy8gdG8gZmluZCB0aGUgY2FsbHNpdGUgdGhhdCBjYXVzZWQgdGhpcyB3YXJuaW5nIHRvIGZpcmUuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICAgIH0gY2F0Y2ggKHgpIHt9XG4gICAgfVxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHdhcm5pbmc7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vZmJqcy9saWIvd2FybmluZy5qc1xuICoqIG1vZHVsZSBpZCA9IDM1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgY29uc29sZTtcclxuaWYgKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgJiYgZ2xvYmFsLmNvbnNvbGUpIHtcclxuICAgIGNvbnNvbGUgPSBnbG9iYWwuY29uc29sZVxyXG59IGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93LmNvbnNvbGUpIHtcclxuICAgIGNvbnNvbGUgPSB3aW5kb3cuY29uc29sZVxyXG59IGVsc2Uge1xyXG4gICAgY29uc29sZSA9IHdpbmRvdy5jb25zb2xlID0ge31cclxufVxyXG5tb2R1bGUuZXhwb3J0cyA9IGNvbnNvbGU7XHJcbmZvcih2YXIgbmFtZSBpbiB7bG9nOjEsIGluZm86MSwgZXJyb3I6MSwgd2FybjoxLCBkaXI6MSwgdHJhY2U6MSwgYXNzZXJ0OjEsIHRpbWU6MSwgdGltZUVuZDogMX0pXHJcblx0aWYoIWNvbnNvbGVbbmFtZV0pXHJcblx0XHRjb25zb2xlW25hbWVdID0gZnVuY3Rpb24oKSB7fTtcclxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vbm9kZS1saWJzLWJyb3dzZXIvbW9jay9jb25zb2xlLmpzXG4gKiogbW9kdWxlIGlkID0gMzZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBlbXB0eUZ1bmN0aW9uXG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIG1ha2VFbXB0eUZ1bmN0aW9uKGFyZykge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBhcmc7XG4gIH07XG59XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBhY2NlcHRzIGFuZCBkaXNjYXJkcyBpbnB1dHM7IGl0IGhhcyBubyBzaWRlIGVmZmVjdHMuIFRoaXMgaXNcbiAqIHByaW1hcmlseSB1c2VmdWwgaWRpb21hdGljYWxseSBmb3Igb3ZlcnJpZGFibGUgZnVuY3Rpb24gZW5kcG9pbnRzIHdoaWNoXG4gKiBhbHdheXMgbmVlZCB0byBiZSBjYWxsYWJsZSwgc2luY2UgSlMgbGFja3MgYSBudWxsLWNhbGwgaWRpb20gYWxhIENvY29hLlxuICovXG5mdW5jdGlvbiBlbXB0eUZ1bmN0aW9uKCkge31cblxuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJucyA9IG1ha2VFbXB0eUZ1bmN0aW9uO1xuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0ZhbHNlID0gbWFrZUVtcHR5RnVuY3Rpb24oZmFsc2UpO1xuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc1RydWUgPSBtYWtlRW1wdHlGdW5jdGlvbih0cnVlKTtcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNOdWxsID0gbWFrZUVtcHR5RnVuY3Rpb24obnVsbCk7XG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zVGhpcyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXM7XG59O1xuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0FyZ3VtZW50ID0gZnVuY3Rpb24gKGFyZykge1xuICByZXR1cm4gYXJnO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBlbXB0eUZ1bmN0aW9uO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2ZianMvbGliL2VtcHR5RnVuY3Rpb24uanNcbiAqKiBtb2R1bGUgaWQgPSAzN1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBAY29weXJpZ2h0IDIwMTUgUHJvbWV0aGV1cyBSZXNlYXJjaCwgTExDXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IChmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoJ3ZhbHVlJyBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSkoKTtcblxudmFyIF9nZXQgPSBmdW5jdGlvbiBnZXQoX3gsIF94MiwgX3gzKSB7IHZhciBfYWdhaW4gPSB0cnVlOyBfZnVuY3Rpb246IHdoaWxlIChfYWdhaW4pIHsgdmFyIG9iamVjdCA9IF94LCBwcm9wZXJ0eSA9IF94MiwgcmVjZWl2ZXIgPSBfeDM7IF9hZ2FpbiA9IGZhbHNlOyBpZiAob2JqZWN0ID09PSBudWxsKSBvYmplY3QgPSBGdW5jdGlvbi5wcm90b3R5cGU7IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KTsgaWYgKGRlc2MgPT09IHVuZGVmaW5lZCkgeyB2YXIgcGFyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChwYXJlbnQgPT09IG51bGwpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSBlbHNlIHsgX3ggPSBwYXJlbnQ7IF94MiA9IHByb3BlcnR5OyBfeDMgPSByZWNlaXZlcjsgX2FnYWluID0gdHJ1ZTsgZGVzYyA9IHBhcmVudCA9IHVuZGVmaW5lZDsgY29udGludWUgX2Z1bmN0aW9uOyB9IH0gZWxzZSBpZiAoJ3ZhbHVlJyBpbiBkZXNjKSB7IHJldHVybiBkZXNjLnZhbHVlOyB9IGVsc2UgeyB2YXIgZ2V0dGVyID0gZGVzYy5nZXQ7IGlmIChnZXR0ZXIgPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IHJldHVybiBnZXR0ZXIuY2FsbChyZWNlaXZlcik7IH0gfSB9O1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGVsc2UgeyB2YXIgbmV3T2JqID0ge307IGlmIChvYmogIT0gbnVsbCkgeyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gbmV3T2JqWydkZWZhdWx0J10gPSBvYmo7IHJldHVybiBuZXdPYmo7IH0gfVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhvYmosIGtleXMpIHsgdmFyIHRhcmdldCA9IHt9OyBmb3IgKHZhciBpIGluIG9iaikgeyBpZiAoa2V5cy5pbmRleE9mKGkpID49IDApIGNvbnRpbnVlOyBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGkpKSBjb250aW51ZTsgdGFyZ2V0W2ldID0gb2JqW2ldOyB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb24nKTsgfSB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09ICdmdW5jdGlvbicgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90ICcgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgX3JlYWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0KTtcblxudmFyIF9jbGFzc25hbWVzID0gcmVxdWlyZSgnY2xhc3NuYW1lcycpO1xuXG52YXIgX2NsYXNzbmFtZXMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY2xhc3NuYW1lcyk7XG5cbnZhciBfZ2V0Q29tcG9uZW50RGlzcGxheU5hbWUgPSByZXF1aXJlKCcuL2dldENvbXBvbmVudERpc3BsYXlOYW1lJyk7XG5cbnZhciBfZ2V0Q29tcG9uZW50RGlzcGxheU5hbWUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2V0Q29tcG9uZW50RGlzcGxheU5hbWUpO1xuXG52YXIgX0RPTVN0eWxlc2hlZXQgPSByZXF1aXJlKCcuL0RPTVN0eWxlc2hlZXQnKTtcblxudmFyIERPTVN0eWxlc2hlZXQgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfRE9NU3R5bGVzaGVldCk7XG5cbnZhciBTdHlsZWFibGVET01Db21wb25lbnQgPSAoZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzKFN0eWxlYWJsZURPTUNvbXBvbmVudCwgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgX2NyZWF0ZUNsYXNzKFN0eWxlYWJsZURPTUNvbXBvbmVudCwgbnVsbCwgW3tcbiAgICBrZXk6ICdzdHlsZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN0eWxlKHNwZWMpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHJldHVybiAoZnVuY3Rpb24gKF9TdHlsZWFibGVET01Db21wb25lbnQpIHtcbiAgICAgICAgX2luaGVyaXRzKF9jbGFzcywgX1N0eWxlYWJsZURPTUNvbXBvbmVudCk7XG5cbiAgICAgICAgZnVuY3Rpb24gX2NsYXNzKCkge1xuICAgICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBfY2xhc3MpO1xuXG4gICAgICAgICAgX2dldChPYmplY3QuZ2V0UHJvdG90eXBlT2YoX2NsYXNzLnByb3RvdHlwZSksICdjb25zdHJ1Y3RvcicsIHRoaXMpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cblxuICAgICAgICBfY3JlYXRlQ2xhc3MoX2NsYXNzLCBudWxsLCBbe1xuICAgICAgICAgIGtleTogJ2Rpc3BsYXlOYW1lJyxcbiAgICAgICAgICB2YWx1ZTogKDAsIF9nZXRDb21wb25lbnREaXNwbGF5TmFtZTJbJ2RlZmF1bHQnXSkoX3RoaXMpLFxuICAgICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICAgICAgfSwge1xuICAgICAgICAgIGtleTogJ0NvbXBvbmVudCcsXG4gICAgICAgICAgdmFsdWU6IF90aGlzLkNvbXBvbmVudCxcbiAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBrZXk6ICdzdHlsZXNoZWV0JyxcbiAgICAgICAgICB2YWx1ZTogRE9NU3R5bGVzaGVldC5vdmVycmlkZVN0eWxlc2hlZXQoX3RoaXMuc3R5bGVzaGVldCwgc3BlYyksXG4gICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgICB9XSk7XG5cbiAgICAgICAgcmV0dXJuIF9jbGFzcztcbiAgICAgIH0pKFN0eWxlYWJsZURPTUNvbXBvbmVudCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnQ29tcG9uZW50JyxcbiAgICB2YWx1ZTogbnVsbCxcbiAgICBlbnVtZXJhYmxlOiB0cnVlXG4gIH0sIHtcbiAgICBrZXk6ICdzdHlsZXNoZWV0JyxcbiAgICB2YWx1ZTogbnVsbCxcbiAgICBlbnVtZXJhYmxlOiB0cnVlXG4gIH0sIHtcbiAgICBrZXk6ICdwcm9wVHlwZXMnLFxuICAgIHZhbHVlOiB7XG4gICAgICB2YXJpYW50OiBfcmVhY3QuUHJvcFR5cGVzLm9iamVjdCxcbiAgICAgIHN0YXRlOiBfcmVhY3QuUHJvcFR5cGVzLm9iamVjdCxcbiAgICAgIENvbXBvbmVudDogX3JlYWN0LlByb3BUeXBlcy5vbmVPZlR5cGUoW19yZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLCBfcmVhY3QuUHJvcFR5cGVzLmZ1bmNdKSxcbiAgICAgIGNsYXNzTmFtZTogX3JlYWN0LlByb3BUeXBlcy5zdHJpbmdcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IHRydWVcbiAgfV0pO1xuXG4gIGZ1bmN0aW9uIFN0eWxlYWJsZURPTUNvbXBvbmVudChwcm9wcykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTdHlsZWFibGVET01Db21wb25lbnQpO1xuXG4gICAgX2dldChPYmplY3QuZ2V0UHJvdG90eXBlT2YoU3R5bGVhYmxlRE9NQ29tcG9uZW50LnByb3RvdHlwZSksICdjb25zdHJ1Y3RvcicsIHRoaXMpLmNhbGwodGhpcywgcHJvcHMpO1xuICAgIHRoaXMuX3N0YXRlRGVwcmVjYXRpb25XYXJuZWQgPSBmYWxzZTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhTdHlsZWFibGVET01Db21wb25lbnQsIFt7XG4gICAga2V5OiAncmVuZGVyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgdmFyIF9wcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgICB2YXIgdmFyaWFudCA9IF9wcm9wcy52YXJpYW50O1xuICAgICAgdmFyIHN0YXRlID0gX3Byb3BzLnN0YXRlO1xuICAgICAgdmFyIF9wcm9wcyRDb21wb25lbnQgPSBfcHJvcHMuQ29tcG9uZW50O1xuICAgICAgdmFyIENvbXBvbmVudCA9IF9wcm9wcyRDb21wb25lbnQgPT09IHVuZGVmaW5lZCA/IHRoaXMuY29uc3RydWN0b3IuQ29tcG9uZW50IDogX3Byb3BzJENvbXBvbmVudDtcbiAgICAgIHZhciBleHRyYUNsYXNzTmFtZSA9IF9wcm9wcy5jbGFzc05hbWU7XG5cbiAgICAgIHZhciBwcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcHJvcHMsIFsndmFyaWFudCcsICdzdGF0ZScsICdDb21wb25lbnQnLCAnY2xhc3NOYW1lJ10pO1xuXG4gICAgICBpZiAoc3RhdGUgJiYgIXRoaXMuX3N0YXRlRGVwcmVjYXRpb25XYXJuZWQpIHtcbiAgICAgICAgdGhpcy5fc3RhdGVEZXByZWNhdGlvbldhcm5lZCA9IHRydWU7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgICAgJ1dhcm5pbmc6IFJlYWN0IFN0eWxlc2hlZXQ6IHN0YXRlIGlzIGRlcHJlY2F0ZWQsIHVzZSB2YXJpYW50IGluc3RlYWQnKTtcbiAgICAgIH1cbiAgICAgIHZhcmlhbnQgPSB2YXJpYW50IHx8IHN0YXRlO1xuICAgICAgdmFyIHN0eWxlc2hlZXQgPSB0aGlzLmNvbnN0cnVjdG9yLnN0eWxlc2hlZXQ7XG5cbiAgICAgIHZhciBjbGFzc05hbWUgPSBzdHlsZXNoZWV0LmFzQ2xhc3NOYW1lKHZhcmlhbnQpO1xuICAgICAgcmV0dXJuIF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KENvbXBvbmVudCwgX2V4dGVuZHMoe30sIHByb3BzLCB7XG4gICAgICAgIGNsYXNzTmFtZTogKDAsIF9jbGFzc25hbWVzMlsnZGVmYXVsdCddKShjbGFzc05hbWUsIGV4dHJhQ2xhc3NOYW1lKVxuICAgICAgfSkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2NvbXBvbmVudERpZE1vdW50JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICB0aGlzLmNvbnN0cnVjdG9yLnN0eWxlc2hlZXQudXNlKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnY29tcG9uZW50V2lsbFVubW91bnQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICAgIHRoaXMuY29uc3RydWN0b3Iuc3R5bGVzaGVldC5kaXNwb3NlKCk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFN0eWxlYWJsZURPTUNvbXBvbmVudDtcbn0pKF9yZWFjdDJbJ2RlZmF1bHQnXS5Db21wb25lbnQpO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBTdHlsZWFibGVET01Db21wb25lbnQ7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0LXN0eWxlc2hlZXQvbGliL1N0eWxlYWJsZURPTUNvbXBvbmVudC5qc1xuICoqIG1vZHVsZSBpZCA9IDM4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKiFcbiAgQ29weXJpZ2h0IChjKSAyMDE1IEplZCBXYXRzb24uXG4gIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZSAoTUlUKSwgc2VlXG4gIGh0dHA6Ly9qZWR3YXRzb24uZ2l0aHViLmlvL2NsYXNzbmFtZXNcbiovXG4vKiBnbG9iYWwgZGVmaW5lICovXG5cbihmdW5jdGlvbiAoKSB7XG5cdCd1c2Ugc3RyaWN0JztcblxuXHR2YXIgaGFzT3duID0ge30uaGFzT3duUHJvcGVydHk7XG5cblx0ZnVuY3Rpb24gY2xhc3NOYW1lcyAoKSB7XG5cdFx0dmFyIGNsYXNzZXMgPSAnJztcblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgYXJnID0gYXJndW1lbnRzW2ldO1xuXHRcdFx0aWYgKCFhcmcpIGNvbnRpbnVlO1xuXG5cdFx0XHR2YXIgYXJnVHlwZSA9IHR5cGVvZiBhcmc7XG5cblx0XHRcdGlmIChhcmdUeXBlID09PSAnc3RyaW5nJyB8fCBhcmdUeXBlID09PSAnbnVtYmVyJykge1xuXHRcdFx0XHRjbGFzc2VzICs9ICcgJyArIGFyZztcblx0XHRcdH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShhcmcpKSB7XG5cdFx0XHRcdGNsYXNzZXMgKz0gJyAnICsgY2xhc3NOYW1lcy5hcHBseShudWxsLCBhcmcpO1xuXHRcdFx0fSBlbHNlIGlmIChhcmdUeXBlID09PSAnb2JqZWN0Jykge1xuXHRcdFx0XHRmb3IgKHZhciBrZXkgaW4gYXJnKSB7XG5cdFx0XHRcdFx0aWYgKGhhc093bi5jYWxsKGFyZywga2V5KSAmJiBhcmdba2V5XSkge1xuXHRcdFx0XHRcdFx0Y2xhc3NlcyArPSAnICcgKyBrZXk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNsYXNzZXMuc3Vic3RyKDEpO1xuXHR9XG5cblx0aWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBjbGFzc05hbWVzO1xuXHR9IGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGRlZmluZS5hbWQgPT09ICdvYmplY3QnICYmIGRlZmluZS5hbWQpIHtcblx0XHQvLyByZWdpc3RlciBhcyAnY2xhc3NuYW1lcycsIGNvbnNpc3RlbnQgd2l0aCBucG0gcGFja2FnZSBuYW1lXG5cdFx0ZGVmaW5lKCdjbGFzc25hbWVzJywgW10sIGZ1bmN0aW9uICgpIHtcblx0XHRcdHJldHVybiBjbGFzc05hbWVzO1xuXHRcdH0pO1xuXHR9IGVsc2Uge1xuXHRcdHdpbmRvdy5jbGFzc05hbWVzID0gY2xhc3NOYW1lcztcblx0fVxufSgpKTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NsYXNzbmFtZXMvaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSAzOVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBAY29weXJpZ2h0IDIwMTUgUHJvbWV0aGV1cyBSZXNlYXJjaCwgTExDXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IChmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoJ3ZhbHVlJyBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSkoKTtcblxudmFyIF9nZXQgPSBmdW5jdGlvbiBnZXQoX3gsIF94MiwgX3gzKSB7IHZhciBfYWdhaW4gPSB0cnVlOyBfZnVuY3Rpb246IHdoaWxlIChfYWdhaW4pIHsgdmFyIG9iamVjdCA9IF94LCBwcm9wZXJ0eSA9IF94MiwgcmVjZWl2ZXIgPSBfeDM7IF9hZ2FpbiA9IGZhbHNlOyBpZiAob2JqZWN0ID09PSBudWxsKSBvYmplY3QgPSBGdW5jdGlvbi5wcm90b3R5cGU7IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KTsgaWYgKGRlc2MgPT09IHVuZGVmaW5lZCkgeyB2YXIgcGFyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChwYXJlbnQgPT09IG51bGwpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSBlbHNlIHsgX3ggPSBwYXJlbnQ7IF94MiA9IHByb3BlcnR5OyBfeDMgPSByZWNlaXZlcjsgX2FnYWluID0gdHJ1ZTsgZGVzYyA9IHBhcmVudCA9IHVuZGVmaW5lZDsgY29udGludWUgX2Z1bmN0aW9uOyB9IH0gZWxzZSBpZiAoJ3ZhbHVlJyBpbiBkZXNjKSB7IHJldHVybiBkZXNjLnZhbHVlOyB9IGVsc2UgeyB2YXIgZ2V0dGVyID0gZGVzYy5nZXQ7IGlmIChnZXR0ZXIgPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IHJldHVybiBnZXR0ZXIuY2FsbChyZWNlaXZlcik7IH0gfSB9O1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBzdHlsZWFibGU7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb24nKTsgfSB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09ICdmdW5jdGlvbicgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90ICcgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgX1N0eWxlc2hlZXQgPSByZXF1aXJlKCcuL1N0eWxlc2hlZXQnKTtcblxudmFyIF9nZXRDb21wb25lbnREaXNwbGF5TmFtZSA9IHJlcXVpcmUoJy4vZ2V0Q29tcG9uZW50RGlzcGxheU5hbWUnKTtcblxudmFyIF9nZXRDb21wb25lbnREaXNwbGF5TmFtZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9nZXRDb21wb25lbnREaXNwbGF5TmFtZSk7XG5cbmZ1bmN0aW9uIHN0eWxlYWJsZShDb21wb25lbnQpIHtcbiAgdmFyIGRpc3BsYXlOYW1lID0gKDAsIF9nZXRDb21wb25lbnREaXNwbGF5TmFtZTJbJ2RlZmF1bHQnXSkoQ29tcG9uZW50KTtcbiAgcmV0dXJuIChmdW5jdGlvbiAoX0NvbXBvbmVudCkge1xuICAgIF9pbmhlcml0cyhfY2xhc3MsIF9Db21wb25lbnQpO1xuXG4gICAgZnVuY3Rpb24gX2NsYXNzKCkge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIF9jbGFzcyk7XG5cbiAgICAgIF9nZXQoT2JqZWN0LmdldFByb3RvdHlwZU9mKF9jbGFzcy5wcm90b3R5cGUpLCAnY29uc3RydWN0b3InLCB0aGlzKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhfY2xhc3MsIFt7XG4gICAgICBrZXk6ICdzdHlsZXNoZWV0JyxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcm9wcy5zdHlsZXNoZWV0IHx8IHRoaXMuY29uc3RydWN0b3Iuc3R5bGVzaGVldDtcbiAgICAgIH1cbiAgICB9XSwgW3tcbiAgICAgIGtleTogJ3N0eWxlJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzdHlsZShzcGVjKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgICAgcmV0dXJuIChmdW5jdGlvbiAoX3JlZikge1xuICAgICAgICAgIF9pbmhlcml0cyhfY2xhc3MyLCBfcmVmKTtcblxuICAgICAgICAgIGZ1bmN0aW9uIF9jbGFzczIoKSB7XG4gICAgICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgX2NsYXNzMik7XG5cbiAgICAgICAgICAgIF9nZXQoT2JqZWN0LmdldFByb3RvdHlwZU9mKF9jbGFzczIucHJvdG90eXBlKSwgJ2NvbnN0cnVjdG9yJywgdGhpcykuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBfY3JlYXRlQ2xhc3MoX2NsYXNzMiwgbnVsbCwgW3tcbiAgICAgICAgICAgIGtleTogJ3N0eWxlc2hlZXQnLFxuICAgICAgICAgICAgdmFsdWU6ICgwLCBfU3R5bGVzaGVldC5vdmVycmlkZVN0eWxlc2hlZXQpKF90aGlzLnN0eWxlc2hlZXQsIHNwZWMpLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgICAgIH1dKTtcblxuICAgICAgICAgIHJldHVybiBfY2xhc3MyO1xuICAgICAgICB9KSh0aGlzKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdwcm9wVHlwZXMnLFxuICAgICAgdmFsdWU6IF9leHRlbmRzKHt9LCBDb21wb25lbnQucHJvcFR5cGVzLCB7XG4gICAgICAgIHN0eWxlc2hlZXQ6IF9yZWFjdC5Qcm9wVHlwZXMub2JqZWN0XG4gICAgICB9KSxcbiAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICB9LCB7XG4gICAgICBrZXk6ICdkaXNwbGF5TmFtZScsXG4gICAgICB2YWx1ZTogZGlzcGxheU5hbWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIF9jbGFzcztcbiAgfSkoQ29tcG9uZW50KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC1zdHlsZXNoZWV0L2xpYi9zdHlsZWFibGUuanNcbiAqKiBtb2R1bGUgaWQgPSA0MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBAY29weXJpZ2h0IDIwMTUsIFByb21ldGhldXMgUmVzZWFyY2gsIExMQ1xuICovXG5cbmltcG9ydCBSZWFjdCwge1Byb3BUeXBlc30gZnJvbSAncmVhY3QnO1xuaW1wb3J0IGludmFyaWFudCAgICAgICAgICBmcm9tICdpbnZhcmlhbnQnO1xuaW1wb3J0IGtleVBhdGggICAgICAgICAgICBmcm9tICcuL2tleVBhdGgnO1xuXG5leHBvcnQgY29uc3QgQ29udGV4dFR5cGVzID0ge1xuICBmb3JtVmFsdWU6IFByb3BUeXBlcy5vYmplY3Rcbn07XG5cbmxldCBzZWxlY3RQcm9wVHlwZSA9IFByb3BUeXBlcy5vbmVPZlR5cGUoW1xuICBQcm9wVHlwZXMuYXJyYXksXG4gIFByb3BUeXBlcy5zdHJpbmcsXG4gIFByb3BUeXBlcy5udW1iZXIsXG4gIFByb3BUeXBlcy5ib29sXG5dKTtcblxuLyoqXG4gKiBCYXNlIGNsYXNzIGZvciBmb3JtIGNvbXBvbmVudHMuXG4gKlxuICogSXQgZXhwb3NlcyBmb3JtIHZhbHVlIHZpYSBgdGhpcy5mb3JtVmFsdWVgIHdoaWNoIGlzIHByb3ZpZGVkIGVpdGhlciB2aWFcbiAqIGB0aGlzLnByb3BzLmZvcm1WYWx1ZWAgb3IgdmlhIGNvbnRleHQuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENvbXBvbmVudCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG5cbiAgc3RhdGljIHByb3BUeXBlcyA9IHtcbiAgICAvKipcbiAgICAgKiBGb3JtIHZhbHVlIHBhc3NlZCBhcyBhIHByb3AuXG4gICAgICovXG4gICAgZm9ybVZhbHVlOiBQcm9wVHlwZXMub2JqZWN0LFxuXG4gICAgLyoqXG4gICAgICogU2VsZWN0b3IgZm9yIGZvcm0gdmFsdWUuXG4gICAgICpcbiAgICAgKiBVc2VkIHRvIHNlbGVjdCBhIHBhcnQgZnJvbSBhIGZvcm0gdmFsdWUgcGFzc2VkIHZpYSBjb250ZXh0LlxuICAgICAqL1xuICAgIHNlbGVjdDogc2VsZWN0UHJvcFR5cGUsXG5cbiAgICAvKipcbiAgICAgKiBTYW1lIGFzIGBzZWxlY3RgLlxuICAgICAqXG4gICAgICogRGVwcmVjYXRlZC5cbiAgICAgKi9cbiAgICBzZWxlY3RGb3JtVmFsdWU6IHNlbGVjdFByb3BUeXBlXG4gIH07XG5cbiAgc3RhdGljIGNvbnRleHRUeXBlcyA9IENvbnRleHRUeXBlcztcbiAgc3RhdGljIGNoaWxkQ29udGV4dFR5cGVzID0gQ29udGV4dFR5cGVzO1xuXG4gIGdldENoaWxkQ29udGV4dCgpIHtcbiAgICByZXR1cm4ge2Zvcm1WYWx1ZTogdGhpcy5mb3JtVmFsdWV9O1xuICB9XG5cbiAgZ2V0IGZvcm1WYWx1ZSgpIHtcbiAgICBsZXQgZm9ybVZhbHVlID0gdGhpcy5wcm9wcy5mb3JtVmFsdWUgfHwgdGhpcy5jb250ZXh0LmZvcm1WYWx1ZTtcblxuICAgIGludmFyaWFudChcbiAgICAgIGZvcm1WYWx1ZSxcbiAgICAgICdBIGZvcm0gY29tcG9uZW50IDwlcyAvPiBzaG91bGQgcmVjZWl2ZSBmb3JtIHZhbHVlIHZpYSBwcm9wcyAnICtcbiAgICAgICdvciBiZSB1c2VkIGFzIGEgcGFydCBvZiBlbGVtZW50IGhpZXJhcmNoeSB3aGljaCAnICtcbiAgICAgICdpbmNsdWRlcyA8Rm9ybSAvPiBjb21wb25lbnQgaW4gaXRzIGFuY2VzdG9ycycsXG4gICAgICB0aGlzLmNvbnN0cnVjdG9yLmRpc3BsYXlOYW1lIHx8IHRoaXMuY29uc3RydWN0b3IubmFtZVxuICAgICk7XG5cbiAgICBsZXQgc2VsZWN0ID0gdGhpcy5wcm9wcy5zZWxlY3QgfHwgdGhpcy5wcm9wcy5zZWxlY3RGb3JtVmFsdWU7XG4gICAgLy8gV2UgY2hlY2sgZm9yIHNlbGVjdCAhPT0gdHJ1ZSB0byBrZWVwIGNvbXBhdGFiaWxpdHkgd2UgZWFyaWxlclxuICAgIC8vIHZlcnNpb25zIG9mIFJlYWN0IEZvcm1zIHdoZXJlIHdlIG5lZWRlZCB0byByZWJ1aWxkIGVsZW1lbnQgdHJlZSB0b1xuICAgIC8vIHByb3BhZ2F0ZSB2YWx1ZXMgdG8gZm9ybS5cbiAgICBpZiAoc2VsZWN0ICYmIHNlbGVjdCAhPT0gdHJ1ZSkge1xuICAgICAgc2VsZWN0ID0ga2V5UGF0aChzZWxlY3QpO1xuICAgICAgZm9ybVZhbHVlID0gZm9ybVZhbHVlLnNlbGVjdChzZWxlY3QpO1xuICAgIH1cblxuICAgIHJldHVybiBmb3JtVmFsdWU7XG4gIH1cbn1cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL0NvbXBvbmVudC5qc1xuICoqLyIsIi8qKlxuICogQGNvcHlyaWdodCAyMDE1LCBQcm9tZXRoZXVzIFJlc2VhcmNoLCBMTENcbiAqL1xuXG5pbXBvcnQgaXNTdHJpbmcgIGZyb20gJ2xvZGFzaC9sYW5nL2lzU3RyaW5nJztcbmltcG9ydCBpc0FycmF5ICAgZnJvbSAnbG9kYXNoL2xhbmcvaXNBcnJheSc7XG5pbXBvcnQgaW52YXJpYW50IGZyb20gJ2ludmFyaWFudCc7XG5cbmNvbnN0IElTX05VTUJFUiA9IC9bMC05XSsvO1xuXG5mdW5jdGlvbiB0cnlQYXJzZUludCh2KSB7XG4gIGlmICh0eXBlb2YgdiA9PT0gJ3N0cmluZycgJiYgSVNfTlVNQkVSLmV4ZWModikpIHtcbiAgICB2ID0gcGFyc2VJbnQodiwgMTApO1xuICB9XG4gIHJldHVybiB2O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBrZXlQYXRoKHZhbHVlKSB7XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfSBlbHNlIGlmIChpc1N0cmluZyh2YWx1ZSkpIHtcbiAgICBpZiAodmFsdWUuaW5kZXhPZignLicpICE9PSAtMSkge1xuICAgICAgdmFsdWUgPSB2YWx1ZS5zcGxpdCgnLicpLmZpbHRlcihCb29sZWFuKS5tYXAodHJ5UGFyc2VJbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSA9IFt0cnlQYXJzZUludCh2YWx1ZSldO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIHJldHVybiBbdmFsdWVdO1xuICB9IGVsc2Uge1xuICAgIGludmFyaWFudChcbiAgICAgIGZhbHNlLFxuICAgICAgJ2tleVBhdGggY2FuIGJlIGVpdGhlciBhbiBhcnJheSwgYSBzdHJpbmcgb3IgYSBudW1iZXIsIGdvdDogJXMnLFxuICAgICAgdmFsdWVcbiAgICApO1xuICB9XG59XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9rZXlQYXRoLmpzXG4gKiovIiwidmFyIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4uL2ludGVybmFsL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXSc7XG5cbi8qKiBVc2VkIGZvciBuYXRpdmUgbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBvYmpUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU3RyaW5nYCBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBjb3JyZWN0bHkgY2xhc3NpZmllZCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzU3RyaW5nKCdhYmMnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzU3RyaW5nKDEpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNTdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyB8fCAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBvYmpUb1N0cmluZy5jYWxsKHZhbHVlKSA9PSBzdHJpbmdUYWcpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzU3RyaW5nO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vbG9kYXNoL2xhbmcvaXNTdHJpbmcuanNcbiAqKiBtb2R1bGUgaWQgPSA0M1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuICEhdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzT2JqZWN0TGlrZTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2xvZGFzaC9pbnRlcm5hbC9pc09iamVjdExpa2UuanNcbiAqKiBtb2R1bGUgaWQgPSA0NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4uL2ludGVybmFsL2dldE5hdGl2ZScpLFxuICAgIGlzTGVuZ3RoID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvaXNMZW5ndGgnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9pc09iamVjdExpa2UnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFycmF5VGFnID0gJ1tvYmplY3QgQXJyYXldJztcblxuLyoqIFVzZWQgZm9yIG5hdGl2ZSBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZSBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG9ialRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qIE5hdGl2ZSBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlSXNBcnJheSA9IGdldE5hdGl2ZShBcnJheSwgJ2lzQXJyYXknKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGFuIGBBcnJheWAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBjb3JyZWN0bHkgY2xhc3NpZmllZCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXkoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXkoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNBcnJheSA9IG5hdGl2ZUlzQXJyYXkgfHwgZnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiBvYmpUb1N0cmluZy5jYWxsKHZhbHVlKSA9PSBhcnJheVRhZztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gaXNBcnJheTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2xvZGFzaC9sYW5nL2lzQXJyYXkuanNcbiAqKiBtb2R1bGUgaWQgPSA0NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGlzTmF0aXZlID0gcmVxdWlyZSgnLi4vbGFuZy9pc05hdGl2ZScpO1xuXG4vKipcbiAqIEdldHMgdGhlIG5hdGl2ZSBmdW5jdGlvbiBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBtZXRob2QgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGZ1bmN0aW9uIGlmIGl0J3MgbmF0aXZlLCBlbHNlIGB1bmRlZmluZWRgLlxuICovXG5mdW5jdGlvbiBnZXROYXRpdmUob2JqZWN0LCBrZXkpIHtcbiAgdmFyIHZhbHVlID0gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcbiAgcmV0dXJuIGlzTmF0aXZlKHZhbHVlKSA/IHZhbHVlIDogdW5kZWZpbmVkO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldE5hdGl2ZTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2xvZGFzaC9pbnRlcm5hbC9nZXROYXRpdmUuanNcbiAqKiBtb2R1bGUgaWQgPSA0NlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGlzRnVuY3Rpb24gPSByZXF1aXJlKCcuL2lzRnVuY3Rpb24nKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9pc09iamVjdExpa2UnKTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGhvc3QgY29uc3RydWN0b3JzIChTYWZhcmkgPiA1KS4gKi9cbnZhciByZUlzSG9zdEN0b3IgPSAvXlxcW29iamVjdCAuKz9Db25zdHJ1Y3RvclxcXSQvO1xuXG4vKiogVXNlZCBmb3IgbmF0aXZlIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xudmFyIGZuVG9TdHJpbmcgPSBGdW5jdGlvbi5wcm90b3R5cGUudG9TdHJpbmc7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBpZiBhIG1ldGhvZCBpcyBuYXRpdmUuICovXG52YXIgcmVJc05hdGl2ZSA9IFJlZ0V4cCgnXicgK1xuICBmblRvU3RyaW5nLmNhbGwoaGFzT3duUHJvcGVydHkpLnJlcGxhY2UoL1tcXFxcXiQuKis/KClbXFxde318XS9nLCAnXFxcXCQmJylcbiAgLnJlcGxhY2UoL2hhc093blByb3BlcnR5fChmdW5jdGlvbikuKj8oPz1cXFxcXFwoKXwgZm9yIC4rPyg/PVxcXFxcXF0pL2csICckMS4qPycpICsgJyQnXG4pO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgbmF0aXZlIGZ1bmN0aW9uLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG5hdGl2ZSBmdW5jdGlvbiwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzTmF0aXZlKEFycmF5LnByb3RvdHlwZS5wdXNoKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzTmF0aXZlKF8pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNOYXRpdmUodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgcmV0dXJuIHJlSXNOYXRpdmUudGVzdChmblRvU3RyaW5nLmNhbGwodmFsdWUpKTtcbiAgfVxuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiByZUlzSG9zdEN0b3IudGVzdCh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNOYXRpdmU7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9sb2Rhc2gvbGFuZy9pc05hdGl2ZS5qc1xuICoqIG1vZHVsZSBpZCA9IDQ3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0Jyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJztcblxuLyoqIFVzZWQgZm9yIG5hdGl2ZSBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZSBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG9ialRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBGdW5jdGlvbmAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBjb3JyZWN0bHkgY2xhc3NpZmllZCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oXyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0Z1bmN0aW9uKC9hYmMvKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgLy8gVGhlIHVzZSBvZiBgT2JqZWN0I3RvU3RyaW5nYCBhdm9pZHMgaXNzdWVzIHdpdGggdGhlIGB0eXBlb2ZgIG9wZXJhdG9yXG4gIC8vIGluIG9sZGVyIHZlcnNpb25zIG9mIENocm9tZSBhbmQgU2FmYXJpIHdoaWNoIHJldHVybiAnZnVuY3Rpb24nIGZvciByZWdleGVzXG4gIC8vIGFuZCBTYWZhcmkgOCB3aGljaCByZXR1cm5zICdvYmplY3QnIGZvciB0eXBlZCBhcnJheSBjb25zdHJ1Y3RvcnMuXG4gIHJldHVybiBpc09iamVjdCh2YWx1ZSkgJiYgb2JqVG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gZnVuY1RhZztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0Z1bmN0aW9uO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vbG9kYXNoL2xhbmcvaXNGdW5jdGlvbi5qc1xuICoqIG1vZHVsZSBpZCA9IDQ4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHRoZSBbbGFuZ3VhZ2UgdHlwZV0oaHR0cHM6Ly9lczUuZ2l0aHViLmlvLyN4OCkgb2YgYE9iamVjdGAuXG4gKiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3Qoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KDEpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgLy8gQXZvaWQgYSBWOCBKSVQgYnVnIGluIENocm9tZSAxOS0yMC5cbiAgLy8gU2VlIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0yMjkxIGZvciBtb3JlIGRldGFpbHMuXG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gISF2YWx1ZSAmJiAodHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdmdW5jdGlvbicpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzT2JqZWN0O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vbG9kYXNoL2xhbmcvaXNPYmplY3QuanNcbiAqKiBtb2R1bGUgaWQgPSA0OVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBVc2VkIGFzIHRoZSBbbWF4aW11bSBsZW5ndGhdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLW51bWJlci5tYXhfc2FmZV9pbnRlZ2VyKVxuICogb2YgYW4gYXJyYXktbGlrZSB2YWx1ZS5cbiAqL1xudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBsZW5ndGguXG4gKlxuICogKipOb3RlOioqIFRoaXMgZnVuY3Rpb24gaXMgYmFzZWQgb24gW2BUb0xlbmd0aGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLXRvbGVuZ3RoKS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGxlbmd0aCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0xlbmd0aCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInICYmIHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPD0gTUFYX1NBRkVfSU5URUdFUjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0xlbmd0aDtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2xvZGFzaC9pbnRlcm5hbC9pc0xlbmd0aC5qc1xuICoqIG1vZHVsZSBpZCA9IDUwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIEBjb3B5cmlnaHQgMjAxNSwgUHJvbWV0aGV1cyBSZXNlYXJjaCwgTExDXG4gKi9cblxuaW1wb3J0IGF1dG9iaW5kIGZyb20gJ2F1dG9iaW5kLWRlY29yYXRvcic7XG5pbXBvcnQgUmVhY3QsIHtQcm9wVHlwZXN9IGZyb20gJ3JlYWN0JztcbmltcG9ydCAqIGFzIFJlYWN0U3R5bGVzaGVldCBmcm9tICdyZWFjdC1zdHlsZXNoZWV0JztcbmltcG9ydCBDb21wb25lbnQgZnJvbSAnLi9Db21wb25lbnQnO1xuaW1wb3J0IElucHV0IGZyb20gJy4vSW5wdXQnO1xuaW1wb3J0IEVycm9yTGlzdCBmcm9tICcuL0Vycm9yTGlzdCc7XG5pbXBvcnQgTGFiZWwgZnJvbSAnLi9MYWJlbCc7XG5cbkBSZWFjdFN0eWxlc2hlZXQuc3R5bGVhYmxlXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBGaWVsZCBleHRlbmRzIENvbXBvbmVudCB7XG5cbiAgc3RhdGljIHByb3BUeXBlcyA9IHtcbiAgICAuLi5Db21wb25lbnQucHJvcFR5cGVzLFxuICAgIGxhYmVsOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgIGNoaWxkcmVuOiBQcm9wVHlwZXMuZWxlbWVudCxcbiAgICBJbnB1dDogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLnN0cmluZywgUHJvcFR5cGVzLmZ1bmNdKSxcbiAgfTtcblxuICBzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuICAgIElucHV0LFxuICB9O1xuXG4gIHN0YXRpYyBzdHlsZXNoZWV0ID0gUmVhY3RTdHlsZXNoZWV0LmNyZWF0ZVN0eWxlc2hlZXQoe1xuICAgIFJvb3Q6ICdkaXYnLFxuICAgIEVycm9yTGlzdDogRXJyb3JMaXN0LFxuICAgIExhYmVsOiBMYWJlbCxcbiAgICBJbnB1dFdyYXBwZXI6ICdkaXYnLFxuICB9KTtcblxuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgIHN1cGVyKHByb3BzKTtcbiAgICB0aGlzLnN0YXRlID0ge2RpcnR5OiBmYWxzZX07XG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgbGV0IHtJbnB1dCwgbGFiZWwsIGNoaWxkcmVufSA9IHRoaXMucHJvcHM7XG4gICAgbGV0IHtSb290LCBFcnJvckxpc3QsIExhYmVsLCBJbnB1dFdyYXBwZXJ9ID0gdGhpcy5zdHlsZXNoZWV0O1xuICAgIGxldCB7ZGlydHl9ID0gdGhpcy5zdGF0ZTtcbiAgICBsZXQge3NjaGVtYSA9IHt9LCB2YWx1ZSwgcGFyYW1zID0ge319ID0gdGhpcy5mb3JtVmFsdWU7XG4gICAgbGV0IHNob3dFcnJvcnMgPSBkaXJ0eSB8fCBwYXJhbXMuZm9yY2VTaG93RXJyb3JzO1xuICAgIGlmICghY2hpbGRyZW4pIHtcbiAgICAgIGNoaWxkcmVuID0gPElucHV0IHZhbHVlPXt2YWx1ZX0gb25DaGFuZ2U9e3RoaXMub25DaGFuZ2V9IC8+O1xuICAgIH0gZWxzZSB7XG4gICAgICBjaGlsZHJlbiA9IFJlYWN0LmNsb25lRWxlbWVudChcbiAgICAgICAgUmVhY3QuQ2hpbGRyZW4ub25seShjaGlsZHJlbiksXG4gICAgICAgIHt2YWx1ZSwgb25DaGFuZ2U6IHRoaXMub25DaGFuZ2V9KTtcbiAgICB9XG4gICAgcmV0dXJuIChcbiAgICAgIDxSb290IG9uQmx1cj17dGhpcy5vbkJsdXJ9PlxuICAgICAgICA8TGFiZWwgbGFiZWw9e2xhYmVsfSBzY2hlbWE9e3NjaGVtYX0gLz5cbiAgICAgICAgPElucHV0V3JhcHBlcj5cbiAgICAgICAgICB7Y2hpbGRyZW59XG4gICAgICAgIDwvSW5wdXRXcmFwcGVyPlxuICAgICAgICB7c2hvd0Vycm9ycyAmJlxuICAgICAgICAgIDxFcnJvckxpc3QgZm9ybVZhbHVlPXt0aGlzLmZvcm1WYWx1ZX0gLz59XG4gICAgICA8L1Jvb3Q+XG4gICAgKTtcbiAgfVxuXG4gIEBhdXRvYmluZFxuICBvbkJsdXIoKSB7XG4gICAgdGhpcy5zZXRTdGF0ZSh7ZGlydHk6IHRydWV9KTtcbiAgfVxuXG4gIEBhdXRvYmluZFxuICBvbkNoYW5nZShlKSB7XG4gICAgbGV0IHZhbHVlO1xuICAgIGlmIChlICYmIGUudGFyZ2V0ICYmIGUudGFyZ2V0LnZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICB2YWx1ZSA9IGUudGFyZ2V0LnZhbHVlO1xuICAgICAgaWYgKHZhbHVlID09PSAnJykge1xuICAgICAgICB2YWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgPSBlO1xuICAgIH1cbiAgICB0aGlzLnNldFN0YXRlKHtkaXJ0eTogdHJ1ZX0pO1xuICAgIHRoaXMuZm9ybVZhbHVlLnVwZGF0ZSh2YWx1ZSk7XG4gIH1cbn1cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL0ZpZWxkLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbi8qKlxuICogQGNvcHlyaWdodCAyMDE1LCBBbmRyZXkgUG9wcCA8OG1heWRheUBnbWFpbC5jb20+XG4gKlxuICogVGhlIGRlY29yYXRvciBtYXkgYmUgdXNlZCBvbiBjbGFzc2VzIG9yIG1ldGhvZHNcbiAqIGBgYFxuICogQGF1dG9iaW5kXG4gKiBjbGFzcyBGdWxsQm91bmQge31cbiAqXG4gKiBjbGFzcyBQYXJ0Qm91bmQge1xuICogICBAYXV0b2JpbmRcbiAqICAgbWV0aG9kICgpIHt9XG4gKiB9XG4gKiBgYGBcbiAqL1xuZXhwb3J0c1snZGVmYXVsdCddID0gYXV0b2JpbmQ7XG5cbmZ1bmN0aW9uIGF1dG9iaW5kKCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICBpZiAoYXJncy5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gYm91bmRDbGFzcy5hcHBseSh1bmRlZmluZWQsIGFyZ3MpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBib3VuZE1ldGhvZC5hcHBseSh1bmRlZmluZWQsIGFyZ3MpO1xuICB9XG59XG5cbi8qKlxuICogVXNlIGJvdW5kTWV0aG9kIHRvIGJpbmQgYWxsIG1ldGhvZHMgb24gdGhlIHRhcmdldC5wcm90b3R5cGVcbiAqL1xuZnVuY3Rpb24gYm91bmRDbGFzcyh0YXJnZXQpIHtcbiAgLy8gKFVzaW5nIHJlZmxlY3QgdG8gZ2V0IGFsbCBrZXlzIGluY2x1ZGluZyBzeW1ib2xzKVxuICB2YXIga2V5cyA9IHVuZGVmaW5lZDtcbiAgLy8gVXNlIFJlZmxlY3QgaWYgZXhpc3RzXG4gIGlmICh0eXBlb2YgUmVmbGVjdCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBrZXlzID0gUmVmbGVjdC5vd25LZXlzKHRhcmdldC5wcm90b3R5cGUpO1xuICB9IGVsc2Uge1xuICAgIGtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0YXJnZXQucHJvdG90eXBlKTtcbiAgICAvLyB1c2Ugc3ltYm9scyBpZiBzdXBwb3J0IGlzIHByb3ZpZGVkXG4gICAgaWYgKHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBrZXlzID0ga2V5cy5jb25jYXQoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyh0YXJnZXQucHJvdG90eXBlKSk7XG4gICAgfVxuICB9XG5cbiAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAvLyBJZ25vcmUgc3BlY2lhbCBjYXNlIHRhcmdldCBtZXRob2RcbiAgICBpZiAoa2V5ID09PSAnY29uc3RydWN0b3InKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGRlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldC5wcm90b3R5cGUsIGtleSk7XG5cbiAgICAvLyBPbmx5IG1ldGhvZHMgbmVlZCBiaW5kaW5nXG4gICAgaWYgKHR5cGVvZiBkZXNjcmlwdG9yLnZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LnByb3RvdHlwZSwga2V5LCBib3VuZE1ldGhvZCh0YXJnZXQsIGtleSwgZGVzY3JpcHRvcikpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbi8qKlxuICogUmV0dXJuIGEgZGVzY3JpcHRvciByZW1vdmluZyB0aGUgdmFsdWUgYW5kIHJldHVybmluZyBhIGdldHRlclxuICogVGhlIGdldHRlciB3aWxsIHJldHVybiBhIC5iaW5kIHZlcnNpb24gb2YgdGhlIGZ1bmN0aW9uXG4gKiBhbmQgbWVtb2l6ZSB0aGUgcmVzdWx0IGFnYWluc3QgYSBzeW1ib2wgb24gdGhlIGluc3RhbmNlXG4gKi9cbmZ1bmN0aW9uIGJvdW5kTWV0aG9kKHRhcmdldCwga2V5LCBkZXNjcmlwdG9yKSB7XG4gIHZhciBmbiA9IGRlc2NyaXB0b3IudmFsdWU7XG5cbiAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBFcnJvcignQGF1dG9iaW5kIGRlY29yYXRvciBjYW4gb25seSBiZSBhcHBsaWVkIHRvIG1ldGhvZHMgbm90OiAnICsgdHlwZW9mIGZuKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgaWYgKHRoaXMgPT09IHRhcmdldC5wcm90b3R5cGUpIHtcbiAgICAgICAgcmV0dXJuIGZuO1xuICAgICAgfVxuXG4gICAgICB2YXIgYm91bmRGbiA9IGZuLmJpbmQodGhpcyk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywga2V5LCB7XG4gICAgICAgIHZhbHVlOiBib3VuZEZuLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBib3VuZEZuO1xuICAgIH1cbiAgfTtcbn1cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYXV0b2JpbmQtZGVjb3JhdG9yL2xpYi9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDUyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIEBjb3B5cmlnaHQgMjAxNSwgUHJvbWV0aGV1cyBSZXNlYXJjaCwgTExDXG4gKi9cblxuaW1wb3J0IGF1dG9iaW5kICAgICAgICAgICBmcm9tICdhdXRvYmluZC1kZWNvcmF0b3InO1xuaW1wb3J0IFJlYWN0LCB7UHJvcFR5cGVzfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgZGVib3VuY2UgICAgICAgICAgIGZyb20gJ2xvZGFzaC9mdW5jdGlvbi9kZWJvdW5jZSc7XG5pbXBvcnQgZW1wdHlGdW5jdGlvbiAgICAgIGZyb20gJ2VtcHR5L2Z1bmN0aW9uJztcblxuLyoqXG4gKiBJbnB1dCBjb21wb25lbnQgd2l0aCBkZWJvdW5jZS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSW5wdXQgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuXG4gIHN0YXRpYyBwcm9wVHlwZXMgPSB7XG4gICAgQ29tcG9uZW50OiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuc3RyaW5nLCBQcm9wVHlwZXMuZnVuY10pLFxuICAgIGRlYm91bmNlOiBQcm9wVHlwZXMubnVtYmVyLFxuICAgIHZhbHVlOiBQcm9wVHlwZXMuYW55LFxuICAgIG9uQ2hhbmdlOiBQcm9wVHlwZXMuZnVuY1xuICB9O1xuXG4gIHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG4gICAgQ29tcG9uZW50OiAnaW5wdXQnLFxuICAgIGRlYm91bmNlOiAxMDAsXG4gICAgb25DaGFuZ2U6IGVtcHR5RnVuY3Rpb25cbiAgfTtcblxuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgIHN1cGVyKHByb3BzKTtcbiAgICB0aGlzLnN0YXRlID0ge3ZhbHVlOiBwcm9wcy52YWx1ZX07XG4gICAgdGhpcy5fZXhwZWN0ZWRWYWx1ZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9maW5hbGl6ZU9uQ2hhbmdlRGVib3VuY2VkID0gcHJvcHMuZGVib3VuY2UgP1xuICAgICAgZGVib3VuY2UodGhpcy5fZmluYWxpemVPbkNoYW5nZS5iaW5kKHRoaXMpLCBwcm9wcy5kZWJvdW5jZSkgOlxuICAgICAgdGhpcy5fZmluYWxpemVPbkNoYW5nZS5iaW5kKHRoaXMpO1xuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIGxldCB7Q29tcG9uZW50LCBkZWJvdW5jZTogZGVib3VuY2VFbmFibGVkLCB2YWx1ZSwgLi4ucHJvcHN9ID0gdGhpcy5wcm9wcztcbiAgICBpZiAoZGVib3VuY2VFbmFibGVkKSB7XG4gICAgICB2YWx1ZSA9IHRoaXMuc3RhdGUudmFsdWU7XG4gICAgfVxuICAgIHJldHVybiAoXG4gICAgICA8Q29tcG9uZW50XG4gICAgICAgIHsuLi5wcm9wc31cbiAgICAgICAgdmFsdWU9e3ZhbHVlfVxuICAgICAgICBvbkNoYW5nZT17dGhpcy5vbkNoYW5nZX1cbiAgICAgICAgb25CbHVyPXt0aGlzLm9uQmx1cn0gLz5cbiAgICApO1xuICB9XG5cbiAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpIHtcbiAgICBpZiAobmV4dFByb3BzLnZhbHVlICE9PSB0aGlzLl9leHBlY3RlZFZhbHVlKSB7XG4gICAgICB0aGlzLl9jYW5jZWxPbkNoYW5nZSgpO1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7dmFsdWU6IG5leHRQcm9wcy52YWx1ZX0pO1xuICAgIH1cbiAgICBpZiAobmV4dFByb3BzLmRlYm91bmNlICE9PSB0aGlzLnByb3BzLmRlYm91bmNlKSB7XG4gICAgICB0aGlzLl9maW5hbGl6ZU9uQ2hhbmdlKCk7XG4gICAgICB0aGlzLl9jYW5jZWxPbkNoYW5nZSgpO1xuICAgICAgdGhpcy5fZmluYWxpemVPbkNoYW5nZURlYm91bmNlZCA9IG5leHRQcm9wcy5kZWJvdW5jZSA/XG4gICAgICAgIGRlYm91bmNlKHRoaXMuX2ZpbmFsaXplT25DaGFuZ2UuYmluZCh0aGlzKSwgbmV4dFByb3BzLmRlYm91bmNlKSA6XG4gICAgICAgIHRoaXMuX2ZpbmFsaXplT25DaGFuZ2UuYmluZCh0aGlzKTtcbiAgICB9XG4gIH1cblxuICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICB0aGlzLl9maW5hbGl6ZU9uQ2hhbmdlKCk7XG4gICAgdGhpcy5fY2FuY2VsT25DaGFuZ2UoKTtcbiAgfVxuXG4gIF9zY2hlZHVsZU9uQ2hhbmdlKHZhbHVlKSB7XG4gICAgdGhpcy5zZXRTdGF0ZSh7dmFsdWV9KTtcbiAgICB0aGlzLl9leHBlY3RlZFZhbHVlID0gdmFsdWU7XG4gICAgdGhpcy5fZmluYWxpemVPbkNoYW5nZURlYm91bmNlZCgpO1xuICB9XG5cbiAgX2ZpbmFsaXplT25DaGFuZ2UoKSB7XG4gICAgaWYgKHRoaXMuX2V4cGVjdGVkVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgbGV0IHZhbHVlID0gdGhpcy5fZXhwZWN0ZWRWYWx1ZTtcbiAgICAgIHRoaXMuX2V4cGVjdGVkVmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLnByb3BzLm9uQ2hhbmdlKHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICBfY2FuY2VsT25DaGFuZ2UoKSB7XG4gICAgaWYgKHRoaXMuX2ZpbmFsaXplT25DaGFuZ2VEZWJvdW5jZWQuY2FuY2VsKSB7XG4gICAgICB0aGlzLl9leHBlY3RlZFZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5fZmluYWxpemVPbkNoYW5nZURlYm91bmNlZC5jYW5jZWwoKTtcbiAgICB9XG4gIH1cblxuICBAYXV0b2JpbmRcbiAgb25DaGFuZ2UoZSkge1xuICAgIGxldCB2YWx1ZSA9IGUgJiYgZS50YXJnZXQgJiYgJ3ZhbHVlJyBpbiBlLnRhcmdldCA/XG4gICAgICBlLnRhcmdldC52YWx1ZSA6XG4gICAgICBlO1xuICAgIHRoaXMuX3NjaGVkdWxlT25DaGFuZ2UodmFsdWUpO1xuICB9XG5cbiAgQGF1dG9iaW5kXG4gIG9uQmx1cigpIHtcbiAgICBpZiAodGhpcy5fZXhwZWN0ZWRWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLl9maW5hbGl6ZU9uQ2hhbmdlKCk7XG4gICAgICB0aGlzLl9jYW5jZWxPbkNoYW5nZSgpO1xuICAgIH1cbiAgfVxuXG59XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9JbnB1dC5qc1xuICoqLyIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4uL2xhbmcvaXNPYmplY3QnKSxcbiAgICBub3cgPSByZXF1aXJlKCcuLi9kYXRlL25vdycpO1xuXG4vKiogVXNlZCBhcyB0aGUgYFR5cGVFcnJvcmAgbWVzc2FnZSBmb3IgXCJGdW5jdGlvbnNcIiBtZXRob2RzLiAqL1xudmFyIEZVTkNfRVJST1JfVEVYVCA9ICdFeHBlY3RlZCBhIGZ1bmN0aW9uJztcblxuLyogTmF0aXZlIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVNYXggPSBNYXRoLm1heDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgZGVib3VuY2VkIGZ1bmN0aW9uIHRoYXQgZGVsYXlzIGludm9raW5nIGBmdW5jYCB1bnRpbCBhZnRlciBgd2FpdGBcbiAqIG1pbGxpc2Vjb25kcyBoYXZlIGVsYXBzZWQgc2luY2UgdGhlIGxhc3QgdGltZSB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uIHdhc1xuICogaW52b2tlZC4gVGhlIGRlYm91bmNlZCBmdW5jdGlvbiBjb21lcyB3aXRoIGEgYGNhbmNlbGAgbWV0aG9kIHRvIGNhbmNlbFxuICogZGVsYXllZCBpbnZvY2F0aW9ucy4gUHJvdmlkZSBhbiBvcHRpb25zIG9iamVjdCB0byBpbmRpY2F0ZSB0aGF0IGBmdW5jYFxuICogc2hvdWxkIGJlIGludm9rZWQgb24gdGhlIGxlYWRpbmcgYW5kL29yIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIGB3YWl0YCB0aW1lb3V0LlxuICogU3Vic2VxdWVudCBjYWxscyB0byB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uIHJldHVybiB0aGUgcmVzdWx0IG9mIHRoZSBsYXN0XG4gKiBgZnVuY2AgaW52b2NhdGlvbi5cbiAqXG4gKiAqKk5vdGU6KiogSWYgYGxlYWRpbmdgIGFuZCBgdHJhaWxpbmdgIG9wdGlvbnMgYXJlIGB0cnVlYCwgYGZ1bmNgIGlzIGludm9rZWRcbiAqIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0IG9ubHkgaWYgdGhlIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb24gaXNcbiAqIGludm9rZWQgbW9yZSB0aGFuIG9uY2UgZHVyaW5nIHRoZSBgd2FpdGAgdGltZW91dC5cbiAqXG4gKiBTZWUgW0RhdmlkIENvcmJhY2hvJ3MgYXJ0aWNsZV0oaHR0cDovL2RydXBhbG1vdGlvbi5jb20vYXJ0aWNsZS9kZWJvdW5jZS1hbmQtdGhyb3R0bGUtdmlzdWFsLWV4cGxhbmF0aW9uKVxuICogZm9yIGRldGFpbHMgb3ZlciB0aGUgZGlmZmVyZW5jZXMgYmV0d2VlbiBgXy5kZWJvdW5jZWAgYW5kIGBfLnRocm90dGxlYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBkZWJvdW5jZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbd2FpdD0wXSBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byBkZWxheS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gVGhlIG9wdGlvbnMgb2JqZWN0LlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5sZWFkaW5nPWZhbHNlXSBTcGVjaWZ5IGludm9raW5nIG9uIHRoZSBsZWFkaW5nXG4gKiAgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5tYXhXYWl0XSBUaGUgbWF4aW11bSB0aW1lIGBmdW5jYCBpcyBhbGxvd2VkIHRvIGJlXG4gKiAgZGVsYXllZCBiZWZvcmUgaXQncyBpbnZva2VkLlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy50cmFpbGluZz10cnVlXSBTcGVjaWZ5IGludm9raW5nIG9uIHRoZSB0cmFpbGluZ1xuICogIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBkZWJvdW5jZWQgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIC8vIGF2b2lkIGNvc3RseSBjYWxjdWxhdGlvbnMgd2hpbGUgdGhlIHdpbmRvdyBzaXplIGlzIGluIGZsdXhcbiAqIGpRdWVyeSh3aW5kb3cpLm9uKCdyZXNpemUnLCBfLmRlYm91bmNlKGNhbGN1bGF0ZUxheW91dCwgMTUwKSk7XG4gKlxuICogLy8gaW52b2tlIGBzZW5kTWFpbGAgd2hlbiB0aGUgY2xpY2sgZXZlbnQgaXMgZmlyZWQsIGRlYm91bmNpbmcgc3Vic2VxdWVudCBjYWxsc1xuICogalF1ZXJ5KCcjcG9zdGJveCcpLm9uKCdjbGljaycsIF8uZGVib3VuY2Uoc2VuZE1haWwsIDMwMCwge1xuICogICAnbGVhZGluZyc6IHRydWUsXG4gKiAgICd0cmFpbGluZyc6IGZhbHNlXG4gKiB9KSk7XG4gKlxuICogLy8gZW5zdXJlIGBiYXRjaExvZ2AgaXMgaW52b2tlZCBvbmNlIGFmdGVyIDEgc2Vjb25kIG9mIGRlYm91bmNlZCBjYWxsc1xuICogdmFyIHNvdXJjZSA9IG5ldyBFdmVudFNvdXJjZSgnL3N0cmVhbScpO1xuICogalF1ZXJ5KHNvdXJjZSkub24oJ21lc3NhZ2UnLCBfLmRlYm91bmNlKGJhdGNoTG9nLCAyNTAsIHtcbiAqICAgJ21heFdhaXQnOiAxMDAwXG4gKiB9KSk7XG4gKlxuICogLy8gY2FuY2VsIGEgZGVib3VuY2VkIGNhbGxcbiAqIHZhciB0b2RvQ2hhbmdlcyA9IF8uZGVib3VuY2UoYmF0Y2hMb2csIDEwMDApO1xuICogT2JqZWN0Lm9ic2VydmUobW9kZWxzLnRvZG8sIHRvZG9DaGFuZ2VzKTtcbiAqXG4gKiBPYmplY3Qub2JzZXJ2ZShtb2RlbHMsIGZ1bmN0aW9uKGNoYW5nZXMpIHtcbiAqICAgaWYgKF8uZmluZChjaGFuZ2VzLCB7ICd1c2VyJzogJ3RvZG8nLCAndHlwZSc6ICdkZWxldGUnfSkpIHtcbiAqICAgICB0b2RvQ2hhbmdlcy5jYW5jZWwoKTtcbiAqICAgfVxuICogfSwgWydkZWxldGUnXSk7XG4gKlxuICogLy8gLi4uYXQgc29tZSBwb2ludCBgbW9kZWxzLnRvZG9gIGlzIGNoYW5nZWRcbiAqIG1vZGVscy50b2RvLmNvbXBsZXRlZCA9IHRydWU7XG4gKlxuICogLy8gLi4uYmVmb3JlIDEgc2Vjb25kIGhhcyBwYXNzZWQgYG1vZGVscy50b2RvYCBpcyBkZWxldGVkXG4gKiAvLyB3aGljaCBjYW5jZWxzIHRoZSBkZWJvdW5jZWQgYHRvZG9DaGFuZ2VzYCBjYWxsXG4gKiBkZWxldGUgbW9kZWxzLnRvZG87XG4gKi9cbmZ1bmN0aW9uIGRlYm91bmNlKGZ1bmMsIHdhaXQsIG9wdGlvbnMpIHtcbiAgdmFyIGFyZ3MsXG4gICAgICBtYXhUaW1lb3V0SWQsXG4gICAgICByZXN1bHQsXG4gICAgICBzdGFtcCxcbiAgICAgIHRoaXNBcmcsXG4gICAgICB0aW1lb3V0SWQsXG4gICAgICB0cmFpbGluZ0NhbGwsXG4gICAgICBsYXN0Q2FsbGVkID0gMCxcbiAgICAgIG1heFdhaXQgPSBmYWxzZSxcbiAgICAgIHRyYWlsaW5nID0gdHJ1ZTtcblxuICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgfVxuICB3YWl0ID0gd2FpdCA8IDAgPyAwIDogKCt3YWl0IHx8IDApO1xuICBpZiAob3B0aW9ucyA9PT0gdHJ1ZSkge1xuICAgIHZhciBsZWFkaW5nID0gdHJ1ZTtcbiAgICB0cmFpbGluZyA9IGZhbHNlO1xuICB9IGVsc2UgaWYgKGlzT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgbGVhZGluZyA9ICEhb3B0aW9ucy5sZWFkaW5nO1xuICAgIG1heFdhaXQgPSAnbWF4V2FpdCcgaW4gb3B0aW9ucyAmJiBuYXRpdmVNYXgoK29wdGlvbnMubWF4V2FpdCB8fCAwLCB3YWl0KTtcbiAgICB0cmFpbGluZyA9ICd0cmFpbGluZycgaW4gb3B0aW9ucyA/ICEhb3B0aW9ucy50cmFpbGluZyA6IHRyYWlsaW5nO1xuICB9XG5cbiAgZnVuY3Rpb24gY2FuY2VsKCkge1xuICAgIGlmICh0aW1lb3V0SWQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgIH1cbiAgICBpZiAobWF4VGltZW91dElkKSB7XG4gICAgICBjbGVhclRpbWVvdXQobWF4VGltZW91dElkKTtcbiAgICB9XG4gICAgbGFzdENhbGxlZCA9IDA7XG4gICAgbWF4VGltZW91dElkID0gdGltZW91dElkID0gdHJhaWxpbmdDYWxsID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgZnVuY3Rpb24gY29tcGxldGUoaXNDYWxsZWQsIGlkKSB7XG4gICAgaWYgKGlkKSB7XG4gICAgICBjbGVhclRpbWVvdXQoaWQpO1xuICAgIH1cbiAgICBtYXhUaW1lb3V0SWQgPSB0aW1lb3V0SWQgPSB0cmFpbGluZ0NhbGwgPSB1bmRlZmluZWQ7XG4gICAgaWYgKGlzQ2FsbGVkKSB7XG4gICAgICBsYXN0Q2FsbGVkID0gbm93KCk7XG4gICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuICAgICAgaWYgKCF0aW1lb3V0SWQgJiYgIW1heFRpbWVvdXRJZCkge1xuICAgICAgICBhcmdzID0gdGhpc0FyZyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBkZWxheWVkKCkge1xuICAgIHZhciByZW1haW5pbmcgPSB3YWl0IC0gKG5vdygpIC0gc3RhbXApO1xuICAgIGlmIChyZW1haW5pbmcgPD0gMCB8fCByZW1haW5pbmcgPiB3YWl0KSB7XG4gICAgICBjb21wbGV0ZSh0cmFpbGluZ0NhbGwsIG1heFRpbWVvdXRJZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZGVsYXllZCwgcmVtYWluaW5nKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBtYXhEZWxheWVkKCkge1xuICAgIGNvbXBsZXRlKHRyYWlsaW5nLCB0aW1lb3V0SWQpO1xuICB9XG5cbiAgZnVuY3Rpb24gZGVib3VuY2VkKCkge1xuICAgIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgc3RhbXAgPSBub3coKTtcbiAgICB0aGlzQXJnID0gdGhpcztcbiAgICB0cmFpbGluZ0NhbGwgPSB0cmFpbGluZyAmJiAodGltZW91dElkIHx8ICFsZWFkaW5nKTtcblxuICAgIGlmIChtYXhXYWl0ID09PSBmYWxzZSkge1xuICAgICAgdmFyIGxlYWRpbmdDYWxsID0gbGVhZGluZyAmJiAhdGltZW91dElkO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIW1heFRpbWVvdXRJZCAmJiAhbGVhZGluZykge1xuICAgICAgICBsYXN0Q2FsbGVkID0gc3RhbXA7XG4gICAgICB9XG4gICAgICB2YXIgcmVtYWluaW5nID0gbWF4V2FpdCAtIChzdGFtcCAtIGxhc3RDYWxsZWQpLFxuICAgICAgICAgIGlzQ2FsbGVkID0gcmVtYWluaW5nIDw9IDAgfHwgcmVtYWluaW5nID4gbWF4V2FpdDtcblxuICAgICAgaWYgKGlzQ2FsbGVkKSB7XG4gICAgICAgIGlmIChtYXhUaW1lb3V0SWQpIHtcbiAgICAgICAgICBtYXhUaW1lb3V0SWQgPSBjbGVhclRpbWVvdXQobWF4VGltZW91dElkKTtcbiAgICAgICAgfVxuICAgICAgICBsYXN0Q2FsbGVkID0gc3RhbXA7XG4gICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpc0FyZywgYXJncyk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmICghbWF4VGltZW91dElkKSB7XG4gICAgICAgIG1heFRpbWVvdXRJZCA9IHNldFRpbWVvdXQobWF4RGVsYXllZCwgcmVtYWluaW5nKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzQ2FsbGVkICYmIHRpbWVvdXRJZCkge1xuICAgICAgdGltZW91dElkID0gY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCF0aW1lb3V0SWQgJiYgd2FpdCAhPT0gbWF4V2FpdCkge1xuICAgICAgdGltZW91dElkID0gc2V0VGltZW91dChkZWxheWVkLCB3YWl0KTtcbiAgICB9XG4gICAgaWYgKGxlYWRpbmdDYWxsKSB7XG4gICAgICBpc0NhbGxlZCA9IHRydWU7XG4gICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuICAgIH1cbiAgICBpZiAoaXNDYWxsZWQgJiYgIXRpbWVvdXRJZCAmJiAhbWF4VGltZW91dElkKSB7XG4gICAgICBhcmdzID0gdGhpc0FyZyA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBkZWJvdW5jZWQuY2FuY2VsID0gY2FuY2VsO1xuICByZXR1cm4gZGVib3VuY2VkO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGRlYm91bmNlO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vbG9kYXNoL2Z1bmN0aW9uL2RlYm91bmNlLmpzXG4gKiogbW9kdWxlIGlkID0gNTRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBnZXROYXRpdmUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9nZXROYXRpdmUnKTtcblxuLyogTmF0aXZlIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVOb3cgPSBnZXROYXRpdmUoRGF0ZSwgJ25vdycpO1xuXG4vKipcbiAqIEdldHMgdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdGhhdCBoYXZlIGVsYXBzZWQgc2luY2UgdGhlIFVuaXggZXBvY2hcbiAqICgxIEphbnVhcnkgMTk3MCAwMDowMDowMCBVVEMpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgRGF0ZVxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmRlZmVyKGZ1bmN0aW9uKHN0YW1wKSB7XG4gKiAgIGNvbnNvbGUubG9nKF8ubm93KCkgLSBzdGFtcCk7XG4gKiB9LCBfLm5vdygpKTtcbiAqIC8vID0+IGxvZ3MgdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgaXQgdG9vayBmb3IgdGhlIGRlZmVycmVkIGZ1bmN0aW9uIHRvIGJlIGludm9rZWRcbiAqL1xudmFyIG5vdyA9IG5hdGl2ZU5vdyB8fCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBub3c7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9sb2Rhc2gvZGF0ZS9ub3cuanNcbiAqKiBtb2R1bGUgaWQgPSA1NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHt9O1xuXG5pZiAoJ3Byb2R1Y3Rpb24nICE9IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gIE9iamVjdC5mcmVlemUobW9kdWxlLmV4cG9ydHMpO1xufVxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vZW1wdHkvZnVuY3Rpb24uanNcbiAqKiBtb2R1bGUgaWQgPSA1NlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBAY29weXJpZ2h0IDIwMTUsIFByb21ldGhldXMgUmVzZWFyY2gsIExMQ1xuICovXG5cbmltcG9ydCBSZWFjdCwge1Byb3BUeXBlc30gZnJvbSAncmVhY3QnO1xuaW1wb3J0ICogYXMgUmVhY3RTdHlsZXNoZWV0IGZyb20gJ3JlYWN0LXN0eWxlc2hlZXQnO1xuaW1wb3J0IENvbXBvbmVudCBmcm9tICcuL0NvbXBvbmVudCc7XG5pbXBvcnQgRXJyb3IgZnJvbSAnLi9FcnJvcic7XG5cbkBSZWFjdFN0eWxlc2hlZXQuc3R5bGVhYmxlXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFcnJvckxpc3QgZXh0ZW5kcyBDb21wb25lbnQge1xuXG4gIHN0YXRpYyBwcm9wVHlwZXMgPSB7XG4gICAgLi4uQ29tcG9uZW50LnByb3BUeXBlcyxcblxuICAgIC8qKlxuICAgICAqIElmIGNvbXBvbmVudCBzaG91bGQgcmVuZGVyIGVycm9ycyBmcm9tIGFsbCB0aGUgc3VidmFsdWVzLlxuICAgICAqL1xuICAgIGNvbXBsZXRlOiBQcm9wVHlwZXMuYm9vbCxcblxuICAgIC8qKlxuICAgICAqIFJlc3RyaWN0IHNjaGVtYSB0eXBlc1xuICAgICAqL1xuICAgIHNjaGVtYVR5cGU6IFByb3BUeXBlcy5vYmplY3QsXG5cbiAgICBub0xhYmVsOiBQcm9wVHlwZXMuYm9vbCxcblxuICAgIGxhYmVsOiBQcm9wVHlwZXMuc3RyaW5nXG4gIH07XG5cbiAgc3RhdGljIHN0eWxlc2hlZXQgPSBSZWFjdFN0eWxlc2hlZXQuY3JlYXRlU3R5bGVzaGVldCh7XG4gICAgRXJyb3I6IEVycm9yLFxuICAgIFJvb3Q6ICdkaXYnLFxuICB9KTtcblxuICByZW5kZXIoKSB7XG4gICAgbGV0IHtub0xhYmVsLCBjb21wbGV0ZSwgc2NoZW1hVHlwZSwgLi4ucHJvcHN9ID0gdGhpcy5wcm9wcztcbiAgICBsZXQge1Jvb3QsIEVycm9yfSA9IHRoaXMuc3R5bGVzaGVldDtcbiAgICBsZXQgZXJyb3JMaXN0ID0gY29tcGxldGUgP1xuICAgICAgdGhpcy5mb3JtVmFsdWUuY29tcGxldGVFcnJvckxpc3QgOlxuICAgICAgdGhpcy5mb3JtVmFsdWUuZXJyb3JMaXN0O1xuICAgIGlmIChzY2hlbWFUeXBlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGVycm9yTGlzdCA9IGVycm9yTGlzdC5maWx0ZXIoZXJyb3IgPT5cbiAgICAgICAgZXJyb3Iuc2NoZW1hID8gc2NoZW1hVHlwZVtlcnJvci5zY2hlbWEudHlwZV0gOiBzY2hlbWFUeXBlLm5vbmUpO1xuICAgIH1cbiAgICBpZiAoZXJyb3JMaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGxldCBpdGVtcyA9IGVycm9yTGlzdC5tYXAoKGVycm9yLCBpbmRleCkgPT5cbiAgICAgIDxFcnJvclxuICAgICAgICBrZXk9e2Vycm9yLmZpZWxkICsgJ19fJyArIGluZGV4fVxuICAgICAgICBlcnJvcj17ZXJyb3J9XG4gICAgICAgIG5vTGFiZWw9e25vTGFiZWx9XG4gICAgICAgIGNvbXBsZXRlPXtjb21wbGV0ZX1cbiAgICAgICAgLz5cbiAgICApO1xuICAgIHJldHVybiA8Um9vdCB7Li4ucHJvcHN9PntpdGVtc308L1Jvb3Q+O1xuICB9XG59XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9FcnJvckxpc3QuanNcbiAqKi8iLCIvKipcbiAqIEBjb3B5cmlnaHQgMjAxNSwgUHJvbWV0aGV1cyBSZXNlYXJjaCwgTExDXG4gKi9cblxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gRXJyb3Ioe2Vycm9yLCBsYWJlbCwgbm9MYWJlbCwgY29tcGxldGV9KSB7XG4gIGlmICghZXJyb3IpIHtcbiAgICByZXR1cm4gPG5vc2NyaXB0IC8+O1xuICB9XG4gIGlmICghbGFiZWwgJiYgZXJyb3Iuc2NoZW1hKSB7XG4gICAgbGFiZWwgPSBlcnJvci5zY2hlbWEubGFiZWw7XG4gIH1cbiAgaWYgKGxhYmVsICYmIGNvbXBsZXRlICYmICFub0xhYmVsKSB7XG4gICAgcmV0dXJuIDxkaXY+e2xhYmVsfToge2Vycm9yLm1lc3NhZ2V9PC9kaXY+O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiA8ZGl2PntlcnJvci5tZXNzYWdlfTwvZGl2PjtcbiAgfVxufVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvRXJyb3IuanNcbiAqKi8iLCIvKipcbiAqIEBjb3B5cmlnaHQgMjAxNSwgUHJvbWV0aGV1cyBSZXNlYXJjaCwgTExDXG4gKi9cblxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gTGFiZWwoe3NjaGVtYSA9IHt9LCBsYWJlbCA9IHNjaGVtYS5sYWJlbH0pIHtcbiAgcmV0dXJuIGxhYmVsID8gPGxhYmVsPntsYWJlbH08L2xhYmVsPiA6IDxub3NjcmlwdCAvPjtcbn1cblxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvTGFiZWwuanNcbiAqKi8iLCIvKipcbiAqIEBjb3B5cmlnaHQgMjAxNSwgUHJvbWV0aGV1cyBSZXNlYXJjaCwgTExDXG4gKi9cblxuaW1wb3J0IG1lbW9pemUgICAgICAgICAgICAgICAgICAgIGZyb20gJ21lbW9pemUtZGVjb3JhdG9yJztcbmltcG9ydCBzZWxlY3RWYWx1ZSAgICAgICAgICAgICAgICBmcm9tICdsb2Rhc2gvb2JqZWN0L2dldCc7XG5pbXBvcnQgZW1wdHlGdW5jdGlvbiAgICAgICAgICAgICAgZnJvbSAnZW1wdHkvZnVuY3Rpb24nO1xuaW1wb3J0IHVwZGF0ZSAgICAgICAgICAgICAgICAgICAgIGZyb20gJ2ltbXVwZGF0ZSc7XG5pbXBvcnQgbWFrZUtleVBhdGggICAgICAgICAgICAgICAgZnJvbSAnLi9rZXlQYXRoJztcbmltcG9ydCB7U2NoZW1hLFxuICAgICAgICBzZWxlY3QgYXMgc2VsZWN0U2NoZW1hfSAgIGZyb20gJy4vU2NoZW1hJztcblxuZXhwb3J0IGNsYXNzIFZhbHVlIHtcblxuICBzZWxlY3Qoa2V5KSB7XG4gICAgbGV0IGtleVBhdGggPSB0aGlzLmtleVBhdGguY29uY2F0KG1ha2VLZXlQYXRoKGtleSkpO1xuICAgIHJldHVybiBuZXcgVmFsdWVMZWFmKHRoaXMuX3Jvb3QsIGtleVBhdGgpO1xuICB9XG5cbiAgc2V0KHZhbHVlLCBxdWlldCkge1xuICAgIGNvbnNvbGUud2FybigvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnNvbGVcbiAgICAgICdWYWx1ZS5wcm90b3R5cGUuc2V0KHZhbHVlKSBpcyBkZXByZWNhdGVkLCAnICtcbiAgICAgICd1c2UgVmFsdWUucHJvdG90eXBlLnVwZGF0ZSh2YWx1ZSkgaW5zdGVhZCdcbiAgICApO1xuICAgIHJldHVybiB0aGlzLnVwZGF0ZSh2YWx1ZSwgcXVpZXQpO1xuICB9XG5cbiAgdXBkYXRlKHZhbHVlLCBxdWlldCkge1xuICAgIGxldCByb290VmFsdWU7XG4gICAgaWYgKHRoaXMua2V5UGF0aC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJvb3RWYWx1ZSA9IHZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByb290VmFsdWUgPSB1cGRhdGUodGhpcy5fcm9vdC52YWx1ZSwgdGhpcy5rZXlQYXRoLmpvaW4oJy4nKSwgdmFsdWUpO1xuICAgIH1cbiAgICBsZXQgbmV4dFJvb3QgPSBjcmVhdGVWYWx1ZShcbiAgICAgIHRoaXMuX3Jvb3Quc2NoZW1hLFxuICAgICAgcm9vdFZhbHVlLFxuICAgICAgdGhpcy5fcm9vdC5vbkNoYW5nZSxcbiAgICAgIHRoaXMuX3Jvb3QucGFyYW1zKTtcbiAgICBpZiAoIXF1aWV0KSB7XG4gICAgICB0aGlzLl9yb290Lm9uQ2hhbmdlKG5leHRSb290KTtcbiAgICB9XG4gICAgcmV0dXJuIG5leHRSb290O1xuICB9XG59XG5cbmNsYXNzIFZhbHVlUm9vdCBleHRlbmRzIFZhbHVlIHtcblxuICBrZXlQYXRoID0gW107XG4gIHBhcmVudCA9IG51bGw7XG5cbiAgY29uc3RydWN0b3Ioc2NoZW1hLCB2YWx1ZSwgb25DaGFuZ2UsIHBhcmFtcywgZXJyb3JMaXN0KSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLl9yb290ID0gdGhpcztcbiAgICB0aGlzLmtleVBhdGggPSBbXTtcbiAgICB0aGlzLnNjaGVtYSA9IHNjaGVtYTtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgdGhpcy5vbkNoYW5nZSA9IG9uQ2hhbmdlO1xuICAgIHRoaXMucGFyYW1zID0gcGFyYW1zO1xuICAgIHRoaXMuZXJyb3JMaXN0ID0gZXJyb3JMaXN0LmZpbHRlcihlcnJvciA9PiBlcnJvci5maWVsZCA9PT0gJ2RhdGEnKTtcbiAgICB0aGlzLmNvbXBsZXRlRXJyb3JMaXN0ID0gZXJyb3JMaXN0O1xuICB9XG59XG5cbmNsYXNzIFZhbHVlTGVhZiBleHRlbmRzIFZhbHVlIHtcblxuICBjb25zdHJ1Y3Rvcihyb290LCBrZXlQYXRoKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLl9yb290ID0gcm9vdDtcbiAgICB0aGlzLmtleVBhdGggPSBrZXlQYXRoO1xuICAgIHRoaXMuc2NoZW1hID0gc2VsZWN0U2NoZW1hKHJvb3Quc2NoZW1hLCBrZXlQYXRoKTtcbiAgICB0aGlzLnZhbHVlID0gc2VsZWN0VmFsdWUocm9vdC52YWx1ZSwga2V5UGF0aCk7XG4gIH1cblxuICBnZXQgcGFyYW1zKCkge1xuICAgIHJldHVybiB0aGlzLl9yb290LnBhcmFtcztcbiAgfVxuXG4gIEBtZW1vaXplXG4gIGdldCBlcnJvckxpc3QoKSB7XG4gICAgbGV0IGVycm9yS2V5UGF0aCA9IGBkYXRhLiR7dGhpcy5rZXlQYXRoLmpvaW4oJy4nKX1gO1xuICAgIHJldHVybiB0aGlzLl9yb290LmNvbXBsZXRlRXJyb3JMaXN0LmZpbHRlcihlcnJvciA9PiBlcnJvci5maWVsZCA9PT0gZXJyb3JLZXlQYXRoKTtcbiAgfVxuXG4gIEBtZW1vaXplXG4gIGdldCBjb21wbGV0ZUVycm9yTGlzdCgpIHtcbiAgICBsZXQgZXJyb3JLZXlQYXRoID0gYGRhdGEuJHt0aGlzLmtleVBhdGguam9pbignLicpfWA7XG4gICAgbGV0IGxlbmd0aCA9IGVycm9yS2V5UGF0aC5sZW5ndGg7XG4gICAgcmV0dXJuIHRoaXMuX3Jvb3QuY29tcGxldGVFcnJvckxpc3RcbiAgICAgIC5maWx0ZXIoZXJyb3IgPT4gZXJyb3IuZmllbGQuc2xpY2UoMCwgbGVuZ3RoKSA9PT0gZXJyb3JLZXlQYXRoKTtcbiAgfVxuXG4gIGdldCBwYXJlbnQoKSB7XG4gICAgaWYgKHRoaXMua2V5UGF0aC5sZW5ndGggPT09IDEpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yb290O1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQga2V5UGF0aCA9IHRoaXMua2V5UGF0aC5zbGljZSgpO1xuICAgICAga2V5UGF0aC5wb3AoKTtcbiAgICAgIHJldHVybiBuZXcgVmFsdWVMZWFmKFxuICAgICAgICB0aGlzLl9yb290LFxuICAgICAgICBrZXlQYXRoXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG59XG5cbmNvbnN0IE5PTl9FTlVNRVJBQkxFX1BST1AgPSB7XG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICB3cml0YWJsZTogdHJ1ZSxcbiAgY29uZmlndXJhYmxlOiB0cnVlXG59O1xuXG5mdW5jdGlvbiBjYWNoZShvYmosIGtleSwgdmFsdWUpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7Li4uTk9OX0VOVU1FUkFCTEVfUFJPUCwgdmFsdWV9KTtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGUoc2NoZW1hLCB2YWx1ZSkge1xuICBpZiAoIXNjaGVtYSkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBpZiAodmFsdWUuX19zY2hlbWEgPT09IHNjaGVtYSAmJiB2YWx1ZS5fX2Vycm9yTGlzdCkge1xuICAgIHJldHVybiB2YWx1ZS5fX2Vycm9yTGlzdDtcbiAgfSBlbHNlIHtcbiAgICBpZiAoc2NoZW1hLl9fdmFsaWRhdG9yID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGNhY2hlKHNjaGVtYSwgJ19fdmFsaWRhdG9yJywgU2NoZW1hKHNjaGVtYSwge2Zvcm1hdHM6IHNjaGVtYS5mb3JtYXRzfSkpO1xuICAgIH1cbiAgICBsZXQgZXJyb3JMaXN0ID0gc2NoZW1hLl9fdmFsaWRhdG9yKHZhbHVlKTtcbiAgICBjYWNoZSh2YWx1ZSwgJ19fc2NoZW1hJywgc2NoZW1hKTtcbiAgICBjYWNoZSh2YWx1ZSwgJ19fZXJyb3JMaXN0JywgZXJyb3JMaXN0KTtcbiAgICByZXR1cm4gZXJyb3JMaXN0O1xuICB9XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdmFsdWUgaXMgYSBmb3JtIHZhbHVlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNWYWx1ZShtYXliZVZhbHVlKSB7XG4gIHJldHVybiBtYXliZVZhbHVlIGluc3RhbmNlb2YgVmFsdWU7XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IHJvb3QgdmFsdWUuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNyZWF0ZVZhbHVlKFxuICAgIHNjaGVtYSxcbiAgICB2YWx1ZSA9IHt9LFxuICAgIG9uQ2hhbmdlID0gZW1wdHlGdW5jdGlvbixcbiAgICBwYXJhbXMgPSB7fSxcbiAgICBlcnJvckxpc3QgPSBudWxsKSB7XG4gIGlmIChlcnJvckxpc3QgPT09IG51bGwpIHtcbiAgICBlcnJvckxpc3QgPSB2YWxpZGF0ZShzY2hlbWEsIHZhbHVlKTtcbiAgfVxuICByZXR1cm4gbmV3IFZhbHVlUm9vdChzY2hlbWEsIHZhbHVlLCBvbkNoYW5nZSwgcGFyYW1zLCBlcnJvckxpc3QpO1xufVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvVmFsdWUuanNcbiAqKi8iLCJ2YXIgYmFzZUdldCA9IHJlcXVpcmUoJy4uL2ludGVybmFsL2Jhc2VHZXQnKSxcbiAgICB0b1BhdGggPSByZXF1aXJlKCcuLi9pbnRlcm5hbC90b1BhdGgnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBwcm9wZXJ0eSB2YWx1ZSBhdCBgcGF0aGAgb2YgYG9iamVjdGAuIElmIHRoZSByZXNvbHZlZCB2YWx1ZSBpc1xuICogYHVuZGVmaW5lZGAgdGhlIGBkZWZhdWx0VmFsdWVgIGlzIHVzZWQgaW4gaXRzIHBsYWNlLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHBhcmFtIHsqfSBbZGVmYXVsdFZhbHVlXSBUaGUgdmFsdWUgcmV0dXJuZWQgaWYgdGhlIHJlc29sdmVkIHZhbHVlIGlzIGB1bmRlZmluZWRgLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHZhbHVlLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IFt7ICdiJzogeyAnYyc6IDMgfSB9XSB9O1xuICpcbiAqIF8uZ2V0KG9iamVjdCwgJ2FbMF0uYi5jJyk7XG4gKiAvLyA9PiAzXG4gKlxuICogXy5nZXQob2JqZWN0LCBbJ2EnLCAnMCcsICdiJywgJ2MnXSk7XG4gKiAvLyA9PiAzXG4gKlxuICogXy5nZXQob2JqZWN0LCAnYS5iLmMnLCAnZGVmYXVsdCcpO1xuICogLy8gPT4gJ2RlZmF1bHQnXG4gKi9cbmZ1bmN0aW9uIGdldChvYmplY3QsIHBhdGgsIGRlZmF1bHRWYWx1ZSkge1xuICB2YXIgcmVzdWx0ID0gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBiYXNlR2V0KG9iamVjdCwgdG9QYXRoKHBhdGgpLCAocGF0aCArICcnKSk7XG4gIHJldHVybiByZXN1bHQgPT09IHVuZGVmaW5lZCA/IGRlZmF1bHRWYWx1ZSA6IHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXQ7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9sb2Rhc2gvb2JqZWN0L2dldC5qc1xuICoqIG1vZHVsZSBpZCA9IDYxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL3RvT2JqZWN0Jyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGdldGAgd2l0aG91dCBzdXBwb3J0IGZvciBzdHJpbmcgcGF0aHNcbiAqIGFuZCBkZWZhdWx0IHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheX0gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHBhcmFtIHtzdHJpbmd9IFtwYXRoS2V5XSBUaGUga2V5IHJlcHJlc2VudGF0aW9uIG9mIHBhdGguXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzb2x2ZWQgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGJhc2VHZXQob2JqZWN0LCBwYXRoLCBwYXRoS2V5KSB7XG4gIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAocGF0aEtleSAhPT0gdW5kZWZpbmVkICYmIHBhdGhLZXkgaW4gdG9PYmplY3Qob2JqZWN0KSkge1xuICAgIHBhdGggPSBbcGF0aEtleV07XG4gIH1cbiAgdmFyIGluZGV4ID0gMCxcbiAgICAgIGxlbmd0aCA9IHBhdGgubGVuZ3RoO1xuXG4gIHdoaWxlIChvYmplY3QgIT0gbnVsbCAmJiBpbmRleCA8IGxlbmd0aCkge1xuICAgIG9iamVjdCA9IG9iamVjdFtwYXRoW2luZGV4KytdXTtcbiAgfVxuICByZXR1cm4gKGluZGV4ICYmIGluZGV4ID09IGxlbmd0aCkgPyBvYmplY3QgOiB1bmRlZmluZWQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUdldDtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2xvZGFzaC9pbnRlcm5hbC9iYXNlR2V0LmpzXG4gKiogbW9kdWxlIGlkID0gNjJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4uL2xhbmcvaXNPYmplY3QnKTtcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGFuIG9iamVjdCBpZiBpdCdzIG5vdCBvbmUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIHRvT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdCh2YWx1ZSkgPyB2YWx1ZSA6IE9iamVjdCh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdG9PYmplY3Q7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9sb2Rhc2gvaW50ZXJuYWwvdG9PYmplY3QuanNcbiAqKiBtb2R1bGUgaWQgPSA2M1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGJhc2VUb1N0cmluZyA9IHJlcXVpcmUoJy4vYmFzZVRvU3RyaW5nJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4uL2xhbmcvaXNBcnJheScpO1xuXG4vKiogVXNlZCB0byBtYXRjaCBwcm9wZXJ0eSBuYW1lcyB3aXRoaW4gcHJvcGVydHkgcGF0aHMuICovXG52YXIgcmVQcm9wTmFtZSA9IC9bXi5bXFxdXSt8XFxbKD86KC0/XFxkKyg/OlxcLlxcZCspPyl8KFtcIiddKSgoPzooPyFcXDIpW15cXG5cXFxcXXxcXFxcLikqPylcXDIpXFxdL2c7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIGJhY2tzbGFzaGVzIGluIHByb3BlcnR5IHBhdGhzLiAqL1xudmFyIHJlRXNjYXBlQ2hhciA9IC9cXFxcKFxcXFwpPy9nO1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gcHJvcGVydHkgcGF0aCBhcnJheSBpZiBpdCdzIG5vdCBvbmUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHByb3BlcnR5IHBhdGggYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIHRvUGF0aCh2YWx1ZSkge1xuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBiYXNlVG9TdHJpbmcodmFsdWUpLnJlcGxhY2UocmVQcm9wTmFtZSwgZnVuY3Rpb24obWF0Y2gsIG51bWJlciwgcXVvdGUsIHN0cmluZykge1xuICAgIHJlc3VsdC5wdXNoKHF1b3RlID8gc3RyaW5nLnJlcGxhY2UocmVFc2NhcGVDaGFyLCAnJDEnKSA6IChudW1iZXIgfHwgbWF0Y2gpKTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdG9QYXRoO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vbG9kYXNoL2ludGVybmFsL3RvUGF0aC5qc1xuICoqIG1vZHVsZSBpZCA9IDY0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcgaWYgaXQncyBub3Qgb25lLiBBbiBlbXB0eSBzdHJpbmcgaXMgcmV0dXJuZWRcbiAqIGZvciBgbnVsbGAgb3IgYHVuZGVmaW5lZGAgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm9jZXNzLlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBiYXNlVG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09IG51bGwgPyAnJyA6ICh2YWx1ZSArICcnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlVG9TdHJpbmc7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9sb2Rhc2gvaW50ZXJuYWwvYmFzZVRvU3RyaW5nLmpzXG4gKiogbW9kdWxlIGlkID0gNjVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlxuZnVuY3Rpb24gdXBkYXRlKGhvc3QsIHNwZWMpIHtcbiAgLy8gU2luZ2xlIHBhdGggc3RyaW5nIHVwZGF0ZSBsaWtlOiB1cGRhdGUob2JqLCAncGF0aDEucGF0aDIubmFtZScsICdKb2huJyk7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzKSB7XG4gICAgdmFyIHZhbHVlID0gYXJndW1lbnRzWzJdO1xuICAgIHZhciBwYXRocyA9IHNwZWMuc3BsaXQoJy4nKTtcbiAgICB2YXIgc3BlY09iaiA9IHt9O1xuICAgIHZhciBjdXJyZW50T2JqID0gc3BlY09iajtcbiAgICBwYXRocy5mb3JFYWNoKGZ1bmN0aW9uKHBhdGgsIGluZGV4KSB7XG4gICAgICBpZiAoaW5kZXggPT09IHBhdGhzLmxlbmd0aCAtIDEpIGN1cnJlbnRPYmpbcGF0aF0gPSB2YWx1ZTtcbiAgICAgIGVsc2UgY3VycmVudE9ialtwYXRoXSA9IGN1cnJlbnRPYmogPSB7fTtcbiAgICB9KTtcbiAgICBzcGVjID0gc3BlY09iajtcbiAgfVxuXG4gIC8vIElmIGFueSBvZiB0aGUgYnJhbmNoZXMgb2YgYW4gb2JqZWN0IGNoYW5nZWQsIHRoZW4gdGhhbiBvYmplY3QgY2hhbmdlZCB0b286IGNsb25lIGl0LlxuICAvLyBUaGUgdHlwZSBvZiB0aGUgY29weSBpcyBpbmZlcnJlZC5cbiAgdmFyIGNvcHkgPSBob3N0XG4gICAgPyBBcnJheS5pc0FycmF5KGhvc3QpID8gaG9zdC5zbGljZSgpIDogY2xvbmUoaG9zdClcbiAgICA6IEFycmF5LmlzQXJyYXkoc3BlYykgPyBbXSA6IHt9O1xuXG4gIGZvciAodmFyIGtleSBpbiBzcGVjKSB7XG4gICAgdmFyIHNwZWNWYWx1ZSA9IHNwZWNba2V5XTtcblxuICAgIGlmIChzcGVjVmFsdWUgPT09IERFTEVURSkge1xuICAgICAgQXJyYXkuaXNBcnJheShjb3B5KSA/IGNvcHkuc3BsaWNlKGtleSwgMSkgOiBkZWxldGUgY29weVtrZXldO1xuICAgIH1cbiAgICAvLyBUaGUgc3BlYyBjb250aW51ZXMgZGVlcGVyXG4gICAgZWxzZSBpZiAoaXNPYmplY3Qoc3BlY1ZhbHVlKSkge1xuICAgICAgY29weVtrZXldID0gdXBkYXRlKGNvcHlba2V5XSwgc3BlY1ZhbHVlKTtcbiAgICB9XG4gICAgLy8gTGVhZiB1cGRhdGVcbiAgICBlbHNlIHtcbiAgICAgIHZhciBuZXdWYWx1ZSA9ICh0eXBlb2Ygc3BlY1ZhbHVlID09PSAnZnVuY3Rpb24nKVxuICAgICAgICA/IHNwZWNWYWx1ZShjb3B5W2tleV0pXG4gICAgICAgIDogc3BlY1ZhbHVlO1xuXG4gICAgICBjb3B5W2tleV0gPSBuZXdWYWx1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29weTtcbn1cblxuZnVuY3Rpb24gY2xvbmUob2JqKSB7XG4gIHZhciByZXN1bHQgPSB7fTtcbiAgT2JqZWN0LmtleXMob2JqKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkgeyByZXN1bHRba2V5XSA9IG9ialtrZXldIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBpc09iamVjdCh4KSB7IHJldHVybiB4ICYmIHR5cGVvZiB4ID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheSh4KSB9XG5cblxudmFyIERFTEVURSA9IHVwZGF0ZS5ERUxFVEUgPSB7fTtcblxudXBkYXRlLnJlcGxhY2UgPSBmdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7IHJldHVybiB2YWx1ZSB9O1xufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IHVwZGF0ZTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9pbW11cGRhdGUvaW1tdXBkYXRlLmpzXG4gKiogbW9kdWxlIGlkID0gNjZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQGNvcHlyaWdodCAyMDE1LCBQcm9tZXRoZXVzIFJlc2VhcmNoLCBMTENcbiAqL1xuXG5pbXBvcnQgSlNPTlNjaGVtYSBmcm9tICcuL0pTT05TY2hlbWEnO1xuXG4vKipcbiAqIENyZWF0ZSBhIFJlYWN0IEZvcm1zIHNjaGVtYSB2YWxpZGF0b3IuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBTY2hlbWEoc2NoZW1hLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSB7XG4gICAgLi4ub3B0aW9ucyxcbiAgICBncmVlZHk6IHRydWUsXG4gICAgdW5kZWZpbmVkQXNPYmplY3Q6IHRydWUsXG4gICAgbnVsbEFzT2JqZWN0OiB0cnVlLFxuICAgIHVuZGVmaW5lZEFzQXJyYXk6IHRydWUsXG4gICAgbnVsbEFzVW5kZWZpbmVkOiB0cnVlLFxuICAgIG51bGxBc0FycmF5OiB0cnVlLFxuICAgIG51bGxBc0JvdHRvbVR5cGU6IHRydWVcbiAgfTtcbiAgcmV0dXJuIEpTT05TY2hlbWEoc2NoZW1hLCBvcHRpb25zKTtcbn1cblxuZnVuY3Rpb24gX2dlbmVyYXRlU2NoZW1hQnVpbGRlcih0eXBlKSB7XG4gIHJldHVybiBmdW5jdGlvbiBidWlsZGVyKHBhcmFtcykge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlLFxuICAgICAgaXNSZXF1aXJlZDogcGFyYW1zID8gISFwYXJhbXMuaXNSZXF1aXJlZCA6IGZhbHNlLFxuICAgICAgLi4ucGFyYW1zXG4gICAgfTtcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG9iamVjdChwcm9wZXJ0aWVzLCBwYXJhbXMpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnb2JqZWN0JyxcbiAgICBwcm9wZXJ0aWVzLFxuICAgIHJlcXVpcmVkOiBPYmplY3Qua2V5cyhwcm9wZXJ0aWVzKS5maWx0ZXIoayA9PiBwcm9wZXJ0aWVzW2tdLmlzUmVxdWlyZWQpLFxuICAgIGlzUmVxdWlyZWQ6IHBhcmFtcyA/ICEhcGFyYW1zLmlzUmVxdWlyZWQgOiBmYWxzZSxcbiAgICAuLi5wYXJhbXNcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFycmF5KGl0ZW1zLCBwYXJhbXMpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnYXJyYXknLFxuICAgIGl0ZW1zLFxuICAgIGlzUmVxdWlyZWQ6IHBhcmFtcyA/ICEhcGFyYW1zLmlzUmVxdWlyZWQgOiBmYWxzZSxcbiAgICAuLi5wYXJhbXNcbiAgfTtcbn1cblxuZXhwb3J0IGxldCBzdHJpbmcgPSBfZ2VuZXJhdGVTY2hlbWFCdWlsZGVyKCdzdHJpbmcnKTtcbmV4cG9ydCBsZXQgbnVtYmVyID0gX2dlbmVyYXRlU2NoZW1hQnVpbGRlcignbnVtYmVyJyk7XG5cbmV4cG9ydCBmdW5jdGlvbiBzZWxlY3Qoc2NoZW1hLCBrZXlQYXRoKSB7XG4gIGZvciAobGV0IGkgPSAwLCBsZW4gPSBrZXlQYXRoLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKCFzY2hlbWEpIHtcbiAgICAgIHJldHVybiBzY2hlbWE7XG4gICAgfVxuICAgIHNjaGVtYSA9IF9zZWxlY3Qoc2NoZW1hLCBrZXlQYXRoW2ldKTtcbiAgfVxuICByZXR1cm4gc2NoZW1hO1xufVxuXG5mdW5jdGlvbiBfc2VsZWN0KHNjaGVtYSwga2V5KSB7XG4gIGlmIChzY2hlbWEpIHtcbiAgICBpZiAoc2NoZW1hLnR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICBsZXQgc3ViU2NoZW1hID0gc2NoZW1hLnByb3BlcnRpZXMgP1xuICAgICAgICBzY2hlbWEucHJvcGVydGllc1trZXldIDpcbiAgICAgICAgdW5kZWZpbmVkO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc2NoZW1hLnJlcXVpcmVkKSkge1xuICAgICAgICAvLyB0cmFuc2ZlciByZXF1aXJlZCBpbmZvIG9udG8gc2NoZW1hXG4gICAgICAgIHN1YlNjaGVtYSA9IHtcbiAgICAgICAgICB0eXBlOiAnb2JqZWN0JyxcbiAgICAgICAgICAuLi5zdWJTY2hlbWEsXG4gICAgICAgICAgaXNSZXF1aXJlZDogc2NoZW1hLnJlcXVpcmVkLmluZGV4T2Yoa2V5KSAhPT0gLTFcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdWJTY2hlbWE7XG4gICAgfSBlbHNlIGlmIChzY2hlbWEudHlwZSA9PT0gJ2FycmF5Jykge1xuICAgICAgaWYgKHNjaGVtYS5pdGVtcykge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzY2hlbWEuaXRlbXMpKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbWF4LWRlcHRoXG4gICAgICAgICAgcmV0dXJuIHNjaGVtYS5pdGVtc1trZXldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBzY2hlbWEuaXRlbXM7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHtKU09OLnN0cmluZ2lmeShzY2hlbWEpfSAke2tleX1gKTtcbiAgICB9XG4gIH1cbn1cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL1NjaGVtYS5qc1xuICoqLyIsIi8qKlxuICogQGNvcHlyaWdodCAyMDE1LCBQcm9tZXRoZXVzIFJlc2VhcmNoLCBMTENcbiAqL1xuXG5pbXBvcnQgY29tcGlsZVZhbGlkYXRvciBmcm9tICcuL2NvbXBpbGVWYWxpZGF0b3InO1xuXG4vKipcbiAqIENyZWF0ZSBhIEpTT04gc2NoZW1hIHZhbGlkYXRvciB3aGljaCByZXR1cm5zIGEgbGlzdCBvZiBlcnJvcnMgZm9yIGludmFsaWRcbiAqIG9iamVjdHMgYW5kIGFuIGVtcHR5IGxpc3Qgb2YgZXJyb3JzIGZvciB2YWxpZCBvYmplY3RzLlxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBKU09OU2NoZW1hKHNjaGVtYSwgb3B0aW9ucykge1xuICBsZXQgdmFsaWRhdGUgPSBjb21waWxlVmFsaWRhdG9yKHNjaGVtYSwgb3B0aW9ucyk7XG4gIHJldHVybiBmdW5jdGlvbiB2YWxpZGF0b3Iob2JqKSB7XG4gICAgbGV0IHJlc3VsdCA9IHZhbGlkYXRlKG9iaik7XG4gICAgbGV0IGVycm9ycyA9IHZhbGlkYXRlLmVycm9ycztcbiAgICByZXR1cm4gcmVzdWx0ID8gW10gOiBlcnJvcnM7XG4gIH07XG59XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9KU09OU2NoZW1hL2luZGV4LmpzXG4gKiovIiwiLyoqXG4gKiBAY29weXJpZ2h0IDIwMTQsIE1hdGhpYXMgQnV1c1xuICogQGNvcHlyaWdodCAyMDE1LCBQcm9tZXRoZXVzIFJlc2VhcmNoLCBMTENcbiAqL1xuXG5pbXBvcnQgZ2Vub2JqICAgICAgIGZyb20gJ2dlbmVyYXRlLW9iamVjdC1wcm9wZXJ0eSc7XG5pbXBvcnQgZ2VuZnVuICAgICAgIGZyb20gJ2dlbmVyYXRlLWZ1bmN0aW9uJztcbmltcG9ydCBqc29ucG9pbnRlciAgZnJvbSAnanNvbnBvaW50ZXInO1xuaW1wb3J0IEZvcm1hdCAgICAgICBmcm9tICcuL0Zvcm1hdCc7XG5cbmNvbnN0IEhUVFBfUkVGID0gL15odHRwcz86XFwvXFwvLztcbmNvbnN0IFNQTElUX05BTUUgPSAvW1xcW1xcXV0vO1xuXG5mdW5jdGlvbiBnZXRTY2hlbWFCeVJlZihvYmosIGFkZGl0aW9uYWxTY2hlbWFzLCBwdHIpIHtcbiAgaWYgKEhUVFBfUkVGLnRlc3QocHRyKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gdmlzaXQoc3ViKSB7XG4gICAgaWYgKHN1YiAmJiBzdWIuaWQgPT09IHB0cikge1xuICAgICAgcmV0dXJuIHN1YjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBzdWIgIT09ICdvYmplY3QnIHx8ICFzdWIpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LmtleXMoc3ViKS5yZWR1Y2UoZnVuY3Rpb24ocmVzLCBrKSB7XG4gICAgICByZXR1cm4gcmVzIHx8IHZpc2l0KHN1YltrXSk7XG4gICAgfSwgbnVsbCk7XG4gIH1cblxuICBsZXQgcmVzID0gdmlzaXQob2JqKTtcbiAgaWYgKHJlcykge1xuICAgIHJldHVybiByZXM7XG4gIH1cblxuICBwdHIgPSBwdHIucmVwbGFjZSgvXiMvLCAnJyk7XG4gIHB0ciA9IHB0ci5yZXBsYWNlKC9cXC8kLywgJycpO1xuXG4gIHRyeSB7XG4gICAgcmV0dXJuIGpzb25wb2ludGVyLmdldChvYmosIGRlY29kZVVSSShwdHIpKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgbGV0IG90aGVyID0gYWRkaXRpb25hbFNjaGVtYXNbcHRyXSB8fCBhZGRpdGlvbmFsU2NoZW1hc1twdHIucmVwbGFjZSgvXiMvLCAnJyldO1xuICAgIHJldHVybiBvdGhlciB8fCBudWxsO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZvcm1hdE5hbWUoZmllbGQpIHtcbiAgZmllbGQgPSBmaWVsZC5yZXBsYWNlKC9cXFsvZywgJ1tcXHUwMDAxJykuc3BsaXQoU1BMSVRfTkFNRSk7XG4gIGxldCBmb3JtYXR0ZWQgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBmaWVsZC5sZW5ndGg7IGkrKykge1xuICAgIGxldCBwYXJ0ID0gZmllbGRbaV07XG4gICAgaWYgKHBhcnRbMF0gPT09ICdcXHUwMDAxJykge1xuICAgICAgZm9ybWF0dGVkLnB1c2goSlNPTi5zdHJpbmdpZnkoJy4nKSk7XG4gICAgICBmb3JtYXR0ZWQucHVzaChwYXJ0LnNsaWNlKDEpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9ybWF0dGVkLnB1c2goSlNPTi5zdHJpbmdpZnkocGFydCkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZm9ybWF0dGVkLmpvaW4oJysnKTtcbn1cblxubGV0IHR5cGVzID0ge1xuICBhbnkoKSB7XG4gICAgcmV0dXJuICd0cnVlJztcbiAgfSxcblxuICBudWxsKG5hbWUpIHtcbiAgICByZXR1cm4gYCR7bmFtZX0gPT09IG51bGxgO1xuICB9LFxuXG4gIGJvb2xlYW4obmFtZSkge1xuICAgIHJldHVybiBgdHlwZW9mICR7bmFtZX0gPT09IFwiYm9vbGVhblwiYDtcbiAgfSxcblxuICBhcnJheShuYW1lKSB7XG4gICAgcmV0dXJuIGBBcnJheS5pc0FycmF5KCR7bmFtZX0pYDtcbiAgfSxcblxuICBvYmplY3QobmFtZSkge1xuICAgIHJldHVybiBgdHlwZW9mICR7bmFtZX0gPT09IFwib2JqZWN0XCIgJiYgJHtuYW1lfSAmJiAhQXJyYXkuaXNBcnJheSgke25hbWV9KWA7XG4gIH0sXG5cbiAgbnVtYmVyKG5hbWUpIHtcbiAgICByZXR1cm4gYHR5cGVvZiAke25hbWV9ID09PSBcIm51bWJlclwiYDtcbiAgfSxcblxuICBpbnRlZ2VyKG5hbWUpIHtcbiAgICByZXR1cm4gYHR5cGVvZiAke25hbWV9ID09PSBcIm51bWJlclwiICYmIChNYXRoLmZsb29yKCR7bmFtZX0pID09PSAke25hbWV9IHx8ICR7bmFtZX0gPiA5MDA3MTk5MjU0NzQwOTkyIHx8ICR7bmFtZX0gPCAtOTAwNzE5OTI1NDc0MDk5MilgOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG1heC1sZW5cbiAgfSxcblxuICBzdHJpbmcobmFtZSkge1xuICAgIHJldHVybiBgdHlwZW9mICR7bmFtZX0gPT09IFwic3RyaW5nXCJgO1xuICB9LFxufTtcblxuZnVuY3Rpb24gdW5pcXVlKGFycmF5KSB7XG4gIGxldCBsaXN0ID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICBsaXN0LnB1c2godHlwZW9mIGFycmF5W2ldID09PSAnb2JqZWN0JyA/IEpTT04uc3RyaW5naWZ5KGFycmF5W2ldKSA6IGFycmF5W2ldKTtcbiAgfVxuICBmb3IgKGxldCBpID0gMTsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAobGlzdC5pbmRleE9mKGxpc3RbaV0pICE9PSBpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBjb21waWxlKHNjaGVtYSwgY2FjaGUsIHJvb3QsIG9wdHMgPSB7fSkge1xuICBsZXQgcmVwb3J0ZXIgPSBvcHRzLnJlcG9ydGVyO1xuICBsZXQgZm9ybWF0cyA9IHsuLi5Gb3JtYXQsIC4uLm9wdHMuZm9ybWF0c307XG4gIGxldCBzY29wZSA9IHt1bmlxdWUsIGZvcm1hdHN9O1xuICBsZXQgdmVyYm9zZSA9IG9wdHMgPyAhIW9wdHMudmVyYm9zZSA6IGZhbHNlO1xuICBsZXQgdW5kZWZpbmVkQXNPYmplY3QgPSBvcHRzID8gISFvcHRzLnVuZGVmaW5lZEFzT2JqZWN0IDogZmFsc2U7XG4gIGxldCBudWxsQXNPYmplY3QgPSBvcHRzID8gISFvcHRzLm51bGxBc09iamVjdCA6IGZhbHNlO1xuICBsZXQgbnVsbEFzVW5kZWZpbmVkID0gb3B0cyA/ICEhb3B0cy5udWxsQXNVbmRlZmluZWQgOiBmYWxzZTtcbiAgbGV0IHVuZGVmaW5lZEFzQXJyYXkgPSBvcHRzID8gISFvcHRzLnVuZGVmaW5lZEFzQXJyYXkgOiBmYWxzZTtcbiAgbGV0IG51bGxBc0FycmF5ID0gb3B0cyA/ICEhb3B0cy5udWxsQXNBcnJheSA6IGZhbHNlO1xuICBsZXQgZ3JlZWR5ID0gb3B0cyAmJiBvcHRzLmdyZWVkeSAhPT0gdW5kZWZpbmVkID9cbiAgICBvcHRzLmdyZWVkeSA6IGZhbHNlO1xuXG4gIGxldCBzeW1zID0ge307XG5cbiAgZnVuY3Rpb24gZ2Vuc3ltKG5hbWUpIHtcbiAgICByZXR1cm4gbmFtZSArIChzeW1zW25hbWVdID0gKHN5bXNbbmFtZV0gfHwgMCkgKyAxKTtcbiAgfVxuXG4gIGxldCByZXZlcnNlUGF0dGVybnMgPSB7fTtcbiAgbGV0IHBhdHRlcm5zID0gZnVuY3Rpb24ocCkge1xuICAgIGlmIChyZXZlcnNlUGF0dGVybnNbcF0pIHtcbiAgICAgIHJldHVybiByZXZlcnNlUGF0dGVybnNbcF07XG4gICAgfVxuICAgIGxldCBuID0gZ2Vuc3ltKCdwYXR0ZXJuJyk7XG4gICAgc2NvcGVbbl0gPSBuZXcgUmVnRXhwKHApO1xuICAgIHJldmVyc2VQYXR0ZXJuc1twXSA9IG47XG4gICAgcmV0dXJuIG47XG4gIH07XG5cbiAgbGV0IHZhcnMgPSBbJ2knLCAnaicsICdrJywgJ2wnLCAnbScsICduJywgJ28nLCAncCcsICdxJywgJ3InLCAncycsICd0JywgJ3UnLCAndicsICd4JywgJ3knLCAneiddO1xuICBsZXQgZ2VubG9vcCA9IGZ1bmN0aW9uKCkge1xuICAgIGxldCB2ID0gdmFycy5zaGlmdCgpO1xuICAgIHZhcnMucHVzaCh2ICsgdlswXSk7XG4gICAgcmV0dXJuIHY7XG4gIH07XG5cbiAgZnVuY3Rpb24gdmlzaXQobmFtZSwgX2RhdGFTeW0sIG5vZGUsIHJlcG9ydGVyLCBmaWx0ZXIpIHtcbiAgICBsZXQgcHJvcGVydGllcyA9IG5vZGUucHJvcGVydGllcztcbiAgICBsZXQgdHlwZSA9IG5vZGUudHlwZTtcbiAgICBsZXQgdHVwbGUgPSBmYWxzZTtcblxuICAgIGxldCBkYXRhU3ltID0gZ2Vuc3ltKCdkYXRhJyk7XG4gICAgdmFsaWRhdGUoJ3ZhciAlcyA9ICVzJywgZGF0YVN5bSwgX2RhdGFTeW0pO1xuXG4gICAgbGV0IG5vZGVTeW0gPSBnZW5zeW0oJ25vZGUnKTtcbiAgICBzY29wZVtub2RlU3ltXSA9IG5vZGU7XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShub2RlLml0ZW1zKSkgeyAvLyB0dXBsZSB0eXBlXG4gICAgICBwcm9wZXJ0aWVzID0ge307XG4gICAgICBub2RlLml0ZW1zLmZvckVhY2goZnVuY3Rpb24oaXRlbSwgaSkge1xuICAgICAgICBwcm9wZXJ0aWVzW2ldID0gaXRlbTtcbiAgICAgIH0pO1xuICAgICAgdHlwZSA9ICdhcnJheSc7XG4gICAgICB0dXBsZSA9IHRydWU7XG4gICAgfVxuXG4gICAgbGV0IGluZGVudCA9IDA7XG5cbiAgICBmdW5jdGlvbiBlcnJvcihtc2csIHByb3AsIHZhbHVlLCBzY2hlbWEpIHtcbiAgICAgIHZhbGlkYXRlKCdlcnJvcnMrKycpO1xuICAgICAgaWYgKHJlcG9ydGVyID09PSB0cnVlKSB7XG4gICAgICAgIHZhbGlkYXRlKCdpZiAodmFsaWRhdGUuZXJyb3JzID09PSBudWxsKSB2YWxpZGF0ZS5lcnJvcnMgPSBbXScpO1xuICAgICAgICBpZiAodmVyYm9zZSkge1xuICAgICAgICAgIHZhbGlkYXRlKFxuICAgICAgICAgICAgJ3ZhbGlkYXRlLmVycm9ycy5wdXNoKHtmaWVsZDolcyxtZXNzYWdlOiVzLHZhbHVlOiVzLHNjaGVtYTolc30pJyxcbiAgICAgICAgICAgIGZvcm1hdE5hbWUocHJvcCB8fCBuYW1lKSwgSlNPTi5zdHJpbmdpZnkobXNnKSwgdmFsdWUgfHwgbmFtZSwgc2NoZW1hIHx8IG5vZGVTeW1cbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbGlkYXRlKFxuICAgICAgICAgICAgJ3ZhbGlkYXRlLmVycm9ycy5wdXNoKHtmaWVsZDolcyxtZXNzYWdlOiVzLHNjaGVtYTolc30pJyxcbiAgICAgICAgICAgIGZvcm1hdE5hbWUocHJvcCB8fCBuYW1lKSwgSlNPTi5zdHJpbmdpZnkobXNnKSwgc2NoZW1hIHx8IG5vZGVTeW1cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVycm9yRnJvbVN5bShzeW0sIHNjaGVtYSkge1xuICAgICAgdmFsaWRhdGUoJ2Vycm9ycysrJyk7XG4gICAgICBpZiAocmVwb3J0ZXIgPT09IHRydWUpIHtcbiAgICAgICAgdmFsaWRhdGUoJ2lmICh2YWxpZGF0ZS5lcnJvcnMgPT09IG51bGwpIHZhbGlkYXRlLmVycm9ycyA9IFtdJyk7XG4gICAgICAgIGlmICh2ZXJib3NlKSB7XG4gICAgICAgICAgdmFsaWRhdGUoXG4gICAgICAgICAgICAndmFsaWRhdGUuZXJyb3JzLnB1c2goe2ZpZWxkOiVzLG1lc3NhZ2U6JXMsdmFsdWU6JXMsc2NoZW1hOiVzfSknLFxuICAgICAgICAgICAgZm9ybWF0TmFtZShuYW1lKSwgc3ltLCBuYW1lLCBzY2hlbWEgfHwgbm9kZVN5bVxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsaWRhdGUoXG4gICAgICAgICAgICAndmFsaWRhdGUuZXJyb3JzLnB1c2goe2ZpZWxkOiVzLG1lc3NhZ2U6JXMsc2NoZW1hOiVzfSknLFxuICAgICAgICAgICAgZm9ybWF0TmFtZShuYW1lKSwgc3ltLCBzY2hlbWEgfHwgbm9kZVN5bVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobm9kZS5yZXF1aXJlZCA9PT0gdHJ1ZSkge1xuICAgICAgaW5kZW50Kys7XG4gICAgICBpZiAobnVsbEFzVW5kZWZpbmVkKSB7XG4gICAgICAgIHZhbGlkYXRlKCdpZiAoJXMgPT0gdW5kZWZpbmVkKSB7JywgZGF0YVN5bSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWxpZGF0ZSgnaWYgKCVzID09PSB1bmRlZmluZWQpIHsnLCBkYXRhU3ltKTtcbiAgICAgIH1cbiAgICAgIGVycm9yKCdpcyByZXF1aXJlZCcpO1xuICAgICAgdmFsaWRhdGUoJ30gZWxzZSB7Jyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChub2RlLnR5cGUgPT09ICdvYmplY3QnICYmICh1bmRlZmluZWRBc09iamVjdCB8fCBudWxsQXNPYmplY3QpKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbG9uZWx5LWlmLG1heC1sZW5cbiAgICAgICAgaWYgKHVuZGVmaW5lZEFzT2JqZWN0ICYmIG51bGxBc09iamVjdCkge1xuICAgICAgICAgIHZhbGlkYXRlKCdpZiAoJXMgPT0gbnVsbCkgJXMgPSB7fScsIGRhdGFTeW0sIGRhdGFTeW0pO1xuICAgICAgICB9IGVsc2UgaWYgKHVuZGVmaW5lZEFzT2JqZWN0KSB7XG4gICAgICAgICAgdmFsaWRhdGUoJ2lmICglcyA9PT0gdW5kZWZpbmVkKSAlcyA9IHt9JywgZGF0YVN5bSwgZGF0YVN5bSk7XG4gICAgICAgIH0gZWxzZSBpZiAobnVsbEFzT2JqZWN0KSB7XG4gICAgICAgICAgdmFsaWRhdGUoJ2lmICglcyA9PT0gbnVsbCkgJXMgPSB7fScsIGRhdGFTeW0sIGRhdGFTeW0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKG5vZGUudHlwZSA9PT0gJ2FycmF5JyAmJiAodW5kZWZpbmVkQXNBcnJheSB8fCBudWxsQXNBcnJheSkpIHtcbiAgICAgICAgaWYgKHVuZGVmaW5lZEFzQXJyYXkgJiYgbnVsbEFzQXJyYXkpIHtcbiAgICAgICAgICB2YWxpZGF0ZSgnaWYgKCVzID09IG51bGwpICVzID0gW10nLCBkYXRhU3ltLCBkYXRhU3ltKTtcbiAgICAgICAgfSBlbHNlIGlmICh1bmRlZmluZWRBc0FycmF5KSB7XG4gICAgICAgICAgdmFsaWRhdGUoJ2lmICglcyA9PT0gdW5kZWZpbmVkKSAlcyA9IFtdJywgZGF0YVN5bSwgZGF0YVN5bSk7XG4gICAgICAgIH0gZWxzZSBpZiAobnVsbEFzQXJyYXkpIHtcbiAgICAgICAgICB2YWxpZGF0ZSgnaWYgKCVzID09PSBudWxsKSAlcyA9IFtdJywgZGF0YVN5bSwgZGF0YVN5bSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluZGVudCsrO1xuICAgICAgICBpZiAobnVsbEFzVW5kZWZpbmVkKSB7XG4gICAgICAgICAgdmFsaWRhdGUoJ2lmICglcyAhPSB1bmRlZmluZWQpIHsnLCBkYXRhU3ltKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWxpZGF0ZSgnaWYgKCVzICE9PSB1bmRlZmluZWQpIHsnLCBkYXRhU3ltKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGxldCB2YWxpZCA9IFtdLmNvbmNhdCh0eXBlKVxuICAgICAgLm1hcChmdW5jdGlvbih0KSB7XG4gICAgICAgIHJldHVybiB0eXBlc1t0IHx8ICdhbnknXShkYXRhU3ltKTtcbiAgICAgIH0pXG4gICAgICAuam9pbignIHx8ICcpIHx8ICd0cnVlJztcblxuICAgIGlmICh2YWxpZCAhPT0gJ3RydWUnKSB7XG4gICAgICBpbmRlbnQrKztcbiAgICAgIHZhbGlkYXRlKCdpZiAoISglcykpIHsnLCB2YWxpZCk7XG4gICAgICBlcnJvcignaXMgdGhlIHdyb25nIHR5cGUnKTtcbiAgICAgIHZhbGlkYXRlKCd9IGVsc2UgeycpO1xuICAgIH1cblxuICAgIGlmICh0dXBsZSkge1xuICAgICAgaWYgKG5vZGUuYWRkaXRpb25hbEl0ZW1zID09PSBmYWxzZSkge1xuICAgICAgICB2YWxpZGF0ZSgnaWYgKCVzLmxlbmd0aCA+ICVkKSB7JywgZGF0YVN5bSwgbm9kZS5pdGVtcy5sZW5ndGgpO1xuICAgICAgICBlcnJvcignaGFzIGFkZGl0aW9uYWwgaXRlbXMnKTtcbiAgICAgICAgdmFsaWRhdGUoJ30nKTtcbiAgICAgIH0gZWxzZSBpZiAobm9kZS5hZGRpdGlvbmFsSXRlbXMpIHtcbiAgICAgICAgbGV0IGkgPSBnZW5sb29wKCk7XG4gICAgICAgIHZhbGlkYXRlKCdmb3IgKHZhciAlcyA9ICVkOyAlcyA8ICVzLmxlbmd0aDsgJXMrKykgeycsIGksIG5vZGUuaXRlbXMubGVuZ3RoLCBpLCBkYXRhU3ltLCBpKTtcbiAgICAgICAgdmlzaXQoXG4gICAgICAgICAgYCR7bmFtZX1bJHtpfV1gLFxuICAgICAgICAgIGAke2RhdGFTeW19WyR7aX1dYCxcbiAgICAgICAgICBub2RlLmFkZGl0aW9uYWxJdGVtcywgcmVwb3J0ZXIsIGZpbHRlclxuICAgICAgICApO1xuICAgICAgICB2YWxpZGF0ZSgnfScpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChub2RlLmZvcm1hdCAmJiAoZm9ybWF0c1tub2RlLmZvcm1hdF0gfHwgdHlwZW9mIG5vZGUuZm9ybWF0ID09PSAnZnVuY3Rpb24nKSkge1xuICAgICAgaWYgKHR5cGUgIT09ICdzdHJpbmcnICYmIGZvcm1hdHNbbm9kZS5mb3JtYXRdKSB7XG4gICAgICAgIHZhbGlkYXRlKCdpZiAoJXMpIHsnLCB0eXBlcy5zdHJpbmcoZGF0YVN5bSkpO1xuICAgICAgfVxuICAgICAgbGV0IG4gPSBnZW5zeW0oJ2Zvcm1hdCcpO1xuICAgICAgaWYgKHR5cGVvZiBub2RlLmZvcm1hdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBzY29wZVtuXSA9IG5vZGUuZm9ybWF0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2NvcGVbbl0gPSBmb3JtYXRzW25vZGUuZm9ybWF0XTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBzY29wZVtuXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBsZXQgciA9IGdlbnN5bSgncmVzdWx0Jyk7XG4gICAgICAgIHZhbGlkYXRlKCd2YXIgJXMgPSAlcyglcywgJXMpJywgciwgbiwgZGF0YVN5bSwgbm9kZVN5bSk7XG4gICAgICAgIHZhbGlkYXRlKCdpZiAoISVzKSB7Jywgcik7XG4gICAgICAgIGVycm9yKGBtdXN0IGJlICR7bm9kZS5mb3JtYXR9IGZvcm1hdGApO1xuICAgICAgICB2YWxpZGF0ZSgnfSBlbHNlIGlmICh0eXBlb2YgJXMgPT09IFwic3RyaW5nXCIpIHsnLCByKTtcbiAgICAgICAgZXJyb3JGcm9tU3ltKHIpO1xuICAgICAgICB2YWxpZGF0ZSgnfScpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsaWRhdGUoJ2lmICghJXMudGVzdCglcykpIHsnLCBuLCBkYXRhU3ltKTtcbiAgICAgICAgZXJyb3IoYG11c3QgYmUgJHtub2RlLmZvcm1hdH0gZm9ybWF0YCk7XG4gICAgICAgIHZhbGlkYXRlKCd9Jyk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZSAhPT0gJ3N0cmluZycgJiYgZm9ybWF0c1tub2RlLmZvcm1hdF0pIHtcbiAgICAgICAgdmFsaWRhdGUoJ30nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShub2RlLnJlcXVpcmVkKSkge1xuICAgICAgbGV0IGNoZWNrUmVxdWlyZWQgPSBmdW5jdGlvbihyZXEpIHtcbiAgICAgICAgaWYgKG51bGxBc1VuZGVmaW5lZCkge1xuICAgICAgICAgIHZhbGlkYXRlKCdpZiAoJXMgPT0gdW5kZWZpbmVkKSB7JywgZ2Vub2JqKGRhdGFTeW0sIHJlcSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbGlkYXRlKCdpZiAoJXMgPT09IHVuZGVmaW5lZCkgeycsIGdlbm9iaihkYXRhU3ltLCByZXEpKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVxU2NoZW1hID0gZ2Vub2JqKG5vZGVTeW0sICdwcm9wZXJ0aWVzJykgKyAnID8gJyArIGdlbm9iaihnZW5vYmoobm9kZVN5bSwgJ3Byb3BlcnRpZXMnKSwgcmVxKSArICcgOiB1bmRlZmluZWQnOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG1heC1sZW5cbiAgICAgICAgZXJyb3IoJ2lzIHJlcXVpcmVkJywgZ2Vub2JqKG5hbWUsIHJlcSksIHVuZGVmaW5lZCwgcmVxU2NoZW1hKTtcbiAgICAgICAgdmFsaWRhdGUoJ21pc3NpbmcrKycpO1xuICAgICAgICB2YWxpZGF0ZSgnfScpO1xuICAgICAgfTtcbiAgICAgIHZhbGlkYXRlKCdpZiAoKCVzKSkgeycsIHR5cGUgIT09ICdvYmplY3QnID8gdHlwZXMub2JqZWN0KGRhdGFTeW0pIDogJ3RydWUnKTtcbiAgICAgIHZhbGlkYXRlKCd2YXIgbWlzc2luZyA9IDAnKTtcbiAgICAgIG5vZGUucmVxdWlyZWQubWFwKGNoZWNrUmVxdWlyZWQpO1xuICAgICAgdmFsaWRhdGUoJ30nKTtcbiAgICAgIGlmICghZ3JlZWR5KSB7XG4gICAgICAgIHZhbGlkYXRlKCdpZiAobWlzc2luZyA9PT0gMCkgeycpO1xuICAgICAgICBpbmRlbnQrKztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobm9kZS51bmlxdWVJdGVtcykge1xuICAgICAgaWYgKHR5cGUgIT09ICdhcnJheScpIHtcbiAgICAgICAgdmFsaWRhdGUoJ2lmICglcykgeycsIHR5cGVzLmFycmF5KGRhdGFTeW0pKTtcbiAgICAgIH1cbiAgICAgIHZhbGlkYXRlKCdpZiAoISh1bmlxdWUoJXMpKSkgeycsIGRhdGFTeW0pO1xuICAgICAgZXJyb3IoJ211c3QgYmUgdW5pcXVlJyk7XG4gICAgICB2YWxpZGF0ZSgnfScpO1xuICAgICAgaWYgKHR5cGUgIT09ICdhcnJheScpIHtcbiAgICAgICAgdmFsaWRhdGUoJ30nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobm9kZS5lbnVtKSB7XG4gICAgICBsZXQgY29tcGxleCA9IG5vZGUuZW51bS5zb21lKGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBlID09PSAnb2JqZWN0JztcbiAgICAgIH0pO1xuXG4gICAgICBsZXQgY29tcGFyZSA9IGNvbXBsZXggP1xuICAgICAgICBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgcmV0dXJuIGBKU09OLnN0cmluZ2lmeSgke2RhdGFTeW19KSAhPT0gSlNPTi5zdHJpbmdpZnkoJHtKU09OLnN0cmluZ2lmeShlKX0pYDtcbiAgICAgICAgfSA6XG4gICAgICAgIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICByZXR1cm4gYCR7ZGF0YVN5bX0gIT09ICR7SlNPTi5zdHJpbmdpZnkoZSl9YDtcbiAgICAgICAgfTtcblxuICAgICAgdmFsaWRhdGUoJ2lmICglcykgeycsIG5vZGUuZW51bS5tYXAoY29tcGFyZSkuam9pbignICYmICcpIHx8ICdmYWxzZScpO1xuICAgICAgZXJyb3IoJ211c3QgYmUgYW4gZW51bSB2YWx1ZScpO1xuICAgICAgdmFsaWRhdGUoJ30nKTtcbiAgICB9XG5cbiAgICBpZiAobm9kZS5kZXBlbmRlbmNpZXMpIHtcbiAgICAgIGlmICh0eXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICB2YWxpZGF0ZSgnaWYgKCVzKSB7JywgdHlwZXMub2JqZWN0KGRhdGFTeW0pKTtcbiAgICAgIH1cblxuICAgICAgT2JqZWN0LmtleXMobm9kZS5kZXBlbmRlbmNpZXMpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIGxldCBkZXBzID0gbm9kZS5kZXBlbmRlbmNpZXNba2V5XTtcbiAgICAgICAgaWYgKHR5cGVvZiBkZXBzID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIGRlcHMgPSBbZGVwc107XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgZXhpc3RzID0gZnVuY3Rpb24oaykge1xuICAgICAgICAgIHJldHVybiBnZW5vYmooZGF0YVN5bSwgaykgKyAnICE9PSB1bmRlZmluZWQnO1xuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGRlcHMpKSB7XG4gICAgICAgICAgdmFsaWRhdGUoXG4gICAgICAgICAgICAnaWYgKCVzICE9PSB1bmRlZmluZWQgJiYgISglcykpIHsnLFxuICAgICAgICAgICAgZ2Vub2JqKGRhdGFTeW0sIGtleSksIGRlcHMubWFwKGV4aXN0cykuam9pbignICYmICcpIHx8ICd0cnVlJ1xuICAgICAgICAgICk7XG4gICAgICAgICAgZXJyb3IoJ2RlcGVuZGVuY2llcyBub3Qgc2V0Jyk7XG4gICAgICAgICAgdmFsaWRhdGUoJ30nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGRlcHMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgdmFsaWRhdGUoJ2lmICglcyAhPT0gdW5kZWZpbmVkKSB7JywgZ2Vub2JqKGRhdGFTeW0sIGtleSkpO1xuICAgICAgICAgIHZpc2l0KG5hbWUsIGRhdGFTeW0sIGRlcHMsIHJlcG9ydGVyLCBmaWx0ZXIpO1xuICAgICAgICAgIHZhbGlkYXRlKCd9Jyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAodHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgdmFsaWRhdGUoJ30nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobm9kZS5hZGRpdGlvbmFsUHJvcGVydGllcyB8fCBub2RlLmFkZGl0aW9uYWxQcm9wZXJ0aWVzID09PSBmYWxzZSkge1xuICAgICAgaWYgKHR5cGUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHZhbGlkYXRlKCdpZiAoJXMpIHsnLCB0eXBlcy5vYmplY3QoZGF0YVN5bSkpO1xuICAgICAgfVxuXG4gICAgICBsZXQgaSA9IGdlbmxvb3AoKTtcbiAgICAgIGxldCBrZXlzID0gZ2Vuc3ltKCdrZXlzJyk7XG5cbiAgICAgIGxldCB0b0NvbXBhcmUgPSBmdW5jdGlvbihwKSB7XG4gICAgICAgIHJldHVybiBgJHtrZXlzfVske2l9XSAhPT0gJHtKU09OLnN0cmluZ2lmeShwKX1gO1xuICAgICAgfTtcblxuICAgICAgbGV0IHRvVGVzdCA9IGZ1bmN0aW9uKHApIHtcbiAgICAgICAgcmV0dXJuIGAhJHtwYXR0ZXJucyhwKX0udGVzdCgke2tleXN9WyR7aX1dKWA7XG4gICAgICB9O1xuXG4gICAgICBsZXQgYWRkaXRpb25hbFByb3AgPSBPYmplY3Qua2V5cyhwcm9wZXJ0aWVzIHx8IHt9KS5tYXAodG9Db21wYXJlKVxuICAgICAgICAuY29uY2F0KE9iamVjdC5rZXlzKG5vZGUucGF0dGVyblByb3BlcnRpZXMgfHwge30pLm1hcCh0b1Rlc3QpKVxuICAgICAgICAuam9pbignICYmICcpIHx8ICd0cnVlJztcblxuICAgICAgdmFsaWRhdGUoJ3ZhciAlcyA9IE9iamVjdC5rZXlzKCVzKScsIGtleXMsIGRhdGFTeW0pO1xuICAgICAgdmFsaWRhdGUoJyAgZm9yICh2YXIgJXMgPSAwOyAlcyA8ICVzLmxlbmd0aDsgJXMrKykgeycsIGksIGksIGtleXMsIGkpO1xuICAgICAgdmFsaWRhdGUoJyAgICBpZiAoJXMpIHsnLCBhZGRpdGlvbmFsUHJvcCk7XG5cbiAgICAgIGlmIChub2RlLmFkZGl0aW9uYWxQcm9wZXJ0aWVzID09PSBmYWxzZSkge1xuICAgICAgICBpZiAoZmlsdGVyKSB7XG4gICAgICAgICAgdmFsaWRhdGUoXG4gICAgICAgICAgICAnZGVsZXRlICVzJyxcbiAgICAgICAgICAgIGAke2RhdGFTeW19WyR7a2V5c31bJHtpfV1dYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgZXJyb3IoXG4gICAgICAgICAgJ2hhcyBhZGRpdGlvbmFsIHByb3BlcnRpZXMnLCBudWxsLFxuICAgICAgICAgIGAke0pTT04uc3RyaW5naWZ5KG5hbWUgKyAnLicpfSArICR7a2V5c31bJHtpfV1gXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2aXNpdChcbiAgICAgICAgICBgJHtuYW1lfVske2tleXN9WyR7aX1dXWAsXG4gICAgICAgICAgYCR7ZGF0YVN5bX1bJHtrZXlzfVske2l9XV1gLFxuICAgICAgICAgIG5vZGUuYWRkaXRpb25hbFByb3BlcnRpZXMsIHJlcG9ydGVyLCBmaWx0ZXJcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgdmFsaWRhdGUoJyAgfScpO1xuICAgICAgdmFsaWRhdGUoJ30nKTtcblxuICAgICAgaWYgKHR5cGUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHZhbGlkYXRlKCd9Jyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG5vZGUuJHJlZikge1xuICAgICAgbGV0IHN1YiA9IGdldFNjaGVtYUJ5UmVmKHJvb3QsIG9wdHMgJiYgb3B0cy5zY2hlbWFzIHx8IHt9LCBub2RlLiRyZWYpO1xuICAgICAgaWYgKHN1Yikge1xuICAgICAgICBsZXQgZm4gPSBjYWNoZVtub2RlLiRyZWZdO1xuICAgICAgICBpZiAoIWZuKSB7XG4gICAgICAgICAgY2FjaGVbbm9kZS4kcmVmXSA9IGZ1bmN0aW9uIHByb3h5KGRhdGEpIHtcbiAgICAgICAgICAgIHJldHVybiBmbihkYXRhKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIGZuID0gY29tcGlsZShzdWIsIGNhY2hlLCByb290LCB7Li4ub3B0cywgcmVwb3J0ZXI6IGZhbHNlfSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG4gPSBnZW5zeW0oJ3JlZicpO1xuICAgICAgICBzY29wZVtuXSA9IGZuO1xuICAgICAgICB2YWxpZGF0ZSgnaWYgKCEoJXMoJXMpKSkgeycsIG4sIGRhdGFTeW0pO1xuICAgICAgICBlcnJvcigncmVmZXJlbmNlZCBzY2hlbWEgZG9lcyBub3QgbWF0Y2gnKTtcbiAgICAgICAgdmFsaWRhdGUoJ30nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobm9kZS5ub3QpIHtcbiAgICAgIGxldCBwcmV2ID0gZ2Vuc3ltKCdwcmV2Jyk7XG4gICAgICB2YWxpZGF0ZSgndmFyICVzID0gZXJyb3JzJywgcHJldik7XG4gICAgICB2aXNpdChuYW1lLCBkYXRhU3ltLCBub2RlLm5vdCwgZmFsc2UsIGZpbHRlcik7XG4gICAgICB2YWxpZGF0ZSgnaWYgKCVzID09PSBlcnJvcnMpIHsnLCBwcmV2KTtcbiAgICAgIGVycm9yKCduZWdhdGl2ZSBzY2hlbWEgbWF0Y2hlcycpO1xuICAgICAgdmFsaWRhdGUoJ30gZWxzZSB7Jyk7XG4gICAgICB2YWxpZGF0ZSgnZXJyb3JzID0gJXMnLCBwcmV2KTtcbiAgICAgIHZhbGlkYXRlKCd9Jyk7XG4gICAgfVxuXG4gICAgaWYgKG5vZGUuaXRlbXMgJiYgIXR1cGxlKSB7XG4gICAgICBpZiAodHlwZSAhPT0gJ2FycmF5Jykge1xuICAgICAgICB2YWxpZGF0ZSgnaWYgKCVzKSB7JywgdHlwZXMuYXJyYXkoZGF0YVN5bSkpO1xuICAgICAgfVxuXG4gICAgICBsZXQgaSA9IGdlbmxvb3AoKTtcbiAgICAgIHZhbGlkYXRlKCdmb3IgKHZhciAlcyA9IDA7ICVzIDwgJXMubGVuZ3RoOyAlcysrKSB7JywgaSwgaSwgZGF0YVN5bSwgaSk7XG4gICAgICB2aXNpdChcbiAgICAgICAgYCR7bmFtZX1bJHtpfV1gLFxuICAgICAgICBgJHtkYXRhU3ltfVske2l9XWAsXG4gICAgICAgIG5vZGUuaXRlbXMsIHJlcG9ydGVyLCBmaWx0ZXJcbiAgICAgICk7XG4gICAgICB2YWxpZGF0ZSgnfScpO1xuXG4gICAgICBpZiAodHlwZSAhPT0gJ2FycmF5Jykge1xuICAgICAgICB2YWxpZGF0ZSgnfScpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChub2RlLnBhdHRlcm5Qcm9wZXJ0aWVzKSB7XG4gICAgICBpZiAodHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgdmFsaWRhdGUoJ2lmICglcykgeycsIHR5cGVzLm9iamVjdChkYXRhU3ltKSk7XG4gICAgICB9XG4gICAgICBsZXQga2V5cyA9IGdlbnN5bSgna2V5cycpO1xuICAgICAgbGV0IGkgPSBnZW5sb29wKCk7XG4gICAgICB2YWxpZGF0ZSgndmFyICVzID0gT2JqZWN0LmtleXMoJXMpJywga2V5cywgZGF0YVN5bSk7XG4gICAgICB2YWxpZGF0ZSgnZm9yICh2YXIgJXMgPSAwOyAlcyA8ICVzLmxlbmd0aDsgJXMrKykgeycsIGksIGksIGtleXMsIGkpO1xuXG4gICAgICBPYmplY3Qua2V5cyhub2RlLnBhdHRlcm5Qcm9wZXJ0aWVzKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICBsZXQgcCA9IHBhdHRlcm5zKGtleSk7XG4gICAgICAgIHZhbGlkYXRlKCdpZiAoJXMudGVzdCglcykpIHsnLCBwLCBgJHtrZXlzfVske2l9XWApO1xuICAgICAgICB2aXNpdChcbiAgICAgICAgICBgJHtuYW1lfVske2tleXN9WyR7aX1dXWAsXG4gICAgICAgICAgYCR7ZGF0YVN5bX1bJHtrZXlzfVske2l9XV1gLCBub2RlLnBhdHRlcm5Qcm9wZXJ0aWVzW2tleV0sIHJlcG9ydGVyLCBmaWx0ZXJcbiAgICAgICAgKTtcbiAgICAgICAgdmFsaWRhdGUoJ30nKTtcbiAgICAgIH0pO1xuXG4gICAgICB2YWxpZGF0ZSgnfScpO1xuICAgICAgaWYgKHR5cGUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHZhbGlkYXRlKCd9Jyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG5vZGUucGF0dGVybikge1xuICAgICAgbGV0IHAgPSBwYXR0ZXJucyhub2RlLnBhdHRlcm4pO1xuICAgICAgaWYgKHR5cGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHZhbGlkYXRlKCdpZiAoJXMpIHsnLCB0eXBlcy5zdHJpbmcoZGF0YVN5bSkpO1xuICAgICAgfVxuICAgICAgdmFsaWRhdGUoJ2lmICghKCVzLnRlc3QoJXMpKSkgeycsIHAsIGRhdGFTeW0pO1xuICAgICAgZXJyb3IoJ3BhdHRlcm4gbWlzbWF0Y2gnKTtcbiAgICAgIHZhbGlkYXRlKCd9Jyk7XG4gICAgICBpZiAodHlwZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdmFsaWRhdGUoJ30nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobm9kZS5hbGxPZikge1xuICAgICAgbm9kZS5hbGxPZi5mb3JFYWNoKGZ1bmN0aW9uKHNjaCkge1xuICAgICAgICB2aXNpdChuYW1lLCBkYXRhU3ltLCBzY2gsIHJlcG9ydGVyLCBmaWx0ZXIpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKG5vZGUuYW55T2YgJiYgbm9kZS5hbnlPZi5sZW5ndGgpIHtcbiAgICAgIGxldCBwcmV2ID0gZ2Vuc3ltKCdwcmV2Jyk7XG5cbiAgICAgIG5vZGUuYW55T2YuZm9yRWFjaChmdW5jdGlvbihzY2gsIGkpIHtcbiAgICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgICB2YWxpZGF0ZSgndmFyICVzID0gZXJyb3JzJywgcHJldik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsaWRhdGUoJ2lmIChlcnJvcnMgIT09ICVzKSB7JywgcHJldik7XG4gICAgICAgICAgdmFsaWRhdGUoJ2Vycm9ycyA9ICVzJywgcHJldik7XG4gICAgICAgIH1cbiAgICAgICAgdmlzaXQobmFtZSwgZGF0YVN5bSwgc2NoLCBmYWxzZSwgZmFsc2UpO1xuICAgICAgfSk7XG4gICAgICBub2RlLmFueU9mLmZvckVhY2goZnVuY3Rpb24oc2NoLCBpKSB7XG4gICAgICAgIGlmIChpKSB7XG4gICAgICAgICAgdmFsaWRhdGUoJ30nKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB2YWxpZGF0ZSgnaWYgKCVzICE9PSBlcnJvcnMpIHsnLCBwcmV2KTtcbiAgICAgIGVycm9yKCdubyBzY2hlbWFzIG1hdGNoJyk7XG4gICAgICB2YWxpZGF0ZSgnfScpO1xuICAgIH1cblxuICAgIGlmIChub2RlLm9uZU9mICYmIG5vZGUub25lT2YubGVuZ3RoKSB7XG4gICAgICBsZXQgcHJldiA9IGdlbnN5bSgncHJldicpO1xuICAgICAgbGV0IHBhc3NlcyA9IGdlbnN5bSgncGFzc2VzJyk7XG5cbiAgICAgIHZhbGlkYXRlKCd2YXIgJXMgPSBlcnJvcnMnLCBwcmV2KTtcbiAgICAgIHZhbGlkYXRlKCd2YXIgJXMgPSAwJywgcGFzc2VzKTtcblxuICAgICAgbm9kZS5vbmVPZi5mb3JFYWNoKGZ1bmN0aW9uKHNjaCkge1xuICAgICAgICB2aXNpdChuYW1lLCBkYXRhU3ltLCBzY2gsIGZhbHNlLCBmYWxzZSk7XG4gICAgICAgIHZhbGlkYXRlKCdpZiAoJXMgPT09IGVycm9ycykgeycsIHByZXYpO1xuICAgICAgICB2YWxpZGF0ZSgnICAlcysrJywgcGFzc2VzKTtcbiAgICAgICAgdmFsaWRhdGUoJ30gZWxzZSB7Jyk7XG4gICAgICAgIHZhbGlkYXRlKCcgIGVycm9ycyA9ICVzJywgcHJldik7XG4gICAgICAgIHZhbGlkYXRlKCd9Jyk7XG4gICAgICB9KTtcblxuICAgICAgdmFsaWRhdGUoJ2lmICglcyAhPT0gMSkgeycsIHBhc3Nlcyk7XG4gICAgICBlcnJvcignbm8gKG9yIG1vcmUgdGhhbiBvbmUpIHNjaGVtYXMgbWF0Y2gnKTtcbiAgICAgIHZhbGlkYXRlKCd9Jyk7XG4gICAgfVxuXG4gICAgaWYgKG5vZGUubXVsdGlwbGVPZiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAodHlwZSAhPT0gJ251bWJlcicgJiYgdHlwZSAhPT0gJ2ludGVnZXInKSB7XG4gICAgICAgIHZhbGlkYXRlKCdpZiAoJXMpIHsnLCB0eXBlcy5udW1iZXIoZGF0YVN5bSkpO1xuICAgICAgfVxuXG4gICAgICBsZXQgZmFjdG9yID0gKChub2RlLm11bHRpcGxlT2YgfCAwKSAhPT0gbm9kZS5tdWx0aXBsZU9mKSA/XG4gICAgICAgIE1hdGgucG93KDEwLCBub2RlLm11bHRpcGxlT2YudG9TdHJpbmcoKS5zcGxpdCgnLicpLnBvcCgpLmxlbmd0aCkgOlxuICAgICAgICAxO1xuXG4gICAgICBpZiAoZmFjdG9yID4gMSkge1xuICAgICAgICB2YWxpZGF0ZSgnaWYgKCglZColcykgJSAlZCkgeycsIGZhY3RvciwgZGF0YVN5bSwgZmFjdG9yICogbm9kZS5tdWx0aXBsZU9mKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbGlkYXRlKCdpZiAoJXMgJSAlZCkgeycsIGRhdGFTeW0sIG5vZGUubXVsdGlwbGVPZik7XG4gICAgICB9XG5cbiAgICAgIGVycm9yKCdoYXMgYSByZW1haW5kZXInKTtcbiAgICAgIHZhbGlkYXRlKCd9Jyk7XG5cbiAgICAgIGlmICh0eXBlICE9PSAnbnVtYmVyJyAmJiB0eXBlICE9PSAnaW50ZWdlcicpIHtcbiAgICAgICAgdmFsaWRhdGUoJ30nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobm9kZS5tYXhQcm9wZXJ0aWVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmICh0eXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICB2YWxpZGF0ZSgnaWYgKCVzKSB7JywgdHlwZXMub2JqZWN0KGRhdGFTeW0pKTtcbiAgICAgIH1cblxuICAgICAgdmFsaWRhdGUoJ2lmIChPYmplY3Qua2V5cyglcykubGVuZ3RoID4gJWQpIHsnLCBkYXRhU3ltLCBub2RlLm1heFByb3BlcnRpZXMpO1xuICAgICAgZXJyb3IoJ2hhcyBtb3JlIHByb3BlcnRpZXMgdGhhbiBhbGxvd2VkJyk7XG4gICAgICB2YWxpZGF0ZSgnfScpO1xuXG4gICAgICBpZiAodHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgdmFsaWRhdGUoJ30nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobm9kZS5taW5Qcm9wZXJ0aWVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmICh0eXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICB2YWxpZGF0ZSgnaWYgKCVzKSB7JywgdHlwZXMub2JqZWN0KGRhdGFTeW0pKTtcbiAgICAgIH1cblxuICAgICAgdmFsaWRhdGUoJ2lmIChPYmplY3Qua2V5cyglcykubGVuZ3RoIDwgJWQpIHsnLCBkYXRhU3ltLCBub2RlLm1pblByb3BlcnRpZXMpO1xuICAgICAgZXJyb3IoJ2hhcyBsZXNzIHByb3BlcnRpZXMgdGhhbiBhbGxvd2VkJyk7XG4gICAgICB2YWxpZGF0ZSgnfScpO1xuXG4gICAgICBpZiAodHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgdmFsaWRhdGUoJ30nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobm9kZS5tYXhJdGVtcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAodHlwZSAhPT0gJ2FycmF5Jykge1xuICAgICAgICB2YWxpZGF0ZSgnaWYgKCVzKSB7JywgdHlwZXMuYXJyYXkoZGF0YVN5bSkpO1xuICAgICAgfVxuXG4gICAgICB2YWxpZGF0ZSgnaWYgKCVzLmxlbmd0aCA+ICVkKSB7JywgZGF0YVN5bSwgbm9kZS5tYXhJdGVtcyk7XG4gICAgICBlcnJvcignaGFzIG1vcmUgaXRlbXMgdGhhbiBhbGxvd2VkJyk7XG4gICAgICB2YWxpZGF0ZSgnfScpO1xuXG4gICAgICBpZiAodHlwZSAhPT0gJ2FycmF5Jykge1xuICAgICAgICB2YWxpZGF0ZSgnfScpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChub2RlLm1pbkl0ZW1zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmICh0eXBlICE9PSAnYXJyYXknKSB7XG4gICAgICAgIHZhbGlkYXRlKCdpZiAoJXMpIHsnLCB0eXBlcy5hcnJheShkYXRhU3ltKSk7XG4gICAgICB9XG5cbiAgICAgIHZhbGlkYXRlKCdpZiAoJXMubGVuZ3RoIDwgJWQpIHsnLCBkYXRhU3ltLCBub2RlLm1pbkl0ZW1zKTtcbiAgICAgIGVycm9yKCdoYXMgbGVzcyBpdGVtcyB0aGFuIGFsbG93ZWQnKTtcbiAgICAgIHZhbGlkYXRlKCd9Jyk7XG5cbiAgICAgIGlmICh0eXBlICE9PSAnYXJyYXknKSB7XG4gICAgICAgIHZhbGlkYXRlKCd9Jyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG5vZGUubWF4TGVuZ3RoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmICh0eXBlICE9PSAnc3RyaW5nJykge1xuICAgICAgICB2YWxpZGF0ZSgnaWYgKCVzKSB7JywgdHlwZXMuc3RyaW5nKGRhdGFTeW0pKTtcbiAgICAgIH1cblxuICAgICAgdmFsaWRhdGUoJ2lmICglcy5sZW5ndGggPiAlZCkgeycsIGRhdGFTeW0sIG5vZGUubWF4TGVuZ3RoKTtcbiAgICAgIGVycm9yKCdoYXMgbG9uZ2VyIGxlbmd0aCB0aGFuIGFsbG93ZWQnKTtcbiAgICAgIHZhbGlkYXRlKCd9Jyk7XG5cbiAgICAgIGlmICh0eXBlICE9PSAnc3RyaW5nJykge1xuICAgICAgICB2YWxpZGF0ZSgnfScpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChub2RlLm1pbkxlbmd0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAodHlwZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdmFsaWRhdGUoJ2lmICglcykgeycsIHR5cGVzLnN0cmluZyhkYXRhU3ltKSk7XG4gICAgICB9XG5cbiAgICAgIHZhbGlkYXRlKCdpZiAoJXMubGVuZ3RoIDwgJWQpIHsnLCBkYXRhU3ltLCBub2RlLm1pbkxlbmd0aCk7XG4gICAgICBlcnJvcignaGFzIGxlc3MgbGVuZ3RoIHRoYW4gYWxsb3dlZCcpO1xuICAgICAgdmFsaWRhdGUoJ30nKTtcblxuICAgICAgaWYgKHR5cGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHZhbGlkYXRlKCd9Jyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG5vZGUubWluaW11bSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YWxpZGF0ZSgnaWYgKCVzICVzICVkKSB7JywgZGF0YVN5bSwgbm9kZS5leGNsdXNpdmVNaW5pbXVtID8gJzw9JyA6ICc8Jywgbm9kZS5taW5pbXVtKTtcbiAgICAgIGVycm9yKCdpcyBsZXNzIHRoYW4gbWluaW11bScpO1xuICAgICAgdmFsaWRhdGUoJ30nKTtcbiAgICB9XG5cbiAgICBpZiAobm9kZS5tYXhpbXVtICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhbGlkYXRlKCdpZiAoJXMgJXMgJWQpIHsnLCBkYXRhU3ltLCBub2RlLmV4Y2x1c2l2ZU1heGltdW0gPyAnPj0nIDogJz4nLCBub2RlLm1heGltdW0pO1xuICAgICAgZXJyb3IoJ2lzIG1vcmUgdGhhbiBtYXhpbXVtJyk7XG4gICAgICB2YWxpZGF0ZSgnfScpO1xuICAgIH1cblxuICAgIGlmIChwcm9wZXJ0aWVzKSB7XG4gICAgICBPYmplY3Qua2V5cyhwcm9wZXJ0aWVzKS5mb3JFYWNoKGZ1bmN0aW9uKHApIHtcbiAgICAgICAgdmlzaXQoZ2Vub2JqKG5hbWUsIHApLCBnZW5vYmooZGF0YVN5bSwgcCksIHByb3BlcnRpZXNbcF0sIHJlcG9ydGVyLCBmaWx0ZXIpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgd2hpbGUgKGluZGVudC0tKSB7XG4gICAgICB2YWxpZGF0ZSgnfScpO1xuICAgIH1cbiAgfVxuXG4gIGxldCB2YWxpZGF0ZSA9IGdlbmZ1bignZnVuY3Rpb24gdmFsaWRhdGUoZGF0YSkgeycpKCd2YWxpZGF0ZS5lcnJvcnMgPSBudWxsJykoJ3ZhciBlcnJvcnMgPSAwJyk7XG5cbiAgdmlzaXQoJ2RhdGEnLCAnZGF0YScsIHNjaGVtYSwgcmVwb3J0ZXIsIG9wdHMgJiYgb3B0cy5maWx0ZXIpO1xuXG4gIHZhbGlkYXRlKCdyZXR1cm4gZXJyb3JzID09PSAwJykoJ30nKTtcblxuICB2YWxpZGF0ZSA9IHZhbGlkYXRlLnRvRnVuY3Rpb24oc2NvcGUpO1xuICB2YWxpZGF0ZS5lcnJvcnMgPSBudWxsO1xuXG4gIHZhbGlkYXRlLl9fZGVmaW5lR2V0dGVyX18oJ2Vycm9yJywgZnVuY3Rpb24oKSB7XG4gICAgaWYgKCF2YWxpZGF0ZS5lcnJvcnMpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHZhbGlkYXRlLmVycm9yc1xuICAgICAgICAubWFwKGVyciA9PiBlcnIuZmllbGQgKyAnICcgKyBlcnIubWVzc2FnZSlcbiAgICAgICAgLmpvaW4oJ1xcbicpO1xuICAgIH1cbiAgfSk7XG5cbiAgdmFsaWRhdGUudG9KU09OID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHNjaGVtYTtcbiAgfTtcblxuICByZXR1cm4gdmFsaWRhdGU7XG59XG5cbi8qKlxuICogQ29tcGlsZSBhIG5ldyBKU09OIFNjaGVtYSB2YWxpZGF0b3IgZm9yIHRoZSBzcGVjaWZpZWQgc2NoZW1hIGFuZCBvcHRpb25zLlxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjb21waWxlVmFsaWRhdG9yKHNjaGVtYSwgb3B0cykge1xuICBpZiAodHlwZW9mIHNjaGVtYSA9PT0gJ3N0cmluZycpIHtcbiAgICBzY2hlbWEgPSBKU09OLnBhcnNlKHNjaGVtYSk7XG4gIH1cbiAgcmV0dXJuIGNvbXBpbGUoc2NoZW1hLCB7fSwgc2NoZW1hLCB7Li4ub3B0cywgcmVwb3J0ZXI6IHRydWV9KTtcbn1cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL0pTT05TY2hlbWEvY29tcGlsZVZhbGlkYXRvci5qc1xuICoqLyIsInZhciBpc1Byb3BlcnR5ID0gcmVxdWlyZSgnaXMtcHJvcGVydHknKVxuXG52YXIgZ2VuID0gZnVuY3Rpb24ob2JqLCBwcm9wKSB7XG4gIHJldHVybiBpc1Byb3BlcnR5KHByb3ApID8gb2JqKycuJytwcm9wIDogb2JqKydbJytKU09OLnN0cmluZ2lmeShwcm9wKSsnXSdcbn1cblxuZ2VuLnZhbGlkID0gaXNQcm9wZXJ0eVxuZ2VuLnByb3BlcnR5ID0gZnVuY3Rpb24gKHByb3ApIHtcbiByZXR1cm4gaXNQcm9wZXJ0eShwcm9wKSA/IHByb3AgOiBKU09OLnN0cmluZ2lmeShwcm9wKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdlblxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vZ2VuZXJhdGUtb2JqZWN0LXByb3BlcnR5L2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gNzBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiXG5mdW5jdGlvbiBpc1Byb3BlcnR5KHN0cikge1xuICByZXR1cm4gL15bJEEtWlxcX2EtelxceGFhXFx4YjVcXHhiYVxceGMwLVxceGQ2XFx4ZDgtXFx4ZjZcXHhmOC1cXHUwMmMxXFx1MDJjNi1cXHUwMmQxXFx1MDJlMC1cXHUwMmU0XFx1MDJlY1xcdTAyZWVcXHUwMzcwLVxcdTAzNzRcXHUwMzc2XFx1MDM3N1xcdTAzN2EtXFx1MDM3ZFxcdTAzODZcXHUwMzg4LVxcdTAzOGFcXHUwMzhjXFx1MDM4ZS1cXHUwM2ExXFx1MDNhMy1cXHUwM2Y1XFx1MDNmNy1cXHUwNDgxXFx1MDQ4YS1cXHUwNTI3XFx1MDUzMS1cXHUwNTU2XFx1MDU1OVxcdTA1NjEtXFx1MDU4N1xcdTA1ZDAtXFx1MDVlYVxcdTA1ZjAtXFx1MDVmMlxcdTA2MjAtXFx1MDY0YVxcdTA2NmVcXHUwNjZmXFx1MDY3MS1cXHUwNmQzXFx1MDZkNVxcdTA2ZTVcXHUwNmU2XFx1MDZlZVxcdTA2ZWZcXHUwNmZhLVxcdTA2ZmNcXHUwNmZmXFx1MDcxMFxcdTA3MTItXFx1MDcyZlxcdTA3NGQtXFx1MDdhNVxcdTA3YjFcXHUwN2NhLVxcdTA3ZWFcXHUwN2Y0XFx1MDdmNVxcdTA3ZmFcXHUwODAwLVxcdTA4MTVcXHUwODFhXFx1MDgyNFxcdTA4MjhcXHUwODQwLVxcdTA4NThcXHUwOGEwXFx1MDhhMi1cXHUwOGFjXFx1MDkwNC1cXHUwOTM5XFx1MDkzZFxcdTA5NTBcXHUwOTU4LVxcdTA5NjFcXHUwOTcxLVxcdTA5NzdcXHUwOTc5LVxcdTA5N2ZcXHUwOTg1LVxcdTA5OGNcXHUwOThmXFx1MDk5MFxcdTA5OTMtXFx1MDlhOFxcdTA5YWEtXFx1MDliMFxcdTA5YjJcXHUwOWI2LVxcdTA5YjlcXHUwOWJkXFx1MDljZVxcdTA5ZGNcXHUwOWRkXFx1MDlkZi1cXHUwOWUxXFx1MDlmMFxcdTA5ZjFcXHUwYTA1LVxcdTBhMGFcXHUwYTBmXFx1MGExMFxcdTBhMTMtXFx1MGEyOFxcdTBhMmEtXFx1MGEzMFxcdTBhMzJcXHUwYTMzXFx1MGEzNVxcdTBhMzZcXHUwYTM4XFx1MGEzOVxcdTBhNTktXFx1MGE1Y1xcdTBhNWVcXHUwYTcyLVxcdTBhNzRcXHUwYTg1LVxcdTBhOGRcXHUwYThmLVxcdTBhOTFcXHUwYTkzLVxcdTBhYThcXHUwYWFhLVxcdTBhYjBcXHUwYWIyXFx1MGFiM1xcdTBhYjUtXFx1MGFiOVxcdTBhYmRcXHUwYWQwXFx1MGFlMFxcdTBhZTFcXHUwYjA1LVxcdTBiMGNcXHUwYjBmXFx1MGIxMFxcdTBiMTMtXFx1MGIyOFxcdTBiMmEtXFx1MGIzMFxcdTBiMzJcXHUwYjMzXFx1MGIzNS1cXHUwYjM5XFx1MGIzZFxcdTBiNWNcXHUwYjVkXFx1MGI1Zi1cXHUwYjYxXFx1MGI3MVxcdTBiODNcXHUwYjg1LVxcdTBiOGFcXHUwYjhlLVxcdTBiOTBcXHUwYjkyLVxcdTBiOTVcXHUwYjk5XFx1MGI5YVxcdTBiOWNcXHUwYjllXFx1MGI5ZlxcdTBiYTNcXHUwYmE0XFx1MGJhOC1cXHUwYmFhXFx1MGJhZS1cXHUwYmI5XFx1MGJkMFxcdTBjMDUtXFx1MGMwY1xcdTBjMGUtXFx1MGMxMFxcdTBjMTItXFx1MGMyOFxcdTBjMmEtXFx1MGMzM1xcdTBjMzUtXFx1MGMzOVxcdTBjM2RcXHUwYzU4XFx1MGM1OVxcdTBjNjBcXHUwYzYxXFx1MGM4NS1cXHUwYzhjXFx1MGM4ZS1cXHUwYzkwXFx1MGM5Mi1cXHUwY2E4XFx1MGNhYS1cXHUwY2IzXFx1MGNiNS1cXHUwY2I5XFx1MGNiZFxcdTBjZGVcXHUwY2UwXFx1MGNlMVxcdTBjZjFcXHUwY2YyXFx1MGQwNS1cXHUwZDBjXFx1MGQwZS1cXHUwZDEwXFx1MGQxMi1cXHUwZDNhXFx1MGQzZFxcdTBkNGVcXHUwZDYwXFx1MGQ2MVxcdTBkN2EtXFx1MGQ3ZlxcdTBkODUtXFx1MGQ5NlxcdTBkOWEtXFx1MGRiMVxcdTBkYjMtXFx1MGRiYlxcdTBkYmRcXHUwZGMwLVxcdTBkYzZcXHUwZTAxLVxcdTBlMzBcXHUwZTMyXFx1MGUzM1xcdTBlNDAtXFx1MGU0NlxcdTBlODFcXHUwZTgyXFx1MGU4NFxcdTBlODdcXHUwZTg4XFx1MGU4YVxcdTBlOGRcXHUwZTk0LVxcdTBlOTdcXHUwZTk5LVxcdTBlOWZcXHUwZWExLVxcdTBlYTNcXHUwZWE1XFx1MGVhN1xcdTBlYWFcXHUwZWFiXFx1MGVhZC1cXHUwZWIwXFx1MGViMlxcdTBlYjNcXHUwZWJkXFx1MGVjMC1cXHUwZWM0XFx1MGVjNlxcdTBlZGMtXFx1MGVkZlxcdTBmMDBcXHUwZjQwLVxcdTBmNDdcXHUwZjQ5LVxcdTBmNmNcXHUwZjg4LVxcdTBmOGNcXHUxMDAwLVxcdTEwMmFcXHUxMDNmXFx1MTA1MC1cXHUxMDU1XFx1MTA1YS1cXHUxMDVkXFx1MTA2MVxcdTEwNjVcXHUxMDY2XFx1MTA2ZS1cXHUxMDcwXFx1MTA3NS1cXHUxMDgxXFx1MTA4ZVxcdTEwYTAtXFx1MTBjNVxcdTEwYzdcXHUxMGNkXFx1MTBkMC1cXHUxMGZhXFx1MTBmYy1cXHUxMjQ4XFx1MTI0YS1cXHUxMjRkXFx1MTI1MC1cXHUxMjU2XFx1MTI1OFxcdTEyNWEtXFx1MTI1ZFxcdTEyNjAtXFx1MTI4OFxcdTEyOGEtXFx1MTI4ZFxcdTEyOTAtXFx1MTJiMFxcdTEyYjItXFx1MTJiNVxcdTEyYjgtXFx1MTJiZVxcdTEyYzBcXHUxMmMyLVxcdTEyYzVcXHUxMmM4LVxcdTEyZDZcXHUxMmQ4LVxcdTEzMTBcXHUxMzEyLVxcdTEzMTVcXHUxMzE4LVxcdTEzNWFcXHUxMzgwLVxcdTEzOGZcXHUxM2EwLVxcdTEzZjRcXHUxNDAxLVxcdTE2NmNcXHUxNjZmLVxcdTE2N2ZcXHUxNjgxLVxcdTE2OWFcXHUxNmEwLVxcdTE2ZWFcXHUxNmVlLVxcdTE2ZjBcXHUxNzAwLVxcdTE3MGNcXHUxNzBlLVxcdTE3MTFcXHUxNzIwLVxcdTE3MzFcXHUxNzQwLVxcdTE3NTFcXHUxNzYwLVxcdTE3NmNcXHUxNzZlLVxcdTE3NzBcXHUxNzgwLVxcdTE3YjNcXHUxN2Q3XFx1MTdkY1xcdTE4MjAtXFx1MTg3N1xcdTE4ODAtXFx1MThhOFxcdTE4YWFcXHUxOGIwLVxcdTE4ZjVcXHUxOTAwLVxcdTE5MWNcXHUxOTUwLVxcdTE5NmRcXHUxOTcwLVxcdTE5NzRcXHUxOTgwLVxcdTE5YWJcXHUxOWMxLVxcdTE5YzdcXHUxYTAwLVxcdTFhMTZcXHUxYTIwLVxcdTFhNTRcXHUxYWE3XFx1MWIwNS1cXHUxYjMzXFx1MWI0NS1cXHUxYjRiXFx1MWI4My1cXHUxYmEwXFx1MWJhZVxcdTFiYWZcXHUxYmJhLVxcdTFiZTVcXHUxYzAwLVxcdTFjMjNcXHUxYzRkLVxcdTFjNGZcXHUxYzVhLVxcdTFjN2RcXHUxY2U5LVxcdTFjZWNcXHUxY2VlLVxcdTFjZjFcXHUxY2Y1XFx1MWNmNlxcdTFkMDAtXFx1MWRiZlxcdTFlMDAtXFx1MWYxNVxcdTFmMTgtXFx1MWYxZFxcdTFmMjAtXFx1MWY0NVxcdTFmNDgtXFx1MWY0ZFxcdTFmNTAtXFx1MWY1N1xcdTFmNTlcXHUxZjViXFx1MWY1ZFxcdTFmNWYtXFx1MWY3ZFxcdTFmODAtXFx1MWZiNFxcdTFmYjYtXFx1MWZiY1xcdTFmYmVcXHUxZmMyLVxcdTFmYzRcXHUxZmM2LVxcdTFmY2NcXHUxZmQwLVxcdTFmZDNcXHUxZmQ2LVxcdTFmZGJcXHUxZmUwLVxcdTFmZWNcXHUxZmYyLVxcdTFmZjRcXHUxZmY2LVxcdTFmZmNcXHUyMDcxXFx1MjA3ZlxcdTIwOTAtXFx1MjA5Y1xcdTIxMDJcXHUyMTA3XFx1MjEwYS1cXHUyMTEzXFx1MjExNVxcdTIxMTktXFx1MjExZFxcdTIxMjRcXHUyMTI2XFx1MjEyOFxcdTIxMmEtXFx1MjEyZFxcdTIxMmYtXFx1MjEzOVxcdTIxM2MtXFx1MjEzZlxcdTIxNDUtXFx1MjE0OVxcdTIxNGVcXHUyMTYwLVxcdTIxODhcXHUyYzAwLVxcdTJjMmVcXHUyYzMwLVxcdTJjNWVcXHUyYzYwLVxcdTJjZTRcXHUyY2ViLVxcdTJjZWVcXHUyY2YyXFx1MmNmM1xcdTJkMDAtXFx1MmQyNVxcdTJkMjdcXHUyZDJkXFx1MmQzMC1cXHUyZDY3XFx1MmQ2ZlxcdTJkODAtXFx1MmQ5NlxcdTJkYTAtXFx1MmRhNlxcdTJkYTgtXFx1MmRhZVxcdTJkYjAtXFx1MmRiNlxcdTJkYjgtXFx1MmRiZVxcdTJkYzAtXFx1MmRjNlxcdTJkYzgtXFx1MmRjZVxcdTJkZDAtXFx1MmRkNlxcdTJkZDgtXFx1MmRkZVxcdTJlMmZcXHUzMDA1LVxcdTMwMDdcXHUzMDIxLVxcdTMwMjlcXHUzMDMxLVxcdTMwMzVcXHUzMDM4LVxcdTMwM2NcXHUzMDQxLVxcdTMwOTZcXHUzMDlkLVxcdTMwOWZcXHUzMGExLVxcdTMwZmFcXHUzMGZjLVxcdTMwZmZcXHUzMTA1LVxcdTMxMmRcXHUzMTMxLVxcdTMxOGVcXHUzMWEwLVxcdTMxYmFcXHUzMWYwLVxcdTMxZmZcXHUzNDAwLVxcdTRkYjVcXHU0ZTAwLVxcdTlmY2NcXHVhMDAwLVxcdWE0OGNcXHVhNGQwLVxcdWE0ZmRcXHVhNTAwLVxcdWE2MGNcXHVhNjEwLVxcdWE2MWZcXHVhNjJhXFx1YTYyYlxcdWE2NDAtXFx1YTY2ZVxcdWE2N2YtXFx1YTY5N1xcdWE2YTAtXFx1YTZlZlxcdWE3MTctXFx1YTcxZlxcdWE3MjItXFx1YTc4OFxcdWE3OGItXFx1YTc4ZVxcdWE3OTAtXFx1YTc5M1xcdWE3YTAtXFx1YTdhYVxcdWE3ZjgtXFx1YTgwMVxcdWE4MDMtXFx1YTgwNVxcdWE4MDctXFx1YTgwYVxcdWE4MGMtXFx1YTgyMlxcdWE4NDAtXFx1YTg3M1xcdWE4ODItXFx1YThiM1xcdWE4ZjItXFx1YThmN1xcdWE4ZmJcXHVhOTBhLVxcdWE5MjVcXHVhOTMwLVxcdWE5NDZcXHVhOTYwLVxcdWE5N2NcXHVhOTg0LVxcdWE5YjJcXHVhOWNmXFx1YWEwMC1cXHVhYTI4XFx1YWE0MC1cXHVhYTQyXFx1YWE0NC1cXHVhYTRiXFx1YWE2MC1cXHVhYTc2XFx1YWE3YVxcdWFhODAtXFx1YWFhZlxcdWFhYjFcXHVhYWI1XFx1YWFiNlxcdWFhYjktXFx1YWFiZFxcdWFhYzBcXHVhYWMyXFx1YWFkYi1cXHVhYWRkXFx1YWFlMC1cXHVhYWVhXFx1YWFmMi1cXHVhYWY0XFx1YWIwMS1cXHVhYjA2XFx1YWIwOS1cXHVhYjBlXFx1YWIxMS1cXHVhYjE2XFx1YWIyMC1cXHVhYjI2XFx1YWIyOC1cXHVhYjJlXFx1YWJjMC1cXHVhYmUyXFx1YWMwMC1cXHVkN2EzXFx1ZDdiMC1cXHVkN2M2XFx1ZDdjYi1cXHVkN2ZiXFx1ZjkwMC1cXHVmYTZkXFx1ZmE3MC1cXHVmYWQ5XFx1ZmIwMC1cXHVmYjA2XFx1ZmIxMy1cXHVmYjE3XFx1ZmIxZFxcdWZiMWYtXFx1ZmIyOFxcdWZiMmEtXFx1ZmIzNlxcdWZiMzgtXFx1ZmIzY1xcdWZiM2VcXHVmYjQwXFx1ZmI0MVxcdWZiNDNcXHVmYjQ0XFx1ZmI0Ni1cXHVmYmIxXFx1ZmJkMy1cXHVmZDNkXFx1ZmQ1MC1cXHVmZDhmXFx1ZmQ5Mi1cXHVmZGM3XFx1ZmRmMC1cXHVmZGZiXFx1ZmU3MC1cXHVmZTc0XFx1ZmU3Ni1cXHVmZWZjXFx1ZmYyMS1cXHVmZjNhXFx1ZmY0MS1cXHVmZjVhXFx1ZmY2Ni1cXHVmZmJlXFx1ZmZjMi1cXHVmZmM3XFx1ZmZjYS1cXHVmZmNmXFx1ZmZkMi1cXHVmZmQ3XFx1ZmZkYS1cXHVmZmRjXVskQS1aXFxfYS16XFx4YWFcXHhiNVxceGJhXFx4YzAtXFx4ZDZcXHhkOC1cXHhmNlxceGY4LVxcdTAyYzFcXHUwMmM2LVxcdTAyZDFcXHUwMmUwLVxcdTAyZTRcXHUwMmVjXFx1MDJlZVxcdTAzNzAtXFx1MDM3NFxcdTAzNzZcXHUwMzc3XFx1MDM3YS1cXHUwMzdkXFx1MDM4NlxcdTAzODgtXFx1MDM4YVxcdTAzOGNcXHUwMzhlLVxcdTAzYTFcXHUwM2EzLVxcdTAzZjVcXHUwM2Y3LVxcdTA0ODFcXHUwNDhhLVxcdTA1MjdcXHUwNTMxLVxcdTA1NTZcXHUwNTU5XFx1MDU2MS1cXHUwNTg3XFx1MDVkMC1cXHUwNWVhXFx1MDVmMC1cXHUwNWYyXFx1MDYyMC1cXHUwNjRhXFx1MDY2ZVxcdTA2NmZcXHUwNjcxLVxcdTA2ZDNcXHUwNmQ1XFx1MDZlNVxcdTA2ZTZcXHUwNmVlXFx1MDZlZlxcdTA2ZmEtXFx1MDZmY1xcdTA2ZmZcXHUwNzEwXFx1MDcxMi1cXHUwNzJmXFx1MDc0ZC1cXHUwN2E1XFx1MDdiMVxcdTA3Y2EtXFx1MDdlYVxcdTA3ZjRcXHUwN2Y1XFx1MDdmYVxcdTA4MDAtXFx1MDgxNVxcdTA4MWFcXHUwODI0XFx1MDgyOFxcdTA4NDAtXFx1MDg1OFxcdTA4YTBcXHUwOGEyLVxcdTA4YWNcXHUwOTA0LVxcdTA5MzlcXHUwOTNkXFx1MDk1MFxcdTA5NTgtXFx1MDk2MVxcdTA5NzEtXFx1MDk3N1xcdTA5NzktXFx1MDk3ZlxcdTA5ODUtXFx1MDk4Y1xcdTA5OGZcXHUwOTkwXFx1MDk5My1cXHUwOWE4XFx1MDlhYS1cXHUwOWIwXFx1MDliMlxcdTA5YjYtXFx1MDliOVxcdTA5YmRcXHUwOWNlXFx1MDlkY1xcdTA5ZGRcXHUwOWRmLVxcdTA5ZTFcXHUwOWYwXFx1MDlmMVxcdTBhMDUtXFx1MGEwYVxcdTBhMGZcXHUwYTEwXFx1MGExMy1cXHUwYTI4XFx1MGEyYS1cXHUwYTMwXFx1MGEzMlxcdTBhMzNcXHUwYTM1XFx1MGEzNlxcdTBhMzhcXHUwYTM5XFx1MGE1OS1cXHUwYTVjXFx1MGE1ZVxcdTBhNzItXFx1MGE3NFxcdTBhODUtXFx1MGE4ZFxcdTBhOGYtXFx1MGE5MVxcdTBhOTMtXFx1MGFhOFxcdTBhYWEtXFx1MGFiMFxcdTBhYjJcXHUwYWIzXFx1MGFiNS1cXHUwYWI5XFx1MGFiZFxcdTBhZDBcXHUwYWUwXFx1MGFlMVxcdTBiMDUtXFx1MGIwY1xcdTBiMGZcXHUwYjEwXFx1MGIxMy1cXHUwYjI4XFx1MGIyYS1cXHUwYjMwXFx1MGIzMlxcdTBiMzNcXHUwYjM1LVxcdTBiMzlcXHUwYjNkXFx1MGI1Y1xcdTBiNWRcXHUwYjVmLVxcdTBiNjFcXHUwYjcxXFx1MGI4M1xcdTBiODUtXFx1MGI4YVxcdTBiOGUtXFx1MGI5MFxcdTBiOTItXFx1MGI5NVxcdTBiOTlcXHUwYjlhXFx1MGI5Y1xcdTBiOWVcXHUwYjlmXFx1MGJhM1xcdTBiYTRcXHUwYmE4LVxcdTBiYWFcXHUwYmFlLVxcdTBiYjlcXHUwYmQwXFx1MGMwNS1cXHUwYzBjXFx1MGMwZS1cXHUwYzEwXFx1MGMxMi1cXHUwYzI4XFx1MGMyYS1cXHUwYzMzXFx1MGMzNS1cXHUwYzM5XFx1MGMzZFxcdTBjNThcXHUwYzU5XFx1MGM2MFxcdTBjNjFcXHUwYzg1LVxcdTBjOGNcXHUwYzhlLVxcdTBjOTBcXHUwYzkyLVxcdTBjYThcXHUwY2FhLVxcdTBjYjNcXHUwY2I1LVxcdTBjYjlcXHUwY2JkXFx1MGNkZVxcdTBjZTBcXHUwY2UxXFx1MGNmMVxcdTBjZjJcXHUwZDA1LVxcdTBkMGNcXHUwZDBlLVxcdTBkMTBcXHUwZDEyLVxcdTBkM2FcXHUwZDNkXFx1MGQ0ZVxcdTBkNjBcXHUwZDYxXFx1MGQ3YS1cXHUwZDdmXFx1MGQ4NS1cXHUwZDk2XFx1MGQ5YS1cXHUwZGIxXFx1MGRiMy1cXHUwZGJiXFx1MGRiZFxcdTBkYzAtXFx1MGRjNlxcdTBlMDEtXFx1MGUzMFxcdTBlMzJcXHUwZTMzXFx1MGU0MC1cXHUwZTQ2XFx1MGU4MVxcdTBlODJcXHUwZTg0XFx1MGU4N1xcdTBlODhcXHUwZThhXFx1MGU4ZFxcdTBlOTQtXFx1MGU5N1xcdTBlOTktXFx1MGU5ZlxcdTBlYTEtXFx1MGVhM1xcdTBlYTVcXHUwZWE3XFx1MGVhYVxcdTBlYWJcXHUwZWFkLVxcdTBlYjBcXHUwZWIyXFx1MGViM1xcdTBlYmRcXHUwZWMwLVxcdTBlYzRcXHUwZWM2XFx1MGVkYy1cXHUwZWRmXFx1MGYwMFxcdTBmNDAtXFx1MGY0N1xcdTBmNDktXFx1MGY2Y1xcdTBmODgtXFx1MGY4Y1xcdTEwMDAtXFx1MTAyYVxcdTEwM2ZcXHUxMDUwLVxcdTEwNTVcXHUxMDVhLVxcdTEwNWRcXHUxMDYxXFx1MTA2NVxcdTEwNjZcXHUxMDZlLVxcdTEwNzBcXHUxMDc1LVxcdTEwODFcXHUxMDhlXFx1MTBhMC1cXHUxMGM1XFx1MTBjN1xcdTEwY2RcXHUxMGQwLVxcdTEwZmFcXHUxMGZjLVxcdTEyNDhcXHUxMjRhLVxcdTEyNGRcXHUxMjUwLVxcdTEyNTZcXHUxMjU4XFx1MTI1YS1cXHUxMjVkXFx1MTI2MC1cXHUxMjg4XFx1MTI4YS1cXHUxMjhkXFx1MTI5MC1cXHUxMmIwXFx1MTJiMi1cXHUxMmI1XFx1MTJiOC1cXHUxMmJlXFx1MTJjMFxcdTEyYzItXFx1MTJjNVxcdTEyYzgtXFx1MTJkNlxcdTEyZDgtXFx1MTMxMFxcdTEzMTItXFx1MTMxNVxcdTEzMTgtXFx1MTM1YVxcdTEzODAtXFx1MTM4ZlxcdTEzYTAtXFx1MTNmNFxcdTE0MDEtXFx1MTY2Y1xcdTE2NmYtXFx1MTY3ZlxcdTE2ODEtXFx1MTY5YVxcdTE2YTAtXFx1MTZlYVxcdTE2ZWUtXFx1MTZmMFxcdTE3MDAtXFx1MTcwY1xcdTE3MGUtXFx1MTcxMVxcdTE3MjAtXFx1MTczMVxcdTE3NDAtXFx1MTc1MVxcdTE3NjAtXFx1MTc2Y1xcdTE3NmUtXFx1MTc3MFxcdTE3ODAtXFx1MTdiM1xcdTE3ZDdcXHUxN2RjXFx1MTgyMC1cXHUxODc3XFx1MTg4MC1cXHUxOGE4XFx1MThhYVxcdTE4YjAtXFx1MThmNVxcdTE5MDAtXFx1MTkxY1xcdTE5NTAtXFx1MTk2ZFxcdTE5NzAtXFx1MTk3NFxcdTE5ODAtXFx1MTlhYlxcdTE5YzEtXFx1MTljN1xcdTFhMDAtXFx1MWExNlxcdTFhMjAtXFx1MWE1NFxcdTFhYTdcXHUxYjA1LVxcdTFiMzNcXHUxYjQ1LVxcdTFiNGJcXHUxYjgzLVxcdTFiYTBcXHUxYmFlXFx1MWJhZlxcdTFiYmEtXFx1MWJlNVxcdTFjMDAtXFx1MWMyM1xcdTFjNGQtXFx1MWM0ZlxcdTFjNWEtXFx1MWM3ZFxcdTFjZTktXFx1MWNlY1xcdTFjZWUtXFx1MWNmMVxcdTFjZjVcXHUxY2Y2XFx1MWQwMC1cXHUxZGJmXFx1MWUwMC1cXHUxZjE1XFx1MWYxOC1cXHUxZjFkXFx1MWYyMC1cXHUxZjQ1XFx1MWY0OC1cXHUxZjRkXFx1MWY1MC1cXHUxZjU3XFx1MWY1OVxcdTFmNWJcXHUxZjVkXFx1MWY1Zi1cXHUxZjdkXFx1MWY4MC1cXHUxZmI0XFx1MWZiNi1cXHUxZmJjXFx1MWZiZVxcdTFmYzItXFx1MWZjNFxcdTFmYzYtXFx1MWZjY1xcdTFmZDAtXFx1MWZkM1xcdTFmZDYtXFx1MWZkYlxcdTFmZTAtXFx1MWZlY1xcdTFmZjItXFx1MWZmNFxcdTFmZjYtXFx1MWZmY1xcdTIwNzFcXHUyMDdmXFx1MjA5MC1cXHUyMDljXFx1MjEwMlxcdTIxMDdcXHUyMTBhLVxcdTIxMTNcXHUyMTE1XFx1MjExOS1cXHUyMTFkXFx1MjEyNFxcdTIxMjZcXHUyMTI4XFx1MjEyYS1cXHUyMTJkXFx1MjEyZi1cXHUyMTM5XFx1MjEzYy1cXHUyMTNmXFx1MjE0NS1cXHUyMTQ5XFx1MjE0ZVxcdTIxNjAtXFx1MjE4OFxcdTJjMDAtXFx1MmMyZVxcdTJjMzAtXFx1MmM1ZVxcdTJjNjAtXFx1MmNlNFxcdTJjZWItXFx1MmNlZVxcdTJjZjJcXHUyY2YzXFx1MmQwMC1cXHUyZDI1XFx1MmQyN1xcdTJkMmRcXHUyZDMwLVxcdTJkNjdcXHUyZDZmXFx1MmQ4MC1cXHUyZDk2XFx1MmRhMC1cXHUyZGE2XFx1MmRhOC1cXHUyZGFlXFx1MmRiMC1cXHUyZGI2XFx1MmRiOC1cXHUyZGJlXFx1MmRjMC1cXHUyZGM2XFx1MmRjOC1cXHUyZGNlXFx1MmRkMC1cXHUyZGQ2XFx1MmRkOC1cXHUyZGRlXFx1MmUyZlxcdTMwMDUtXFx1MzAwN1xcdTMwMjEtXFx1MzAyOVxcdTMwMzEtXFx1MzAzNVxcdTMwMzgtXFx1MzAzY1xcdTMwNDEtXFx1MzA5NlxcdTMwOWQtXFx1MzA5ZlxcdTMwYTEtXFx1MzBmYVxcdTMwZmMtXFx1MzBmZlxcdTMxMDUtXFx1MzEyZFxcdTMxMzEtXFx1MzE4ZVxcdTMxYTAtXFx1MzFiYVxcdTMxZjAtXFx1MzFmZlxcdTM0MDAtXFx1NGRiNVxcdTRlMDAtXFx1OWZjY1xcdWEwMDAtXFx1YTQ4Y1xcdWE0ZDAtXFx1YTRmZFxcdWE1MDAtXFx1YTYwY1xcdWE2MTAtXFx1YTYxZlxcdWE2MmFcXHVhNjJiXFx1YTY0MC1cXHVhNjZlXFx1YTY3Zi1cXHVhNjk3XFx1YTZhMC1cXHVhNmVmXFx1YTcxNy1cXHVhNzFmXFx1YTcyMi1cXHVhNzg4XFx1YTc4Yi1cXHVhNzhlXFx1YTc5MC1cXHVhNzkzXFx1YTdhMC1cXHVhN2FhXFx1YTdmOC1cXHVhODAxXFx1YTgwMy1cXHVhODA1XFx1YTgwNy1cXHVhODBhXFx1YTgwYy1cXHVhODIyXFx1YTg0MC1cXHVhODczXFx1YTg4Mi1cXHVhOGIzXFx1YThmMi1cXHVhOGY3XFx1YThmYlxcdWE5MGEtXFx1YTkyNVxcdWE5MzAtXFx1YTk0NlxcdWE5NjAtXFx1YTk3Y1xcdWE5ODQtXFx1YTliMlxcdWE5Y2ZcXHVhYTAwLVxcdWFhMjhcXHVhYTQwLVxcdWFhNDJcXHVhYTQ0LVxcdWFhNGJcXHVhYTYwLVxcdWFhNzZcXHVhYTdhXFx1YWE4MC1cXHVhYWFmXFx1YWFiMVxcdWFhYjVcXHVhYWI2XFx1YWFiOS1cXHVhYWJkXFx1YWFjMFxcdWFhYzJcXHVhYWRiLVxcdWFhZGRcXHVhYWUwLVxcdWFhZWFcXHVhYWYyLVxcdWFhZjRcXHVhYjAxLVxcdWFiMDZcXHVhYjA5LVxcdWFiMGVcXHVhYjExLVxcdWFiMTZcXHVhYjIwLVxcdWFiMjZcXHVhYjI4LVxcdWFiMmVcXHVhYmMwLVxcdWFiZTJcXHVhYzAwLVxcdWQ3YTNcXHVkN2IwLVxcdWQ3YzZcXHVkN2NiLVxcdWQ3ZmJcXHVmOTAwLVxcdWZhNmRcXHVmYTcwLVxcdWZhZDlcXHVmYjAwLVxcdWZiMDZcXHVmYjEzLVxcdWZiMTdcXHVmYjFkXFx1ZmIxZi1cXHVmYjI4XFx1ZmIyYS1cXHVmYjM2XFx1ZmIzOC1cXHVmYjNjXFx1ZmIzZVxcdWZiNDBcXHVmYjQxXFx1ZmI0M1xcdWZiNDRcXHVmYjQ2LVxcdWZiYjFcXHVmYmQzLVxcdWZkM2RcXHVmZDUwLVxcdWZkOGZcXHVmZDkyLVxcdWZkYzdcXHVmZGYwLVxcdWZkZmJcXHVmZTcwLVxcdWZlNzRcXHVmZTc2LVxcdWZlZmNcXHVmZjIxLVxcdWZmM2FcXHVmZjQxLVxcdWZmNWFcXHVmZjY2LVxcdWZmYmVcXHVmZmMyLVxcdWZmYzdcXHVmZmNhLVxcdWZmY2ZcXHVmZmQyLVxcdWZmZDdcXHVmZmRhLVxcdWZmZGMwLTlcXHUwMzAwLVxcdTAzNmZcXHUwNDgzLVxcdTA0ODdcXHUwNTkxLVxcdTA1YmRcXHUwNWJmXFx1MDVjMVxcdTA1YzJcXHUwNWM0XFx1MDVjNVxcdTA1YzdcXHUwNjEwLVxcdTA2MWFcXHUwNjRiLVxcdTA2NjlcXHUwNjcwXFx1MDZkNi1cXHUwNmRjXFx1MDZkZi1cXHUwNmU0XFx1MDZlN1xcdTA2ZThcXHUwNmVhLVxcdTA2ZWRcXHUwNmYwLVxcdTA2ZjlcXHUwNzExXFx1MDczMC1cXHUwNzRhXFx1MDdhNi1cXHUwN2IwXFx1MDdjMC1cXHUwN2M5XFx1MDdlYi1cXHUwN2YzXFx1MDgxNi1cXHUwODE5XFx1MDgxYi1cXHUwODIzXFx1MDgyNS1cXHUwODI3XFx1MDgyOS1cXHUwODJkXFx1MDg1OS1cXHUwODViXFx1MDhlNC1cXHUwOGZlXFx1MDkwMC1cXHUwOTAzXFx1MDkzYS1cXHUwOTNjXFx1MDkzZS1cXHUwOTRmXFx1MDk1MS1cXHUwOTU3XFx1MDk2MlxcdTA5NjNcXHUwOTY2LVxcdTA5NmZcXHUwOTgxLVxcdTA5ODNcXHUwOWJjXFx1MDliZS1cXHUwOWM0XFx1MDljN1xcdTA5YzhcXHUwOWNiLVxcdTA5Y2RcXHUwOWQ3XFx1MDllMlxcdTA5ZTNcXHUwOWU2LVxcdTA5ZWZcXHUwYTAxLVxcdTBhMDNcXHUwYTNjXFx1MGEzZS1cXHUwYTQyXFx1MGE0N1xcdTBhNDhcXHUwYTRiLVxcdTBhNGRcXHUwYTUxXFx1MGE2Ni1cXHUwYTcxXFx1MGE3NVxcdTBhODEtXFx1MGE4M1xcdTBhYmNcXHUwYWJlLVxcdTBhYzVcXHUwYWM3LVxcdTBhYzlcXHUwYWNiLVxcdTBhY2RcXHUwYWUyXFx1MGFlM1xcdTBhZTYtXFx1MGFlZlxcdTBiMDEtXFx1MGIwM1xcdTBiM2NcXHUwYjNlLVxcdTBiNDRcXHUwYjQ3XFx1MGI0OFxcdTBiNGItXFx1MGI0ZFxcdTBiNTZcXHUwYjU3XFx1MGI2MlxcdTBiNjNcXHUwYjY2LVxcdTBiNmZcXHUwYjgyXFx1MGJiZS1cXHUwYmMyXFx1MGJjNi1cXHUwYmM4XFx1MGJjYS1cXHUwYmNkXFx1MGJkN1xcdTBiZTYtXFx1MGJlZlxcdTBjMDEtXFx1MGMwM1xcdTBjM2UtXFx1MGM0NFxcdTBjNDYtXFx1MGM0OFxcdTBjNGEtXFx1MGM0ZFxcdTBjNTVcXHUwYzU2XFx1MGM2MlxcdTBjNjNcXHUwYzY2LVxcdTBjNmZcXHUwYzgyXFx1MGM4M1xcdTBjYmNcXHUwY2JlLVxcdTBjYzRcXHUwY2M2LVxcdTBjYzhcXHUwY2NhLVxcdTBjY2RcXHUwY2Q1XFx1MGNkNlxcdTBjZTJcXHUwY2UzXFx1MGNlNi1cXHUwY2VmXFx1MGQwMlxcdTBkMDNcXHUwZDNlLVxcdTBkNDRcXHUwZDQ2LVxcdTBkNDhcXHUwZDRhLVxcdTBkNGRcXHUwZDU3XFx1MGQ2MlxcdTBkNjNcXHUwZDY2LVxcdTBkNmZcXHUwZDgyXFx1MGQ4M1xcdTBkY2FcXHUwZGNmLVxcdTBkZDRcXHUwZGQ2XFx1MGRkOC1cXHUwZGRmXFx1MGRmMlxcdTBkZjNcXHUwZTMxXFx1MGUzNC1cXHUwZTNhXFx1MGU0Ny1cXHUwZTRlXFx1MGU1MC1cXHUwZTU5XFx1MGViMVxcdTBlYjQtXFx1MGViOVxcdTBlYmJcXHUwZWJjXFx1MGVjOC1cXHUwZWNkXFx1MGVkMC1cXHUwZWQ5XFx1MGYxOFxcdTBmMTlcXHUwZjIwLVxcdTBmMjlcXHUwZjM1XFx1MGYzN1xcdTBmMzlcXHUwZjNlXFx1MGYzZlxcdTBmNzEtXFx1MGY4NFxcdTBmODZcXHUwZjg3XFx1MGY4ZC1cXHUwZjk3XFx1MGY5OS1cXHUwZmJjXFx1MGZjNlxcdTEwMmItXFx1MTAzZVxcdTEwNDAtXFx1MTA0OVxcdTEwNTYtXFx1MTA1OVxcdTEwNWUtXFx1MTA2MFxcdTEwNjItXFx1MTA2NFxcdTEwNjctXFx1MTA2ZFxcdTEwNzEtXFx1MTA3NFxcdTEwODItXFx1MTA4ZFxcdTEwOGYtXFx1MTA5ZFxcdTEzNWQtXFx1MTM1ZlxcdTE3MTItXFx1MTcxNFxcdTE3MzItXFx1MTczNFxcdTE3NTJcXHUxNzUzXFx1MTc3MlxcdTE3NzNcXHUxN2I0LVxcdTE3ZDNcXHUxN2RkXFx1MTdlMC1cXHUxN2U5XFx1MTgwYi1cXHUxODBkXFx1MTgxMC1cXHUxODE5XFx1MThhOVxcdTE5MjAtXFx1MTkyYlxcdTE5MzAtXFx1MTkzYlxcdTE5NDYtXFx1MTk0ZlxcdTE5YjAtXFx1MTljMFxcdTE5YzhcXHUxOWM5XFx1MTlkMC1cXHUxOWQ5XFx1MWExNy1cXHUxYTFiXFx1MWE1NS1cXHUxYTVlXFx1MWE2MC1cXHUxYTdjXFx1MWE3Zi1cXHUxYTg5XFx1MWE5MC1cXHUxYTk5XFx1MWIwMC1cXHUxYjA0XFx1MWIzNC1cXHUxYjQ0XFx1MWI1MC1cXHUxYjU5XFx1MWI2Yi1cXHUxYjczXFx1MWI4MC1cXHUxYjgyXFx1MWJhMS1cXHUxYmFkXFx1MWJiMC1cXHUxYmI5XFx1MWJlNi1cXHUxYmYzXFx1MWMyNC1cXHUxYzM3XFx1MWM0MC1cXHUxYzQ5XFx1MWM1MC1cXHUxYzU5XFx1MWNkMC1cXHUxY2QyXFx1MWNkNC1cXHUxY2U4XFx1MWNlZFxcdTFjZjItXFx1MWNmNFxcdTFkYzAtXFx1MWRlNlxcdTFkZmMtXFx1MWRmZlxcdTIwMGNcXHUyMDBkXFx1MjAzZlxcdTIwNDBcXHUyMDU0XFx1MjBkMC1cXHUyMGRjXFx1MjBlMVxcdTIwZTUtXFx1MjBmMFxcdTJjZWYtXFx1MmNmMVxcdTJkN2ZcXHUyZGUwLVxcdTJkZmZcXHUzMDJhLVxcdTMwMmZcXHUzMDk5XFx1MzA5YVxcdWE2MjAtXFx1YTYyOVxcdWE2NmZcXHVhNjc0LVxcdWE2N2RcXHVhNjlmXFx1YTZmMFxcdWE2ZjFcXHVhODAyXFx1YTgwNlxcdWE4MGJcXHVhODIzLVxcdWE4MjdcXHVhODgwXFx1YTg4MVxcdWE4YjQtXFx1YThjNFxcdWE4ZDAtXFx1YThkOVxcdWE4ZTAtXFx1YThmMVxcdWE5MDAtXFx1YTkwOVxcdWE5MjYtXFx1YTkyZFxcdWE5NDctXFx1YTk1M1xcdWE5ODAtXFx1YTk4M1xcdWE5YjMtXFx1YTljMFxcdWE5ZDAtXFx1YTlkOVxcdWFhMjktXFx1YWEzNlxcdWFhNDNcXHVhYTRjXFx1YWE0ZFxcdWFhNTAtXFx1YWE1OVxcdWFhN2JcXHVhYWIwXFx1YWFiMi1cXHVhYWI0XFx1YWFiN1xcdWFhYjhcXHVhYWJlXFx1YWFiZlxcdWFhYzFcXHVhYWViLVxcdWFhZWZcXHVhYWY1XFx1YWFmNlxcdWFiZTMtXFx1YWJlYVxcdWFiZWNcXHVhYmVkXFx1YWJmMC1cXHVhYmY5XFx1ZmIxZVxcdWZlMDAtXFx1ZmUwZlxcdWZlMjAtXFx1ZmUyNlxcdWZlMzNcXHVmZTM0XFx1ZmU0ZC1cXHVmZTRmXFx1ZmYxMC1cXHVmZjE5XFx1ZmYzZl0qJC8udGVzdChzdHIpXG59XG5tb2R1bGUuZXhwb3J0cyA9IGlzUHJvcGVydHlcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9pcy1wcm9wZXJ0eS9pcy1wcm9wZXJ0eS5qc1xuICoqIG1vZHVsZSBpZCA9IDcxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKVxuXG52YXIgSU5ERU5UX1NUQVJUID0gL1tcXHtcXFtdL1xudmFyIElOREVOVF9FTkQgPSAvW1xcfVxcXV0vXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XG4gIHZhciBsaW5lcyA9IFtdXG4gIHZhciBpbmRlbnQgPSAwXG5cbiAgdmFyIHB1c2ggPSBmdW5jdGlvbihzdHIpIHtcbiAgICB2YXIgc3BhY2VzID0gJydcbiAgICB3aGlsZSAoc3BhY2VzLmxlbmd0aCA8IGluZGVudCoyKSBzcGFjZXMgKz0gJyAgJ1xuICAgIGxpbmVzLnB1c2goc3BhY2VzK3N0cilcbiAgfVxuXG4gIHZhciBsaW5lID0gZnVuY3Rpb24oZm10KSB7XG4gICAgaWYgKCFmbXQpIHJldHVybiBsaW5lXG5cbiAgICBpZiAoSU5ERU5UX0VORC50ZXN0KGZtdC50cmltKClbMF0pICYmIElOREVOVF9TVEFSVC50ZXN0KGZtdFtmbXQubGVuZ3RoLTFdKSkge1xuICAgICAgaW5kZW50LS1cbiAgICAgIHB1c2godXRpbC5mb3JtYXQuYXBwbHkodXRpbCwgYXJndW1lbnRzKSlcbiAgICAgIGluZGVudCsrXG4gICAgICByZXR1cm4gbGluZVxuICAgIH1cbiAgICBpZiAoSU5ERU5UX1NUQVJULnRlc3QoZm10W2ZtdC5sZW5ndGgtMV0pKSB7XG4gICAgICBwdXNoKHV0aWwuZm9ybWF0LmFwcGx5KHV0aWwsIGFyZ3VtZW50cykpXG4gICAgICBpbmRlbnQrK1xuICAgICAgcmV0dXJuIGxpbmVcbiAgICB9XG4gICAgaWYgKElOREVOVF9FTkQudGVzdChmbXQudHJpbSgpWzBdKSkge1xuICAgICAgaW5kZW50LS1cbiAgICAgIHB1c2godXRpbC5mb3JtYXQuYXBwbHkodXRpbCwgYXJndW1lbnRzKSlcbiAgICAgIHJldHVybiBsaW5lXG4gICAgfVxuXG4gICAgcHVzaCh1dGlsLmZvcm1hdC5hcHBseSh1dGlsLCBhcmd1bWVudHMpKVxuICAgIHJldHVybiBsaW5lXG4gIH1cblxuICBsaW5lLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGxpbmVzLmpvaW4oJ1xcbicpXG4gIH1cblxuICBsaW5lLnRvRnVuY3Rpb24gPSBmdW5jdGlvbihzY29wZSkge1xuICAgIHZhciBzcmMgPSAncmV0dXJuICgnK2xpbmUudG9TdHJpbmcoKSsnKSdcblxuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoc2NvcGUgfHwge30pLm1hcChmdW5jdGlvbihrZXkpIHtcbiAgICAgIHJldHVybiBrZXlcbiAgICB9KVxuXG4gICAgdmFyIHZhbHMgPSBrZXlzLm1hcChmdW5jdGlvbihrZXkpIHtcbiAgICAgIHJldHVybiBzY29wZVtrZXldXG4gICAgfSlcblxuICAgIHJldHVybiBGdW5jdGlvbi5hcHBseShudWxsLCBrZXlzLmNvbmNhdChzcmMpKS5hcHBseShudWxsLCB2YWxzKVxuICB9XG5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIGxpbmUuYXBwbHkobnVsbCwgYXJndW1lbnRzKVxuXG4gIHJldHVybiBsaW5lXG59XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9nZW5lcmF0ZS1mdW5jdGlvbi9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDcyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxudmFyIGZvcm1hdFJlZ0V4cCA9IC8lW3NkaiVdL2c7XG5leHBvcnRzLmZvcm1hdCA9IGZ1bmN0aW9uKGYpIHtcbiAgaWYgKCFpc1N0cmluZyhmKSkge1xuICAgIHZhciBvYmplY3RzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIG9iamVjdHMucHVzaChpbnNwZWN0KGFyZ3VtZW50c1tpXSkpO1xuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0cy5qb2luKCcgJyk7XG4gIH1cblxuICB2YXIgaSA9IDE7XG4gIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICB2YXIgbGVuID0gYXJncy5sZW5ndGg7XG4gIHZhciBzdHIgPSBTdHJpbmcoZikucmVwbGFjZShmb3JtYXRSZWdFeHAsIGZ1bmN0aW9uKHgpIHtcbiAgICBpZiAoeCA9PT0gJyUlJykgcmV0dXJuICclJztcbiAgICBpZiAoaSA+PSBsZW4pIHJldHVybiB4O1xuICAgIHN3aXRjaCAoeCkge1xuICAgICAgY2FzZSAnJXMnOiByZXR1cm4gU3RyaW5nKGFyZ3NbaSsrXSk7XG4gICAgICBjYXNlICclZCc6IHJldHVybiBOdW1iZXIoYXJnc1tpKytdKTtcbiAgICAgIGNhc2UgJyVqJzpcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoYXJnc1tpKytdKTtcbiAgICAgICAgfSBjYXRjaCAoXykge1xuICAgICAgICAgIHJldHVybiAnW0NpcmN1bGFyXSc7XG4gICAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB4O1xuICAgIH1cbiAgfSk7XG4gIGZvciAodmFyIHggPSBhcmdzW2ldOyBpIDwgbGVuOyB4ID0gYXJnc1srK2ldKSB7XG4gICAgaWYgKGlzTnVsbCh4KSB8fCAhaXNPYmplY3QoeCkpIHtcbiAgICAgIHN0ciArPSAnICcgKyB4O1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgKz0gJyAnICsgaW5zcGVjdCh4KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0cjtcbn07XG5cblxuLy8gTWFyayB0aGF0IGEgbWV0aG9kIHNob3VsZCBub3QgYmUgdXNlZC5cbi8vIFJldHVybnMgYSBtb2RpZmllZCBmdW5jdGlvbiB3aGljaCB3YXJucyBvbmNlIGJ5IGRlZmF1bHQuXG4vLyBJZiAtLW5vLWRlcHJlY2F0aW9uIGlzIHNldCwgdGhlbiBpdCBpcyBhIG5vLW9wLlxuZXhwb3J0cy5kZXByZWNhdGUgPSBmdW5jdGlvbihmbiwgbXNnKSB7XG4gIC8vIEFsbG93IGZvciBkZXByZWNhdGluZyB0aGluZ3MgaW4gdGhlIHByb2Nlc3Mgb2Ygc3RhcnRpbmcgdXAuXG4gIGlmIChpc1VuZGVmaW5lZChnbG9iYWwucHJvY2VzcykpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZXhwb3J0cy5kZXByZWNhdGUoZm4sIG1zZykuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9XG5cbiAgaWYgKHByb2Nlc3Mubm9EZXByZWNhdGlvbiA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiBmbjtcbiAgfVxuXG4gIHZhciB3YXJuZWQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gZGVwcmVjYXRlZCgpIHtcbiAgICBpZiAoIXdhcm5lZCkge1xuICAgICAgaWYgKHByb2Nlc3MudGhyb3dEZXByZWNhdGlvbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy50cmFjZURlcHJlY2F0aW9uKSB7XG4gICAgICAgIGNvbnNvbGUudHJhY2UobXNnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IobXNnKTtcbiAgICAgIH1cbiAgICAgIHdhcm5lZCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgcmV0dXJuIGRlcHJlY2F0ZWQ7XG59O1xuXG5cbnZhciBkZWJ1Z3MgPSB7fTtcbnZhciBkZWJ1Z0Vudmlyb247XG5leHBvcnRzLmRlYnVnbG9nID0gZnVuY3Rpb24oc2V0KSB7XG4gIGlmIChpc1VuZGVmaW5lZChkZWJ1Z0Vudmlyb24pKVxuICAgIGRlYnVnRW52aXJvbiA9IHByb2Nlc3MuZW52Lk5PREVfREVCVUcgfHwgJyc7XG4gIHNldCA9IHNldC50b1VwcGVyQ2FzZSgpO1xuICBpZiAoIWRlYnVnc1tzZXRdKSB7XG4gICAgaWYgKG5ldyBSZWdFeHAoJ1xcXFxiJyArIHNldCArICdcXFxcYicsICdpJykudGVzdChkZWJ1Z0Vudmlyb24pKSB7XG4gICAgICB2YXIgcGlkID0gcHJvY2Vzcy5waWQ7XG4gICAgICBkZWJ1Z3Nbc2V0XSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbXNnID0gZXhwb3J0cy5mb3JtYXQuYXBwbHkoZXhwb3J0cywgYXJndW1lbnRzKTtcbiAgICAgICAgY29uc29sZS5lcnJvcignJXMgJWQ6ICVzJywgc2V0LCBwaWQsIG1zZyk7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWJ1Z3Nbc2V0XSA9IGZ1bmN0aW9uKCkge307XG4gICAgfVxuICB9XG4gIHJldHVybiBkZWJ1Z3Nbc2V0XTtcbn07XG5cblxuLyoqXG4gKiBFY2hvcyB0aGUgdmFsdWUgb2YgYSB2YWx1ZS4gVHJ5cyB0byBwcmludCB0aGUgdmFsdWUgb3V0XG4gKiBpbiB0aGUgYmVzdCB3YXkgcG9zc2libGUgZ2l2ZW4gdGhlIGRpZmZlcmVudCB0eXBlcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gcHJpbnQgb3V0LlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHMgT3B0aW9uYWwgb3B0aW9ucyBvYmplY3QgdGhhdCBhbHRlcnMgdGhlIG91dHB1dC5cbiAqL1xuLyogbGVnYWN5OiBvYmosIHNob3dIaWRkZW4sIGRlcHRoLCBjb2xvcnMqL1xuZnVuY3Rpb24gaW5zcGVjdChvYmosIG9wdHMpIHtcbiAgLy8gZGVmYXVsdCBvcHRpb25zXG4gIHZhciBjdHggPSB7XG4gICAgc2VlbjogW10sXG4gICAgc3R5bGl6ZTogc3R5bGl6ZU5vQ29sb3JcbiAgfTtcbiAgLy8gbGVnYWN5Li4uXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDMpIGN0eC5kZXB0aCA9IGFyZ3VtZW50c1syXTtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gNCkgY3R4LmNvbG9ycyA9IGFyZ3VtZW50c1szXTtcbiAgaWYgKGlzQm9vbGVhbihvcHRzKSkge1xuICAgIC8vIGxlZ2FjeS4uLlxuICAgIGN0eC5zaG93SGlkZGVuID0gb3B0cztcbiAgfSBlbHNlIGlmIChvcHRzKSB7XG4gICAgLy8gZ290IGFuIFwib3B0aW9uc1wiIG9iamVjdFxuICAgIGV4cG9ydHMuX2V4dGVuZChjdHgsIG9wdHMpO1xuICB9XG4gIC8vIHNldCBkZWZhdWx0IG9wdGlvbnNcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5zaG93SGlkZGVuKSkgY3R4LnNob3dIaWRkZW4gPSBmYWxzZTtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5kZXB0aCkpIGN0eC5kZXB0aCA9IDI7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguY29sb3JzKSkgY3R4LmNvbG9ycyA9IGZhbHNlO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmN1c3RvbUluc3BlY3QpKSBjdHguY3VzdG9tSW5zcGVjdCA9IHRydWU7XG4gIGlmIChjdHguY29sb3JzKSBjdHguc3R5bGl6ZSA9IHN0eWxpemVXaXRoQ29sb3I7XG4gIHJldHVybiBmb3JtYXRWYWx1ZShjdHgsIG9iaiwgY3R4LmRlcHRoKTtcbn1cbmV4cG9ydHMuaW5zcGVjdCA9IGluc3BlY3Q7XG5cblxuLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9BTlNJX2VzY2FwZV9jb2RlI2dyYXBoaWNzXG5pbnNwZWN0LmNvbG9ycyA9IHtcbiAgJ2JvbGQnIDogWzEsIDIyXSxcbiAgJ2l0YWxpYycgOiBbMywgMjNdLFxuICAndW5kZXJsaW5lJyA6IFs0LCAyNF0sXG4gICdpbnZlcnNlJyA6IFs3LCAyN10sXG4gICd3aGl0ZScgOiBbMzcsIDM5XSxcbiAgJ2dyZXknIDogWzkwLCAzOV0sXG4gICdibGFjaycgOiBbMzAsIDM5XSxcbiAgJ2JsdWUnIDogWzM0LCAzOV0sXG4gICdjeWFuJyA6IFszNiwgMzldLFxuICAnZ3JlZW4nIDogWzMyLCAzOV0sXG4gICdtYWdlbnRhJyA6IFszNSwgMzldLFxuICAncmVkJyA6IFszMSwgMzldLFxuICAneWVsbG93JyA6IFszMywgMzldXG59O1xuXG4vLyBEb24ndCB1c2UgJ2JsdWUnIG5vdCB2aXNpYmxlIG9uIGNtZC5leGVcbmluc3BlY3Quc3R5bGVzID0ge1xuICAnc3BlY2lhbCc6ICdjeWFuJyxcbiAgJ251bWJlcic6ICd5ZWxsb3cnLFxuICAnYm9vbGVhbic6ICd5ZWxsb3cnLFxuICAndW5kZWZpbmVkJzogJ2dyZXknLFxuICAnbnVsbCc6ICdib2xkJyxcbiAgJ3N0cmluZyc6ICdncmVlbicsXG4gICdkYXRlJzogJ21hZ2VudGEnLFxuICAvLyBcIm5hbWVcIjogaW50ZW50aW9uYWxseSBub3Qgc3R5bGluZ1xuICAncmVnZXhwJzogJ3JlZCdcbn07XG5cblxuZnVuY3Rpb24gc3R5bGl6ZVdpdGhDb2xvcihzdHIsIHN0eWxlVHlwZSkge1xuICB2YXIgc3R5bGUgPSBpbnNwZWN0LnN0eWxlc1tzdHlsZVR5cGVdO1xuXG4gIGlmIChzdHlsZSkge1xuICAgIHJldHVybiAnXFx1MDAxYlsnICsgaW5zcGVjdC5jb2xvcnNbc3R5bGVdWzBdICsgJ20nICsgc3RyICtcbiAgICAgICAgICAgJ1xcdTAwMWJbJyArIGluc3BlY3QuY29sb3JzW3N0eWxlXVsxXSArICdtJztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG59XG5cblxuZnVuY3Rpb24gc3R5bGl6ZU5vQ29sb3Ioc3RyLCBzdHlsZVR5cGUpIHtcbiAgcmV0dXJuIHN0cjtcbn1cblxuXG5mdW5jdGlvbiBhcnJheVRvSGFzaChhcnJheSkge1xuICB2YXIgaGFzaCA9IHt9O1xuXG4gIGFycmF5LmZvckVhY2goZnVuY3Rpb24odmFsLCBpZHgpIHtcbiAgICBoYXNoW3ZhbF0gPSB0cnVlO1xuICB9KTtcblxuICByZXR1cm4gaGFzaDtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRWYWx1ZShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMpIHtcbiAgLy8gUHJvdmlkZSBhIGhvb2sgZm9yIHVzZXItc3BlY2lmaWVkIGluc3BlY3QgZnVuY3Rpb25zLlxuICAvLyBDaGVjayB0aGF0IHZhbHVlIGlzIGFuIG9iamVjdCB3aXRoIGFuIGluc3BlY3QgZnVuY3Rpb24gb24gaXRcbiAgaWYgKGN0eC5jdXN0b21JbnNwZWN0ICYmXG4gICAgICB2YWx1ZSAmJlxuICAgICAgaXNGdW5jdGlvbih2YWx1ZS5pbnNwZWN0KSAmJlxuICAgICAgLy8gRmlsdGVyIG91dCB0aGUgdXRpbCBtb2R1bGUsIGl0J3MgaW5zcGVjdCBmdW5jdGlvbiBpcyBzcGVjaWFsXG4gICAgICB2YWx1ZS5pbnNwZWN0ICE9PSBleHBvcnRzLmluc3BlY3QgJiZcbiAgICAgIC8vIEFsc28gZmlsdGVyIG91dCBhbnkgcHJvdG90eXBlIG9iamVjdHMgdXNpbmcgdGhlIGNpcmN1bGFyIGNoZWNrLlxuICAgICAgISh2YWx1ZS5jb25zdHJ1Y3RvciAmJiB2YWx1ZS5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgPT09IHZhbHVlKSkge1xuICAgIHZhciByZXQgPSB2YWx1ZS5pbnNwZWN0KHJlY3Vyc2VUaW1lcywgY3R4KTtcbiAgICBpZiAoIWlzU3RyaW5nKHJldCkpIHtcbiAgICAgIHJldCA9IGZvcm1hdFZhbHVlKGN0eCwgcmV0LCByZWN1cnNlVGltZXMpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgLy8gUHJpbWl0aXZlIHR5cGVzIGNhbm5vdCBoYXZlIHByb3BlcnRpZXNcbiAgdmFyIHByaW1pdGl2ZSA9IGZvcm1hdFByaW1pdGl2ZShjdHgsIHZhbHVlKTtcbiAgaWYgKHByaW1pdGl2ZSkge1xuICAgIHJldHVybiBwcmltaXRpdmU7XG4gIH1cblxuICAvLyBMb29rIHVwIHRoZSBrZXlzIG9mIHRoZSBvYmplY3QuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXModmFsdWUpO1xuICB2YXIgdmlzaWJsZUtleXMgPSBhcnJheVRvSGFzaChrZXlzKTtcblxuICBpZiAoY3R4LnNob3dIaWRkZW4pIHtcbiAgICBrZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModmFsdWUpO1xuICB9XG5cbiAgLy8gSUUgZG9lc24ndCBtYWtlIGVycm9yIGZpZWxkcyBub24tZW51bWVyYWJsZVxuICAvLyBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvaWUvZHd3NTJzYnQodj12cy45NCkuYXNweFxuICBpZiAoaXNFcnJvcih2YWx1ZSlcbiAgICAgICYmIChrZXlzLmluZGV4T2YoJ21lc3NhZ2UnKSA+PSAwIHx8IGtleXMuaW5kZXhPZignZGVzY3JpcHRpb24nKSA+PSAwKSkge1xuICAgIHJldHVybiBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gIH1cblxuICAvLyBTb21lIHR5cGUgb2Ygb2JqZWN0IHdpdGhvdXQgcHJvcGVydGllcyBjYW4gYmUgc2hvcnRjdXR0ZWQuXG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgdmFyIG5hbWUgPSB2YWx1ZS5uYW1lID8gJzogJyArIHZhbHVlLm5hbWUgOiAnJztcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnW0Z1bmN0aW9uJyArIG5hbWUgKyAnXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICAgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAncmVnZXhwJyk7XG4gICAgfVxuICAgIGlmIChpc0RhdGUodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdkYXRlJyk7XG4gICAgfVxuICAgIGlmIChpc0Vycm9yKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICB2YXIgYmFzZSA9ICcnLCBhcnJheSA9IGZhbHNlLCBicmFjZXMgPSBbJ3snLCAnfSddO1xuXG4gIC8vIE1ha2UgQXJyYXkgc2F5IHRoYXQgdGhleSBhcmUgQXJyYXlcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgYXJyYXkgPSB0cnVlO1xuICAgIGJyYWNlcyA9IFsnWycsICddJ107XG4gIH1cblxuICAvLyBNYWtlIGZ1bmN0aW9ucyBzYXkgdGhhdCB0aGV5IGFyZSBmdW5jdGlvbnNcbiAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgdmFyIG4gPSB2YWx1ZS5uYW1lID8gJzogJyArIHZhbHVlLm5hbWUgOiAnJztcbiAgICBiYXNlID0gJyBbRnVuY3Rpb24nICsgbiArICddJztcbiAgfVxuXG4gIC8vIE1ha2UgUmVnRXhwcyBzYXkgdGhhdCB0aGV5IGFyZSBSZWdFeHBzXG4gIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgfVxuXG4gIC8vIE1ha2UgZGF0ZXMgd2l0aCBwcm9wZXJ0aWVzIGZpcnN0IHNheSB0aGUgZGF0ZVxuICBpZiAoaXNEYXRlKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBEYXRlLnByb3RvdHlwZS50b1VUQ1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgfVxuXG4gIC8vIE1ha2UgZXJyb3Igd2l0aCBtZXNzYWdlIGZpcnN0IHNheSB0aGUgZXJyb3JcbiAgaWYgKGlzRXJyb3IodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgfVxuXG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCAmJiAoIWFycmF5IHx8IHZhbHVlLmxlbmd0aCA9PSAwKSkge1xuICAgIHJldHVybiBicmFjZXNbMF0gKyBiYXNlICsgYnJhY2VzWzFdO1xuICB9XG5cbiAgaWYgKHJlY3Vyc2VUaW1lcyA8IDApIHtcbiAgICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ3JlZ2V4cCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJ1tPYmplY3RdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cblxuICBjdHguc2Vlbi5wdXNoKHZhbHVlKTtcblxuICB2YXIgb3V0cHV0O1xuICBpZiAoYXJyYXkpIHtcbiAgICBvdXRwdXQgPSBmb3JtYXRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXlzKTtcbiAgfSBlbHNlIHtcbiAgICBvdXRwdXQgPSBrZXlzLm1hcChmdW5jdGlvbihrZXkpIHtcbiAgICAgIHJldHVybiBmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXksIGFycmF5KTtcbiAgICB9KTtcbiAgfVxuXG4gIGN0eC5zZWVuLnBvcCgpO1xuXG4gIHJldHVybiByZWR1Y2VUb1NpbmdsZVN0cmluZyhvdXRwdXQsIGJhc2UsIGJyYWNlcyk7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0UHJpbWl0aXZlKGN0eCwgdmFsdWUpIHtcbiAgaWYgKGlzVW5kZWZpbmVkKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJ3VuZGVmaW5lZCcsICd1bmRlZmluZWQnKTtcbiAgaWYgKGlzU3RyaW5nKHZhbHVlKSkge1xuICAgIHZhciBzaW1wbGUgPSAnXFwnJyArIEpTT04uc3RyaW5naWZ5KHZhbHVlKS5yZXBsYWNlKC9eXCJ8XCIkL2csICcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLycvZywgXCJcXFxcJ1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKSArICdcXCcnO1xuICAgIHJldHVybiBjdHguc3R5bGl6ZShzaW1wbGUsICdzdHJpbmcnKTtcbiAgfVxuICBpZiAoaXNOdW1iZXIodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnbnVtYmVyJyk7XG4gIGlmIChpc0Jvb2xlYW4odmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnYm9vbGVhbicpO1xuICAvLyBGb3Igc29tZSByZWFzb24gdHlwZW9mIG51bGwgaXMgXCJvYmplY3RcIiwgc28gc3BlY2lhbCBjYXNlIGhlcmUuXG4gIGlmIChpc051bGwodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnbnVsbCcsICdudWxsJyk7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0RXJyb3IodmFsdWUpIHtcbiAgcmV0dXJuICdbJyArIEVycm9yLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSArICddJztcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXlzKSB7XG4gIHZhciBvdXRwdXQgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkodmFsdWUsIFN0cmluZyhpKSkpIHtcbiAgICAgIG91dHB1dC5wdXNoKGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsXG4gICAgICAgICAgU3RyaW5nKGkpLCB0cnVlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dHB1dC5wdXNoKCcnKTtcbiAgICB9XG4gIH1cbiAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgIGlmICgha2V5Lm1hdGNoKC9eXFxkKyQvKSkge1xuICAgICAgb3V0cHV0LnB1c2goZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cyxcbiAgICAgICAgICBrZXksIHRydWUpKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gb3V0cHV0O1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleSwgYXJyYXkpIHtcbiAgdmFyIG5hbWUsIHN0ciwgZGVzYztcbiAgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodmFsdWUsIGtleSkgfHwgeyB2YWx1ZTogdmFsdWVba2V5XSB9O1xuICBpZiAoZGVzYy5nZXQpIHtcbiAgICBpZiAoZGVzYy5zZXQpIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbR2V0dGVyL1NldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0dldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoZGVzYy5zZXQpIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbU2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG4gIGlmICghaGFzT3duUHJvcGVydHkodmlzaWJsZUtleXMsIGtleSkpIHtcbiAgICBuYW1lID0gJ1snICsga2V5ICsgJ10nO1xuICB9XG4gIGlmICghc3RyKSB7XG4gICAgaWYgKGN0eC5zZWVuLmluZGV4T2YoZGVzYy52YWx1ZSkgPCAwKSB7XG4gICAgICBpZiAoaXNOdWxsKHJlY3Vyc2VUaW1lcykpIHtcbiAgICAgICAgc3RyID0gZm9ybWF0VmFsdWUoY3R4LCBkZXNjLnZhbHVlLCBudWxsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0ciA9IGZvcm1hdFZhbHVlKGN0eCwgZGVzYy52YWx1ZSwgcmVjdXJzZVRpbWVzIC0gMSk7XG4gICAgICB9XG4gICAgICBpZiAoc3RyLmluZGV4T2YoJ1xcbicpID4gLTEpIHtcbiAgICAgICAgaWYgKGFycmF5KSB7XG4gICAgICAgICAgc3RyID0gc3RyLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgcmV0dXJuICcgICcgKyBsaW5lO1xuICAgICAgICAgIH0pLmpvaW4oJ1xcbicpLnN1YnN0cigyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdHIgPSAnXFxuJyArIHN0ci5zcGxpdCgnXFxuJykubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiAnICAgJyArIGxpbmU7XG4gICAgICAgICAgfSkuam9pbignXFxuJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tDaXJjdWxhcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuICBpZiAoaXNVbmRlZmluZWQobmFtZSkpIHtcbiAgICBpZiAoYXJyYXkgJiYga2V5Lm1hdGNoKC9eXFxkKyQvKSkge1xuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gICAgbmFtZSA9IEpTT04uc3RyaW5naWZ5KCcnICsga2V5KTtcbiAgICBpZiAobmFtZS5tYXRjaCgvXlwiKFthLXpBLVpfXVthLXpBLVpfMC05XSopXCIkLykpIHtcbiAgICAgIG5hbWUgPSBuYW1lLnN1YnN0cigxLCBuYW1lLmxlbmd0aCAtIDIpO1xuICAgICAgbmFtZSA9IGN0eC5zdHlsaXplKG5hbWUsICduYW1lJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoLycvZywgXCJcXFxcJ1wiKVxuICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXFwiL2csICdcIicpXG4gICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8oXlwifFwiJCkvZywgXCInXCIpO1xuICAgICAgbmFtZSA9IGN0eC5zdHlsaXplKG5hbWUsICdzdHJpbmcnKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmFtZSArICc6ICcgKyBzdHI7XG59XG5cblxuZnVuY3Rpb24gcmVkdWNlVG9TaW5nbGVTdHJpbmcob3V0cHV0LCBiYXNlLCBicmFjZXMpIHtcbiAgdmFyIG51bUxpbmVzRXN0ID0gMDtcbiAgdmFyIGxlbmd0aCA9IG91dHB1dC5yZWR1Y2UoZnVuY3Rpb24ocHJldiwgY3VyKSB7XG4gICAgbnVtTGluZXNFc3QrKztcbiAgICBpZiAoY3VyLmluZGV4T2YoJ1xcbicpID49IDApIG51bUxpbmVzRXN0Kys7XG4gICAgcmV0dXJuIHByZXYgKyBjdXIucmVwbGFjZSgvXFx1MDAxYlxcW1xcZFxcZD9tL2csICcnKS5sZW5ndGggKyAxO1xuICB9LCAwKTtcblxuICBpZiAobGVuZ3RoID4gNjApIHtcbiAgICByZXR1cm4gYnJhY2VzWzBdICtcbiAgICAgICAgICAgKGJhc2UgPT09ICcnID8gJycgOiBiYXNlICsgJ1xcbiAnKSArXG4gICAgICAgICAgICcgJyArXG4gICAgICAgICAgIG91dHB1dC5qb2luKCcsXFxuICAnKSArXG4gICAgICAgICAgICcgJyArXG4gICAgICAgICAgIGJyYWNlc1sxXTtcbiAgfVxuXG4gIHJldHVybiBicmFjZXNbMF0gKyBiYXNlICsgJyAnICsgb3V0cHV0LmpvaW4oJywgJykgKyAnICcgKyBicmFjZXNbMV07XG59XG5cblxuLy8gTk9URTogVGhlc2UgdHlwZSBjaGVja2luZyBmdW5jdGlvbnMgaW50ZW50aW9uYWxseSBkb24ndCB1c2UgYGluc3RhbmNlb2ZgXG4vLyBiZWNhdXNlIGl0IGlzIGZyYWdpbGUgYW5kIGNhbiBiZSBlYXNpbHkgZmFrZWQgd2l0aCBgT2JqZWN0LmNyZWF0ZSgpYC5cbmZ1bmN0aW9uIGlzQXJyYXkoYXIpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXIpO1xufVxuZXhwb3J0cy5pc0FycmF5ID0gaXNBcnJheTtcblxuZnVuY3Rpb24gaXNCb29sZWFuKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nO1xufVxuZXhwb3J0cy5pc0Jvb2xlYW4gPSBpc0Jvb2xlYW47XG5cbmZ1bmN0aW9uIGlzTnVsbChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsID0gaXNOdWxsO1xuXG5mdW5jdGlvbiBpc051bGxPclVuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGxPclVuZGVmaW5lZCA9IGlzTnVsbE9yVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xufVxuZXhwb3J0cy5pc051bWJlciA9IGlzTnVtYmVyO1xuXG5mdW5jdGlvbiBpc1N0cmluZyhhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnO1xufVxuZXhwb3J0cy5pc1N0cmluZyA9IGlzU3RyaW5nO1xuXG5mdW5jdGlvbiBpc1N5bWJvbChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnO1xufVxuZXhwb3J0cy5pc1N5bWJvbCA9IGlzU3ltYm9sO1xuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xufVxuZXhwb3J0cy5pc1VuZGVmaW5lZCA9IGlzVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc1JlZ0V4cChyZSkge1xuICByZXR1cm4gaXNPYmplY3QocmUpICYmIG9iamVjdFRvU3RyaW5nKHJlKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7XG59XG5leHBvcnRzLmlzUmVnRXhwID0gaXNSZWdFeHA7XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xufVxuZXhwb3J0cy5pc09iamVjdCA9IGlzT2JqZWN0O1xuXG5mdW5jdGlvbiBpc0RhdGUoZCkge1xuICByZXR1cm4gaXNPYmplY3QoZCkgJiYgb2JqZWN0VG9TdHJpbmcoZCkgPT09ICdbb2JqZWN0IERhdGVdJztcbn1cbmV4cG9ydHMuaXNEYXRlID0gaXNEYXRlO1xuXG5mdW5jdGlvbiBpc0Vycm9yKGUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KGUpICYmXG4gICAgICAob2JqZWN0VG9TdHJpbmcoZSkgPT09ICdbb2JqZWN0IEVycm9yXScgfHwgZSBpbnN0YW5jZW9mIEVycm9yKTtcbn1cbmV4cG9ydHMuaXNFcnJvciA9IGlzRXJyb3I7XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xufVxuZXhwb3J0cy5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcblxuZnVuY3Rpb24gaXNQcmltaXRpdmUoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGwgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ251bWJlcicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3ltYm9sJyB8fCAgLy8gRVM2IHN5bWJvbFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3VuZGVmaW5lZCc7XG59XG5leHBvcnRzLmlzUHJpbWl0aXZlID0gaXNQcmltaXRpdmU7XG5cbmV4cG9ydHMuaXNCdWZmZXIgPSByZXF1aXJlKCcuL3N1cHBvcnQvaXNCdWZmZXInKTtcblxuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcobykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pO1xufVxuXG5cbmZ1bmN0aW9uIHBhZChuKSB7XG4gIHJldHVybiBuIDwgMTAgPyAnMCcgKyBuLnRvU3RyaW5nKDEwKSA6IG4udG9TdHJpbmcoMTApO1xufVxuXG5cbnZhciBtb250aHMgPSBbJ0phbicsICdGZWInLCAnTWFyJywgJ0FwcicsICdNYXknLCAnSnVuJywgJ0p1bCcsICdBdWcnLCAnU2VwJyxcbiAgICAgICAgICAgICAgJ09jdCcsICdOb3YnLCAnRGVjJ107XG5cbi8vIDI2IEZlYiAxNjoxOTozNFxuZnVuY3Rpb24gdGltZXN0YW1wKCkge1xuICB2YXIgZCA9IG5ldyBEYXRlKCk7XG4gIHZhciB0aW1lID0gW3BhZChkLmdldEhvdXJzKCkpLFxuICAgICAgICAgICAgICBwYWQoZC5nZXRNaW51dGVzKCkpLFxuICAgICAgICAgICAgICBwYWQoZC5nZXRTZWNvbmRzKCkpXS5qb2luKCc6Jyk7XG4gIHJldHVybiBbZC5nZXREYXRlKCksIG1vbnRoc1tkLmdldE1vbnRoKCldLCB0aW1lXS5qb2luKCcgJyk7XG59XG5cblxuLy8gbG9nIGlzIGp1c3QgYSB0aGluIHdyYXBwZXIgdG8gY29uc29sZS5sb2cgdGhhdCBwcmVwZW5kcyBhIHRpbWVzdGFtcFxuZXhwb3J0cy5sb2cgPSBmdW5jdGlvbigpIHtcbiAgY29uc29sZS5sb2coJyVzIC0gJXMnLCB0aW1lc3RhbXAoKSwgZXhwb3J0cy5mb3JtYXQuYXBwbHkoZXhwb3J0cywgYXJndW1lbnRzKSk7XG59O1xuXG5cbi8qKlxuICogSW5oZXJpdCB0aGUgcHJvdG90eXBlIG1ldGhvZHMgZnJvbSBvbmUgY29uc3RydWN0b3IgaW50byBhbm90aGVyLlxuICpcbiAqIFRoZSBGdW5jdGlvbi5wcm90b3R5cGUuaW5oZXJpdHMgZnJvbSBsYW5nLmpzIHJld3JpdHRlbiBhcyBhIHN0YW5kYWxvbmVcbiAqIGZ1bmN0aW9uIChub3Qgb24gRnVuY3Rpb24ucHJvdG90eXBlKS4gTk9URTogSWYgdGhpcyBmaWxlIGlzIHRvIGJlIGxvYWRlZFxuICogZHVyaW5nIGJvb3RzdHJhcHBpbmcgdGhpcyBmdW5jdGlvbiBuZWVkcyB0byBiZSByZXdyaXR0ZW4gdXNpbmcgc29tZSBuYXRpdmVcbiAqIGZ1bmN0aW9ucyBhcyBwcm90b3R5cGUgc2V0dXAgdXNpbmcgbm9ybWFsIEphdmFTY3JpcHQgZG9lcyBub3Qgd29yayBhc1xuICogZXhwZWN0ZWQgZHVyaW5nIGJvb3RzdHJhcHBpbmcgKHNlZSBtaXJyb3IuanMgaW4gcjExNDkwMykuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gY3RvciBDb25zdHJ1Y3RvciBmdW5jdGlvbiB3aGljaCBuZWVkcyB0byBpbmhlcml0IHRoZVxuICogICAgIHByb3RvdHlwZS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IHN1cGVyQ3RvciBDb25zdHJ1Y3RvciBmdW5jdGlvbiB0byBpbmhlcml0IHByb3RvdHlwZSBmcm9tLlxuICovXG5leHBvcnRzLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcblxuZXhwb3J0cy5fZXh0ZW5kID0gZnVuY3Rpb24ob3JpZ2luLCBhZGQpIHtcbiAgLy8gRG9uJ3QgZG8gYW55dGhpbmcgaWYgYWRkIGlzbid0IGFuIG9iamVjdFxuICBpZiAoIWFkZCB8fCAhaXNPYmplY3QoYWRkKSkgcmV0dXJuIG9yaWdpbjtcblxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGFkZCk7XG4gIHZhciBpID0ga2V5cy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICBvcmlnaW5ba2V5c1tpXV0gPSBhZGRba2V5c1tpXV07XG4gIH1cbiAgcmV0dXJuIG9yaWdpbjtcbn07XG5cbmZ1bmN0aW9uIGhhc093blByb3BlcnR5KG9iaiwgcHJvcCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7XG59XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi91dGlsL3V0aWwuanNcbiAqKiBtb2R1bGUgaWQgPSA3M1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0J1ZmZlcihhcmcpIHtcbiAgcmV0dXJuIGFyZyAmJiB0eXBlb2YgYXJnID09PSAnb2JqZWN0J1xuICAgICYmIHR5cGVvZiBhcmcuY29weSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICYmIHR5cGVvZiBhcmcuZmlsbCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICYmIHR5cGVvZiBhcmcucmVhZFVJbnQ4ID09PSAnZnVuY3Rpb24nO1xufVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3V0aWwvc3VwcG9ydC9pc0J1ZmZlckJyb3dzZXIuanNcbiAqKiBtb2R1bGUgaWQgPSA3NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiaWYgKHR5cGVvZiBPYmplY3QuY3JlYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gIC8vIGltcGxlbWVudGF0aW9uIGZyb20gc3RhbmRhcmQgbm9kZS5qcyAndXRpbCcgbW9kdWxlXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDdG9yLnByb3RvdHlwZSwge1xuICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgdmFsdWU6IGN0b3IsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9XG4gICAgfSk7XG4gIH07XG59IGVsc2Uge1xuICAvLyBvbGQgc2Nob29sIHNoaW0gZm9yIG9sZCBicm93c2Vyc1xuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgdmFyIFRlbXBDdG9yID0gZnVuY3Rpb24gKCkge31cbiAgICBUZW1wQ3Rvci5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlXG4gICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgVGVtcEN0b3IoKVxuICAgIGN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY3RvclxuICB9XG59XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9pbmhlcml0cy9pbmhlcml0c19icm93c2VyLmpzXG4gKiogbW9kdWxlIGlkID0gNzVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBjb25zb2xlID0gcmVxdWlyZShcImNvbnNvbGVcIik7XG5cbnZhciB1bnRpbGRlID0gZnVuY3Rpb24oc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvfi4vZywgZnVuY3Rpb24obSkge1xuICAgIHN3aXRjaCAobSkge1xuICAgICAgY2FzZSBcIn4wXCI6XG4gICAgICAgIHJldHVybiBcIn5cIjtcbiAgICAgIGNhc2UgXCJ+MVwiOlxuICAgICAgICByZXR1cm4gXCIvXCI7XG4gICAgfVxuICAgIHRocm93KFwiSW52YWxpZCB0aWxkZSBlc2NhcGU6IFwiICsgbSk7XG4gIH0pO1xufVxuXG52YXIgdHJhdmVyc2UgPSBmdW5jdGlvbihvYmosIHBvaW50ZXIsIHZhbHVlKSB7XG4gIC8vIGFzc2VydChpc0FycmF5KHBvaW50ZXIpKVxuICB2YXIgcGFydCA9IHVudGlsZGUocG9pbnRlci5zaGlmdCgpKTtcbiAgaWYodHlwZW9mIG9ialtwYXJ0XSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHRocm93KFwiVmFsdWUgZm9yIHBvaW50ZXIgJ1wiICsgcG9pbnRlciArIFwiJyBub3QgZm91bmQuXCIpO1xuICAgIHJldHVybjtcbiAgfVxuICBpZihwb2ludGVyLmxlbmd0aCAhPT0gMCkgeyAvLyBrZWVwIHRyYXZlcnNpbiFcbiAgICByZXR1cm4gdHJhdmVyc2Uob2JqW3BhcnRdLCBwb2ludGVyLCB2YWx1ZSk7XG4gIH1cbiAgLy8gd2UncmUgZG9uZVxuICBpZih0eXBlb2YgdmFsdWUgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAvLyBqdXN0IHJlYWRpbmdcbiAgICByZXR1cm4gb2JqW3BhcnRdO1xuICB9XG4gIC8vIHNldCBuZXcgdmFsdWUsIHJldHVybiBvbGQgdmFsdWVcbiAgdmFyIG9sZF92YWx1ZSA9IG9ialtwYXJ0XTtcbiAgaWYodmFsdWUgPT09IG51bGwpIHtcbiAgICBkZWxldGUgb2JqW3BhcnRdO1xuICB9IGVsc2Uge1xuICAgIG9ialtwYXJ0XSA9IHZhbHVlO1xuICB9XG4gIHJldHVybiBvbGRfdmFsdWU7XG59XG5cbnZhciB2YWxpZGF0ZV9pbnB1dCA9IGZ1bmN0aW9uKG9iaiwgcG9pbnRlcikge1xuICBpZih0eXBlb2Ygb2JqICE9PSBcIm9iamVjdFwiKSB7XG4gICAgdGhyb3coXCJJbnZhbGlkIGlucHV0IG9iamVjdC5cIik7XG4gIH1cblxuICBpZihwb2ludGVyID09PSBcIlwiKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgaWYoIXBvaW50ZXIpIHtcbiAgICB0aHJvdyhcIkludmFsaWQgSlNPTiBwb2ludGVyLlwiKTtcbiAgfVxuXG4gIHBvaW50ZXIgPSBwb2ludGVyLnNwbGl0KFwiL1wiKTtcbiAgdmFyIGZpcnN0ID0gcG9pbnRlci5zaGlmdCgpO1xuICBpZiAoZmlyc3QgIT09IFwiXCIpIHtcbiAgICB0aHJvdyhcIkludmFsaWQgSlNPTiBwb2ludGVyLlwiKTtcbiAgfVxuXG4gIHJldHVybiBwb2ludGVyO1xufVxuXG52YXIgZ2V0ID0gZnVuY3Rpb24ob2JqLCBwb2ludGVyKSB7XG4gIHBvaW50ZXIgPSB2YWxpZGF0ZV9pbnB1dChvYmosIHBvaW50ZXIpO1xuICBpZiAocG9pbnRlci5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gb2JqO1xuICB9XG4gIHJldHVybiB0cmF2ZXJzZShvYmosIHBvaW50ZXIpO1xufVxuXG52YXIgc2V0ID0gZnVuY3Rpb24ob2JqLCBwb2ludGVyLCB2YWx1ZSkge1xuICBwb2ludGVyID0gdmFsaWRhdGVfaW5wdXQob2JqLCBwb2ludGVyKTtcbiAgaWYgKHBvaW50ZXIubGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3coXCJJbnZhbGlkIEpTT04gcG9pbnRlciBmb3Igc2V0LlwiKVxuICB9XG4gIHJldHVybiB0cmF2ZXJzZShvYmosIHBvaW50ZXIsIHZhbHVlKTtcbn1cblxuZXhwb3J0cy5nZXQgPSBnZXRcbmV4cG9ydHMuc2V0ID0gc2V0XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9qc29ucG9pbnRlci9qc29ucG9pbnRlci5qc1xuICoqIG1vZHVsZSBpZCA9IDc2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBBdm9pZCBgY29uc29sZWAgZXJyb3JzIGluIGVudmlyb25tZW50cyB0aGF0IGxhY2sgYSBjb25zb2xlLlxudmFyIG1ldGhvZDtcbnZhciBub29wID0gZnVuY3Rpb24gKCkge307XG52YXIgbWV0aG9kcyA9IFtcbiAgICAnYXNzZXJ0JywgJ2NsZWFyJywgJ2NvdW50JywgJ2RlYnVnJywgJ2RpcicsICdkaXJ4bWwnLCAnZXJyb3InLFxuICAgICdleGNlcHRpb24nLCAnZ3JvdXAnLCAnZ3JvdXBDb2xsYXBzZWQnLCAnZ3JvdXBFbmQnLCAnaW5mbycsICdsb2cnLFxuICAgICdtYXJrVGltZWxpbmUnLCAncHJvZmlsZScsICdwcm9maWxlRW5kJywgJ3RhYmxlJywgJ3RpbWUnLCAndGltZUVuZCcsXG4gICAgJ3RpbWVTdGFtcCcsICd0cmFjZScsICd3YXJuJ1xuXTtcbnZhciBsZW5ndGggPSBtZXRob2RzLmxlbmd0aDtcblxud2hpbGUgKGxlbmd0aC0tKSB7XG4gIG1ldGhvZCA9IG1ldGhvZHNbbGVuZ3RoXTtcblxuICAvLyBPbmx5IHN0dWIgdW5kZWZpbmVkIG1ldGhvZHMuXG4gIGlmICghY29uc29sZVttZXRob2RdKSB7XG4gICAgY29uc29sZVttZXRob2RdID0gbm9vcDtcbiAgfVxufVxuXG5pZiAoKHR5cGVvZiBtb2R1bGUgIT09IFwidW5kZWZpbmVkXCIgJiYgbW9kdWxlICE9PSBudWxsKSAmJiBtb2R1bGUuZXhwb3J0cykge1xuICBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBjb25zb2xlO1xufSBlbHNlIHtcbiAgd2luZG93LmNvbnNvbGUgPSBjb25zb2xlO1xufVxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29uc29sZS9jb25zb2xlLmpzXG4gKiogbW9kdWxlIGlkID0gNzdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obW9kdWxlKSB7XHJcblx0aWYoIW1vZHVsZS53ZWJwYWNrUG9seWZpbGwpIHtcclxuXHRcdG1vZHVsZS5kZXByZWNhdGUgPSBmdW5jdGlvbigpIHt9O1xyXG5cdFx0bW9kdWxlLnBhdGhzID0gW107XHJcblx0XHQvLyBtb2R1bGUucGFyZW50ID0gdW5kZWZpbmVkIGJ5IGRlZmF1bHRcclxuXHRcdG1vZHVsZS5jaGlsZHJlbiA9IFtdO1xyXG5cdFx0bW9kdWxlLndlYnBhY2tQb2x5ZmlsbCA9IDE7XHJcblx0fVxyXG5cdHJldHVybiBtb2R1bGU7XHJcbn1cclxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAod2VicGFjaykvYnVpbGRpbi9tb2R1bGUuanNcbiAqKiBtb2R1bGUgaWQgPSA3OFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBAY29weXJpZ2h0IDIwMTQsIE1hdGhpYXMgQnV1c1xuICogQGNvcHlyaWdodCAyMDE1LCBQcm9tZXRoZXVzIFJlc2VhcmNoLCBMTENcbiAqL1xuXG5sZXQgRm9ybWF0ID0ge307XG5cbkZvcm1hdFsnZGF0ZS10aW1lJ10gPSAvXlxcZHs0fS0oPzowWzAtOV17MX18MVswLTJdezF9KS1bMC05XXsyfVt0VCBdXFxkezJ9OlxcZHsyfTpcXGR7Mn0oXFwuXFxkKyk/KFt6Wl18WystXVxcZHsyfTpcXGR7Mn0pJC87IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbWF4LWxlblxuRm9ybWF0WydkYXRlJ10gPSAvXlxcZHs0fS0oPzowWzAtOV17MX18MVswLTJdezF9KS1bMC05XXsyfSQvO1xuRm9ybWF0Wyd0aW1lJ10gPSAvXlxcZHsyfTpcXGR7Mn06XFxkezJ9JC87XG5Gb3JtYXRbJ2VtYWlsJ10gPSAvXlxcUytAXFxTKyQvO1xuRm9ybWF0WydpcC1hZGRyZXNzJ10gPSBGb3JtYXRbJ2lwdjQnXSA9IC9eKD86KD86MjVbMC01XXwyWzAtNF1bMC05XXxbMDFdP1swLTldWzAtOV0/KVxcLil7M30oPzoyNVswLTVdfDJbMC00XVswLTldfFswMV0/WzAtOV1bMC05XT8pJC87IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbWF4LWxlblxuRm9ybWF0WydpcHY2J10gPSAvXlxccyooKChbMC05QS1GYS1mXXsxLDR9Oil7N30oWzAtOUEtRmEtZl17MSw0fXw6KSl8KChbMC05QS1GYS1mXXsxLDR9Oil7Nn0oOlswLTlBLUZhLWZdezEsNH18KCgyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkoXFwuKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSl7M30pfDopKXwoKFswLTlBLUZhLWZdezEsNH06KXs1fSgoKDpbMC05QS1GYS1mXXsxLDR9KXsxLDJ9KXw6KCgyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkoXFwuKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSl7M30pfDopKXwoKFswLTlBLUZhLWZdezEsNH06KXs0fSgoKDpbMC05QS1GYS1mXXsxLDR9KXsxLDN9KXwoKDpbMC05QS1GYS1mXXsxLDR9KT86KCgyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkoXFwuKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSl7M30pKXw6KSl8KChbMC05QS1GYS1mXXsxLDR9Oil7M30oKCg6WzAtOUEtRmEtZl17MSw0fSl7MSw0fSl8KCg6WzAtOUEtRmEtZl17MSw0fSl7MCwyfTooKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKShcXC4oMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKXszfSkpfDopKXwoKFswLTlBLUZhLWZdezEsNH06KXsyfSgoKDpbMC05QS1GYS1mXXsxLDR9KXsxLDV9KXwoKDpbMC05QS1GYS1mXXsxLDR9KXswLDN9OigoMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKFxcLigyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkpezN9KSl8OikpfCgoWzAtOUEtRmEtZl17MSw0fTopezF9KCgoOlswLTlBLUZhLWZdezEsNH0pezEsNn0pfCgoOlswLTlBLUZhLWZdezEsNH0pezAsNH06KCgyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkoXFwuKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSl7M30pKXw6KSl8KDooKCg6WzAtOUEtRmEtZl17MSw0fSl7MSw3fSl8KCg6WzAtOUEtRmEtZl17MSw0fSl7MCw1fTooKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKShcXC4oMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKXszfSkpfDopKSkoJS4rKT9cXHMqJC87IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbWF4LWxlblxuRm9ybWF0Wyd1cmknXSA9IC9eW2EtekEtWl1bYS16QS1aMC05Ky0uXSo6W15cXHNdKiQvO1xuRm9ybWF0Wydjb2xvciddID0gLygjPyhbMC05QS1GYS1mXXszLDZ9KVxcYil8KGFxdWEpfChibGFjayl8KGJsdWUpfChmdWNoc2lhKXwoZ3JheSl8KGdyZWVuKXwobGltZSl8KG1hcm9vbil8KG5hdnkpfChvbGl2ZSl8KG9yYW5nZSl8KHB1cnBsZSl8KHJlZCl8KHNpbHZlcil8KHRlYWwpfCh3aGl0ZSl8KHllbGxvdyl8KHJnYlxcKFxccypcXGIoWzAtOV18WzEtOV1bMC05XXwxWzAtOV1bMC05XXwyWzAtNF1bMC05XXwyNVswLTVdKVxcYlxccyosXFxzKlxcYihbMC05XXxbMS05XVswLTldfDFbMC05XVswLTldfDJbMC00XVswLTldfDI1WzAtNV0pXFxiXFxzKixcXHMqXFxiKFswLTldfFsxLTldWzAtOV18MVswLTldWzAtOV18MlswLTRdWzAtOV18MjVbMC01XSlcXGJcXHMqXFwpKXwocmdiXFwoXFxzKihcXGQ/XFxkJXwxMDAlKStcXHMqLFxccyooXFxkP1xcZCV8MTAwJSkrXFxzKixcXHMqKFxcZD9cXGQlfDEwMCUpK1xccypcXCkpLzsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBtYXgtbGVuXG5Gb3JtYXRbJ2hvc3RuYW1lJ10gPSAvXihbYS16QS1aMC05XXxbYS16QS1aMC05XVthLXpBLVowLTlcXC1dezAsNjF9W2EtekEtWjAtOV0pKFxcLihbYS16QS1aMC05XXxbYS16QS1aMC05XVthLXpBLVowLTlcXC1dezAsNjF9W2EtekEtWjAtOV0pKSokLzsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBtYXgtbGVuXG5Gb3JtYXRbJ2FscGhhJ10gPSAvXlthLXpBLVpdKyQvO1xuRm9ybWF0WydhbHBoYW51bWVyaWMnXSA9IC9eW2EtekEtWjAtOV0rJC87XG5Gb3JtYXRbJ3N0eWxlJ10gPSAvXFxzKiguKz8pOlxccyooW147XSspOz8vZztcbkZvcm1hdFsncGhvbmUnXSA9IC9eXFwrKD86WzAtOV0gPyl7NiwxNH1bMC05XSQvO1xuRm9ybWF0Wyd1dGMtbWlsbGlzZWMnXSA9IC9eWzAtOV0rKFxcLj9bMC05XSspPyQvO1xuXG5leHBvcnQgZGVmYXVsdCBGb3JtYXQ7XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9KU09OU2NoZW1hL0Zvcm1hdC5qc1xuICoqLyIsIi8qKlxuICogQGNvcHlyaWdodCAyMDE1LCBQcm9tZXRoZXVzIFJlc2VhcmNoLCBMTENcbiAqL1xuXG5pbXBvcnQgUmVhY3QgICAgICAgICBmcm9tICdyZWFjdCc7XG5pbXBvcnQgRm9ybUNvbXBvbmVudCBmcm9tICcuL0NvbXBvbmVudCc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFdpdGhGb3JtVmFsdWUoQ29tcG9uZW50KSB7XG5cbiAgbGV0IGRpc3BsYXlOYW1lID0gQ29tcG9uZW50LmRpc3BsYXlOYW1lIHx8IENvbXBvbmVudC5uYW1lO1xuXG4gIHJldHVybiBjbGFzcyBleHRlbmRzIEZvcm1Db21wb25lbnQge1xuXG4gICAgc3RhdGljIGRpc3BsYXlOYW1lID0gYFdpdGhGb3JtVmFsdWUoJHtkaXNwbGF5TmFtZX0pYDtcblxuICAgIHJlbmRlcigpIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIDxDb21wb25lbnRcbiAgICAgICAgICB7Li4udGhpcy5wcm9wc31cbiAgICAgICAgICBmb3JtVmFsdWU9e3RoaXMuZm9ybVZhbHVlfVxuICAgICAgICAgIC8+XG4gICAgICApO1xuICAgIH1cbiAgfTtcbn1cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL1dpdGhGb3JtVmFsdWUuanNcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9