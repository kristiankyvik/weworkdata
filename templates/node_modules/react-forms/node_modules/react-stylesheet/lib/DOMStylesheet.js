/**
 * @copyright 2015 Prometheus Research, LLC
 */

'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createDecoratedClass = (function () { function defineProperties(target, descriptors, initializers) { for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === 'function') { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator); } } if (descriptor.initializer !== undefined) { initializers[key] = descriptor; continue; } } Object.defineProperty(target, key, descriptor); } } return function (Constructor, protoProps, staticProps, protoInitializers, staticInitializers) { if (protoProps) defineProperties(Constructor.prototype, protoProps, protoInitializers); if (staticProps) defineProperties(Constructor, staticProps, staticInitializers); return Constructor; }; })();

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.createStylesheet = createStylesheet;
exports.isValidStylesheet = isValidStylesheet;
exports.overrideStylesheet = overrideStylesheet;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var _memoizeDecorator = require('memoize-decorator');

var _memoizeDecorator2 = _interopRequireDefault(_memoizeDecorator);

var _styleLoaderAddStyles = require('style-loader/addStyles');

var _styleLoaderAddStyles2 = _interopRequireDefault(_styleLoaderAddStyles);

var _reactLibCSSPropertyOperations = require('react/lib/CSSPropertyOperations');

var _reactLibCSSPropertyOperations2 = _interopRequireDefault(_reactLibCSSPropertyOperations);

var _reactLibDangerousStyleValue = require('react/lib/dangerousStyleValue');

var _reactLibDangerousStyleValue2 = _interopRequireDefault(_reactLibDangerousStyleValue);

var _Utils = require('./Utils');

/**
 * Special key which designates the rules which should be applied even if no
 * variant is being active.
 */
var BASE = 'base';

/**
 * Special key which is used to store className in mapping.
 */
var CLASSNAME = 'className';

/**
 * Styles we want to be added to every CSS class.
 */
var DEFAULT_STYLE = {
  boxSizing: 'border-box'
};

/**
 * Variant names we want to see compiled as CSS pseudo classes.
 */
var SUPPORTED_PSEUDO_CLASSES = {
  focus: true,
  hover: true,
  active: true,
  checked: true,
  'default': true,
  disabled: true,
  empty: true,
  enabled: true,
  firstChild: true,
  fullscreen: true,
  indeterminate: true,
  invalid: true,
  lastChild: true,
  left: true,
  link: true,
  onlyChild: true,
  optional: true,
  required: true,
  right: true,
  root: true,
  scope: true,
  target: true,
  valid: true,
  visited: true
};

/**
 * Create a new stylesheet from stylesheet spec.
 */

function createStylesheet(spec) {
  var id = arguments.length <= 1 || arguments[1] === undefined ? '' : arguments[1];

  id = (0, _Utils.uniqueID)(id ? 'Style_' + id : 'Style');
  return new DOMStylesheet(parseSpecToStyle(spec), id);
}

/**
 * Check if object is a valida stylesheet.
 */

function isValidStylesheet(obj) {
  return obj instanceof DOMStylesheet;
}

/**
 * Produce a new stylesheet by overriding an existing one with a new stylesheet
 * spec.
 */

function overrideStylesheet(stylesheet, override, id) {
  override = isValidStylesheet(override) ? override.style : parseSpecToStyle(override);
  var style = overrideStyle(stylesheet.style, override);
  id = (0, _Utils.uniqueID)(id ? 'Style_' + id : 'Style');
  return new DOMStylesheet(style, id);
}

function overrideStyle(style, override) {
  var nextStyle = _extends({}, style);
  for (var key in override) {
    if (!override.hasOwnProperty(key)) {
      continue;
    }
    if (key === BASE) {
      nextStyle[key] = _extends({}, nextStyle[key], override[key]);
    } else {
      nextStyle[key] = overrideStyle(nextStyle[key], override[key]);
    }
  }
  return nextStyle;
}

/**
 * DOM stylesheet is a collection of classes which are applied to a single DOM
 * element.
 */

var DOMStylesheet = (function () {
  function DOMStylesheet(style, id) {
    _classCallCheck(this, DOMStylesheet);

    this.style = style;
    this.id = id;

    this._refs = 0;
    this._remove = null;
    this._disposePerform = this._disposePerform.bind(this);
    this._disposeTimer = null;
  }

  /**
   * Resolve variant to CSS class name.
   */

  _createDecoratedClass(DOMStylesheet, [{
    key: 'asClassName',
    value: function asClassName() {
      var variant = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

      return resolveVariantToClassName(this.mapping, variant).join(' ');
    }
  }, {
    key: 'use',
    value: function use() {
      this._refs = this._refs + 1;
      if (this._disposeTimer !== null) {
        clearTimeout(this._disposeTimer);
        this._disposeTimer = null;
      }
      if (this._remove === null) {
        this._remove = (0, _styleLoaderAddStyles2['default'])(this.css);
      }
      return this;
    }
  }, {
    key: 'dispose',
    value: function dispose() {
      this._refs = this._refs - 1;
      if (this._disposeTimer === null) {
        this._disposeTimer = setTimeout(this._disposePerform, 0);
      }
      return this;
    }
  }, {
    key: '_disposePerform',
    value: function _disposePerform() {
      if (this._refs < 1) {
        this._remove();
        this._remove = null;
      }
    }
  }, {
    key: '_compiled',
    decorators: [_memoizeDecorator2['default']],
    get: function get() {
      return compileStyle(this.style, this.id);
    }
  }, {
    key: 'css',
    get: function get() {
      return [[this.id, this._compiled.css.join('\n')]];
    }
  }, {
    key: 'mapping',
    get: function get() {
      return this._compiled.mapping;
    }
  }]);

  return DOMStylesheet;
})();

function resolveVariantToClassName(mapping, variant) {
  var classList = [];

  for (var key in mapping) {
    if (key === CLASSNAME) {
      classList.push(mapping[key]);
    } else if (variant[key]) {
      var subClassList = resolveVariantToClassName(mapping[key], variant);
      for (var i = 0; i < subClassList.length; i++) {
        classList.push(subClassList[i]);
      }
    }
  }

  return classList;
}

/**
 * Parse style spec to style object.
 */
function parseSpecToStyle(spec) {
  var root = arguments.length <= 1 || arguments[1] === undefined ? true : arguments[1];

  var styleBase = root ? _extends({}, DEFAULT_STYLE) : {};
  var style = _defineProperty({}, BASE, styleBase);
  for (var key in spec) {
    if (!spec.hasOwnProperty(key)) {
      continue;
    }
    var item = spec[key];
    if ((0, _Utils.isPlainObject)(item)) {
      style[key] = parseSpecToStyle(item, false);
    } else {
      styleBase[key] = _value(key, item);
    }
  }
  return style;
}

/**
 * Compile style into CSS string with mapping from variant names to CSS class
 * names.
 */
function compileStyle(style, id) {
  var path = arguments.length <= 2 || arguments[2] === undefined ? [] : arguments[2];
  var variant = arguments.length <= 3 || arguments[3] === undefined ? null : arguments[3];

  var mapping = {};
  var css = [];
  for (var key in style) {
    if (!style.hasOwnProperty(key)) {
      continue;
    }
    var value = style[key];
    if (key === BASE) {
      if (variant !== null) {
        var className = _className(id, path, variant);
        mapping[variant] = mapping[variant] || {};
        mapping[variant][CLASSNAME] = className;

        if (SUPPORTED_PSEUDO_CLASSES[variant]) {
          var pseudoClassName = _className(id, path, variant, true);
          css.push(compileClass('.' + className + ', .' + pseudoClassName, value));
        } else {
          css.push(compileClass('.' + className, value));
        }
      } else {
        css.push(compileClass('.' + id, value));
        mapping[CLASSNAME] = id;
      }
    } else {
      var nextPath = variant === null ? path : path.concat(variant);
      var subResult = compileStyle(value, id, nextPath, key);
      mapping[key] = subResult.mapping;
      css = css.concat(subResult.css);
    }
  }
  return { css: css, mapping: mapping };
}

/**
 * Compile class name and rule set into CSS class.
 */
function compileClass(className, ruleSet) {
  var css = className + ' { ' + _reactLibCSSPropertyOperations2['default'].createMarkupForStyles(ruleSet) + ' }';
  return css;
}

/**
 * Create a CSS class name.
 */
function _className(id, path, variant) {
  var asPseudo = arguments.length <= 3 || arguments[3] === undefined ? false : arguments[3];

  var className = '' + id;
  if (path.length > 0) {
    className = className + ('--' + path.join('--'));
  }
  if (variant) {
    if (asPseudo) {
      className = className + (':' + (0, _Utils.toDashCase)(variant));
    } else {
      className = className + ('--' + variant);
    }
  }
  return className;
}

/**
 * Process ruleSet value.
 */
function _value(key, value) {
  if ((0, _Utils.isArray)(value) && value.length > 0) {
    var rest = value.slice(1).map(function (v) {
      return key + ':' + (0, _reactLibDangerousStyleValue2['default'])(key, v);
    });
    value = [(0, _reactLibDangerousStyleValue2['default'])(key, value[0])].concat(rest).join(';');
  }
  return value;
}
